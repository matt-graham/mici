<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mici.samplers &mdash; Mici 0.2.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/mici-logo-rectangular.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mici.html">mici package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Mici</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mici.samplers</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mici.samplers</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Monte Carlo sampler classes for peforming inference.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">queue</span>
<span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">ExitStack</span><span class="p">,</span> <span class="n">contextmanager</span><span class="p">,</span> <span class="n">nullcontext</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pickle</span> <span class="kn">import</span> <span class="n">PicklingError</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">NamedTuple</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">default_rng</span>

<span class="kn">from</span> <span class="nn">mici.adapters</span> <span class="kn">import</span> <span class="n">DualAveragingStepSizeAdapter</span>
<span class="kn">from</span> <span class="nn">mici.errors</span> <span class="kn">import</span> <span class="n">AdaptationError</span>
<span class="kn">from</span> <span class="nn">mici.progressbars</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DummyProgressBar</span><span class="p">,</span>
    <span class="n">LabelledSequenceProgressBar</span><span class="p">,</span>
    <span class="n">SequenceProgressBar</span><span class="p">,</span>
    <span class="n">_ProxySequenceProgressBar</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">mici.stagers</span> <span class="kn">import</span> <span class="n">WarmUpStager</span><span class="p">,</span> <span class="n">WindowedWarmUpStager</span>
<span class="kn">from</span> <span class="nn">mici.states</span> <span class="kn">import</span> <span class="n">ChainState</span>
<span class="kn">from</span> <span class="nn">mici.transitions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IndependentMomentumTransition</span><span class="p">,</span>
    <span class="n">MetropolisRandomIntegrationTransition</span><span class="p">,</span>
    <span class="n">MetropolisStaticIntegrationTransition</span><span class="p">,</span>
    <span class="n">MultinomialDynamicIntegrationTransition</span><span class="p">,</span>
    <span class="n">SliceDynamicIntegrationTransition</span><span class="p">,</span>
    <span class="n">euclidean_no_u_turn_criterion</span><span class="p">,</span>
    <span class="n">riemannian_no_u_turn_criterion</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Container</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Sequence</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

    <span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">NDArray</span>

    <span class="kn">from</span> <span class="nn">mici.adapters</span> <span class="kn">import</span> <span class="n">Adapter</span>
    <span class="kn">from</span> <span class="nn">mici.integrators</span> <span class="kn">import</span> <span class="n">Integrator</span>
    <span class="kn">from</span> <span class="nn">mici.progressbars</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
    <span class="kn">from</span> <span class="nn">mici.stagers</span> <span class="kn">import</span> <span class="n">Stager</span>
    <span class="kn">from</span> <span class="nn">mici.systems</span> <span class="kn">import</span> <span class="n">System</span>
    <span class="kn">from</span> <span class="nn">mici.transitions</span> <span class="kn">import</span> <span class="n">IntegrationTransition</span><span class="p">,</span> <span class="n">MomentumTransition</span><span class="p">,</span> <span class="n">Transition</span>
    <span class="kn">from</span> <span class="nn">mici.types</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">AdapterState</span><span class="p">,</span>
        <span class="n">ChainIterator</span><span class="p">,</span>
        <span class="n">PyTree</span><span class="p">,</span>
        <span class="n">ScalarLike</span><span class="p">,</span>
        <span class="n">TerminationCriterion</span><span class="p">,</span>
        <span class="n">TraceFunction</span><span class="p">,</span>
    <span class="p">)</span>

<span class="c1"># Preferentially import from multiprocess library if available as able to</span>
<span class="c1"># serialize much wider range of types including autograd functions</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">multiprocess</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Queue</span>
    <span class="kn">from</span> <span class="nn">multiprocess.managers</span> <span class="kn">import</span> <span class="n">SyncManager</span>

    <span class="n">MULTIPROCESS_AVAILABLE</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Queue</span>
    <span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">SyncManager</span>

    <span class="n">MULTIPROCESS_AVAILABLE</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">threadpoolctl</span> <span class="kn">import</span> <span class="n">threadpool_limits</span>

    <span class="n">THREADPOOLCTL_AVAILABLE</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">THREADPOOLCTL_AVAILABLE</span> <span class="o">=</span> <span class="kc">False</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ignore_sigint_initializer</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initializer for processes to force ignoring SIGINT interrupt signals.&quot;&quot;&quot;</span>
    <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIG_IGN</span><span class="p">)</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">_ignore_sigint_manager</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context-managed SyncManager which ignores SIGINT interrupt signals.&quot;&quot;&quot;</span>
    <span class="n">manager</span> <span class="o">=</span> <span class="n">SyncManager</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">manager</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">_ignore_sigint_initializer</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">manager</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">manager</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">_pool_context_manager</span><span class="p">(</span><span class="n">n_process</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context-manager for process pool that ensures clean exiting.</span>

<span class="sd">    Compared to built-in context-manager protocol implementation on Pool object which</span>
<span class="sd">    calls the `terminate` method on exit which immediately stops the worker processes,</span>
<span class="sd">    this manager instead ensures a clean exit by calling `close` to prevent any</span>
<span class="sd">    additional jobs being submitted to pool, and then `join` to wait for processes to</span>
<span class="sd">    exit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">n_process</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">pool</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_get_valid_filename</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a valid filename from a string.</span>

<span class="sd">    Strips all characters which are not alphanumeric or a period (.), dash (-)</span>
<span class="sd">    or underscore (_).</span>

<span class="sd">    Based on https://stackoverflow.com/a/295146/4798943</span>

<span class="sd">    Args:</span>
<span class="sd">        string: String file name to process.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Generated file name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">string</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span> <span class="ow">or</span> <span class="n">c</span> <span class="ow">in</span> <span class="s2">&quot;._- &quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_generate_memmap_filenames</span><span class="p">(</span>
    <span class="n">dir_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate new memory-map filenames.&quot;&quot;&quot;</span>
    <span class="n">key_str</span> <span class="o">=</span> <span class="n">_get_valid_filename</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
    <span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">dir_path</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dir_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key_str</span><span class="si">}</span><span class="s2">.npy&quot;</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_open_new_memmap</span><span class="p">(</span>
    <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="n">default_val</span><span class="p">:</span> <span class="n">ScalarLike</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Open a new memory-mapped array object and fill with a default-value.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_path: Path to write memory-mapped array to.</span>
<span class="sd">        shape: Shape of new array.</span>
<span class="sd">        default_val: Value to fill array with. Should be compatible with specified</span>
<span class="sd">            `dtype`.</span>
<span class="sd">        dtype: NumPy data-type for array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Memory-mapped array object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>
    <span class="n">memmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">open_memmap</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w+&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">memmap</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">default_val</span>
    <span class="k">return</span> <span class="n">memmap</span>


<span class="k">def</span> <span class="nf">_memmaps_to_file_paths</span><span class="p">(</span><span class="n">pytree</span><span class="p">:</span> <span class="n">PyTree</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">PyTree</span><span class="p">[</span><span class="n">Path</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert any memmaps in pytree to corresponding file paths.</span>

<span class="sd">    Acts recursively on arbitrary &#39;pytrees&#39; of nested dict/tuple/lists with any object</span>
<span class="sd">    which is none of a memory map, dictionary, tuple or list returned as is.</span>

<span class="sd">    Arg:</span>
<span class="sd">        pytree: Pytree of objects to convert.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Pytree with same structure as `pytree` and any memory maps converted to paths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytree</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">pytree</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytree</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_memmaps_to_file_paths</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pytree</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytree</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">_memmaps_to_file_paths</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pytree</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytree</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_memmaps_to_file_paths</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pytree</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pytree</span>


<span class="k">def</span> <span class="nf">_file_paths_to_memmaps</span><span class="p">(</span><span class="n">pytree</span><span class="p">:</span> <span class="n">PyTree</span><span class="p">[</span><span class="n">Path</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">PyTree</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert any paths in pytree to corresponding memory-mapped arrays.</span>

<span class="sd">    Acts recursively on arbitrary &#39;pytrees&#39; of nested dict/tuple/lists with any object</span>
<span class="sd">    which is none of a path, dictionary, tuple or list returned as is.</span>

<span class="sd">    Arg:</span>
<span class="sd">        pytree: Pytree of objects to convert.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Pytree with same structure as `pytree` and any paths converted to memory maps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytree</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">open_memmap</span><span class="p">(</span><span class="n">pytree</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytree</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_file_paths_to_memmaps</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pytree</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytree</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">_file_paths_to_memmaps</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pytree</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytree</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_file_paths_to_memmaps</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pytree</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pytree</span>


<span class="k">def</span> <span class="nf">_zip_dict</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Zip iterable keyword arguments in to an iterable of dictionaries.</span>

<span class="sd">    Acts analogously to built-in `zip` in taking a variable number of iterables as</span>
<span class="sd">    arguments and returning an iterable which iterates over collections of values</span>
<span class="sd">    from each of the iterables, however unlike `zip` here the input iterables must be</span>
<span class="sd">    specified as keyword arguments and the returned collections are dictionaries rather</span>
<span class="sd">    than tuples, with keys specified by the argument names.</span>

<span class="sd">    For example</span>

<span class="sd">        list(_zip_dict(a=[1, 2, 3], b=[4, 5, 6]))</span>

<span class="sd">    Produces</span>

<span class="sd">        [{&#39;a&#39;: 1, &#39;b&#39;: 4}, {&#39;a&#39;: 2, &#39;b&#39;: 5}, {&#39;a&#39;: 3, &#39;b&#39;: 6}]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">val_set</span><span class="p">))</span> <span class="k">for</span> <span class="n">val_set</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>


<span class="k">def</span> <span class="nf">_check_and_process_init_state</span><span class="p">(</span>
    <span class="n">state</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ChainState</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span>
    <span class="n">transitions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Transition</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ChainState</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check initial chain state is valid and convert dict to ChainState.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">trans_key</span><span class="p">,</span> <span class="n">transition</span> <span class="ow">in</span> <span class="n">transitions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">var_key</span> <span class="ow">in</span> <span class="n">transition</span><span class="o">.</span><span class="n">state_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;init_state does contain have </span><span class="si">{</span><span class="n">var_key</span><span class="si">}</span><span class="s2"> value required by &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">trans_key</span><span class="si">}</span><span class="s2"> transition.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">(</span><span class="n">ChainState</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;init_state should be a dictionary or ChainState.&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ChainState</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">state</span>


<span class="k">def</span> <span class="nf">_init_stats</span><span class="p">(</span>
    <span class="n">transitions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Transition</span><span class="p">],</span>
    <span class="n">n_chain</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">use_memmap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">memmap_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize dictionary of per-transition chain statistics array dicts.&quot;&quot;&quot;</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">trans_key</span><span class="p">,</span> <span class="n">transition</span> <span class="ow">in</span> <span class="n">transitions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">statistic_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stats</span><span class="p">[</span><span class="n">trans_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">transition</span><span class="o">.</span><span class="n">statistic_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">use_memmap</span><span class="p">:</span>
                    <span class="n">stats</span><span class="p">[</span><span class="n">trans_key</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">_open_new_memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">_generate_memmap_filenames</span><span class="p">(</span>
                            <span class="n">memmap_path</span><span class="p">,</span>
                            <span class="s2">&quot;stats&quot;</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">trans_key</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stats</span><span class="p">[</span><span class="n">trans_key</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_chain</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">),</span> <span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">stats</span>


<span class="k">def</span> <span class="nf">_init_traces</span><span class="p">(</span>
    <span class="n">trace_funcs</span><span class="p">:</span> <span class="n">TraceFunction</span><span class="p">,</span>
    <span class="n">init_states</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ChainState</span><span class="p">],</span>
    <span class="n">n_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">use_memmap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">memmap_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize dictionary of chain trace arrays.&quot;&quot;&quot;</span>
    <span class="n">traces</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">n_chain</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_states</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">trace_func</span> <span class="ow">in</span> <span class="n">trace_funcs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">trace_func</span><span class="p">(</span><span class="n">init_states</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">array_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">else</span> <span class="n">val</span>
            <span class="n">init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">array_val</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">use_memmap</span><span class="p">:</span>
                <span class="n">traces</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">_open_new_memmap</span><span class="p">(</span>
                        <span class="n">filename</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">n_iter</span><span class="p">,</span> <span class="o">*</span><span class="n">array_val</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                        <span class="n">init</span><span class="p">,</span>
                        <span class="n">array_val</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">_generate_memmap_filenames</span><span class="p">(</span>
                        <span class="n">memmap_path</span><span class="p">,</span>
                        <span class="s2">&quot;trace&quot;</span><span class="p">,</span>
                        <span class="n">key</span><span class="p">,</span>
                        <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">traces</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">n_chain</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">,</span> <span class="o">*</span><span class="n">array_val</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                        <span class="n">init</span><span class="p">,</span>
                        <span class="n">array_val</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">traces</span>


<span class="k">def</span> <span class="nf">_construct_chain_iterators</span><span class="p">(</span>
    <span class="n">n_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">chain_iterator_class</span><span class="p">:</span> <span class="n">ProgressBar</span><span class="p">,</span>
    <span class="n">n_chain</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">position_offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ProgressBar</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set up chain iterator progress bar object(s).&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">chain_iterator_class</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">),</span>
            <span class="n">description</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Chain </span><span class="si">{</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">n_chain</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">position_offset</span><span class="p">,</span> <span class="n">n_chain</span> <span class="o">+</span> <span class="n">position_offset</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">)</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_update_chain_stats</span><span class="p">(</span>
    <span class="n">sample_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">chain_stats</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">]],</span>
    <span class="n">trans_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">trans_stats</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update chain statistics arrays for current chain iteration.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">trans_stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">trans_stats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">chain_stats</span><span class="p">[</span><span class="n">trans_key</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">sample_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_update_monitor_stats</span><span class="p">(</span>
    <span class="n">monitor_stats</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Container</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">monitor_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">],</span>
    <span class="n">trans_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">trans_stats</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update dictionary of per-iteration monitored statistics.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">trans_key</span> <span class="ow">in</span> <span class="n">monitor_stats</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">stats_key</span> <span class="ow">in</span> <span class="n">monitor_stats</span><span class="p">[</span><span class="n">trans_key</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">trans_stats</span><span class="p">[</span><span class="n">stats_key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Monitored statistics key </span><span class="si">{</span><span class="n">stats_key</span><span class="si">}</span><span class="s2"> is not present in &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;statistics returned by transition </span><span class="si">{</span><span class="n">trans_key</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
            <span class="k">if</span> <span class="n">stats_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">monitor_dict</span><span class="p">:</span>
                <span class="n">monitor_dict</span><span class="p">[</span><span class="n">stats_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">monitor_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">trans_key</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">stats_key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_flush_memmap_chain_data</span><span class="p">(</span>
    <span class="n">chain_traces</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">],</span>
    <span class="n">chain_stats</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">]],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flush all pending writes to memory-mapped chain data arrays to disk.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">chain_traces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">chain_traces</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;flush&quot;</span><span class="p">):</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">chain_stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">trans_stats</span> <span class="ow">in</span> <span class="n">chain_stats</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">trans_stats</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="s2">&quot;flush&quot;</span><span class="p">):</span>
                    <span class="n">stat</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_sample_chain</span><span class="p">(</span>
    <span class="n">init_state</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ChainState</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">]],</span>
    <span class="n">chain_iterator</span><span class="p">:</span> <span class="n">ChainIterator</span><span class="p">,</span>
    <span class="n">rng</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span>
    <span class="n">transitions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Transition</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">trace_funcs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TraceFunction</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">chain_traces</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">chain_stats</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">load_memmaps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">chain_index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">sampling_index_offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">monitor_stats</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Container</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">adapters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Adapter</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ChainState</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">AdapterState</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample a chain by iteratively appyling a sequence of transition kernels.</span>

<span class="sd">    Args:</span>
<span class="sd">        init_state: Initial chain state. Either a `mici.states.ChainState` object or a</span>
<span class="sd">            dictionary with entries specifying initial values for all state variables</span>
<span class="sd">            used by chain transition `sample` methods.</span>
<span class="sd">        chain_iterator: Iterable object which is iterated over to produce sample indices</span>
<span class="sd">            and (empty) iteration statistic dictionaries to output monitored chain</span>
<span class="sd">            statistics to during sampling.</span>
<span class="sd">        rng: Numpy random number generator.</span>
<span class="sd">        transitions: Ordered dictionary of Markov transitions kernels to sequentially</span>
<span class="sd">            sample from on each chain iteration.</span>
<span class="sd">        trace_funcs: Sequence of functions which compute the variables to be recorded at</span>
<span class="sd">            each chain iteration, with each trace function being passed the current</span>
<span class="sd">            state and returning a dictionary of scalar or array values corresponding to</span>
<span class="sd">            the variable(s) to be stored. The keys in the returned dictionaries are used</span>
<span class="sd">            to index the trace arrays in the returned traces dictionary. If a key</span>
<span class="sd">            appears in multiple dictionaries only the the value corresponding to the</span>
<span class="sd">            last trace function to return that key will be stored.</span>
<span class="sd">        chain_traces: dictionary of chain trace arrays (or string file paths to</span>
<span class="sd">            memory-mapped stores of those arrays if `load_memmaps=True`) , to record</span>
<span class="sd">            traced output in. Values in dictionary are arrays (or paths to memmaped</span>
<span class="sd">            arrays) which variables outputted by trace functions in `trace_funcs` are</span>
<span class="sd">            recorded in. The leading dimension of each array corresponds to the sampling</span>
<span class="sd">            (draw) index and must be of size greater than `sampling_index_offset +</span>
<span class="sd">            n_iter` where `n_iter` is the number of chain iterations. The key for each</span>
<span class="sd">            value is the corresponding key in the dictionary returned by the trace</span>
<span class="sd">            function which computes the traced value.</span>
<span class="sd">        chain_stats: dictionary of chain transition statistic dictionaries to record</span>
<span class="sd">            chain statistics in. Values in outer dictionary are dictionaries of</span>
<span class="sd">            statistics for each chain transition, keyed by the string key for the</span>
<span class="sd">            transition. The values in each inner transition dictionary are arrays (or</span>
<span class="sd">            paths to memmaped arrays if `load_memmaps=True`) which chain statistic</span>
<span class="sd">            values will be recorded in. The leading dimension of each array corresponds</span>
<span class="sd">            to the sampling (draw) index and must be of size greater than</span>
<span class="sd">            `sampling_index_offset + n_iter` where `n_iter` is the number of chain</span>
<span class="sd">            iterations. The key for each value is a string description of the</span>
<span class="sd">            corresponding transition statistic.</span>
<span class="sd">        load_memmaps: Flag indicating whether `chain_traces` and `chain_stats`</span>
<span class="sd">            dictionary contain file paths to saved memory-mapped arrays which must be</span>
<span class="sd">            loaded before writing chain data.</span>
<span class="sd">        chain_index: Identifier for chain when sampling multiple chains.</span>
<span class="sd">        sampling_index_offset: Non-negative integer specifying sampling (draw) index in</span>
<span class="sd">            trace and statistic arrays to begin recording values at.</span>
<span class="sd">        monitor_stats: String-keyed dictionary of containers of strings, with dictionary</span>
<span class="sd">            key the key of a Markov transition in the `transitions` dict passed to the</span>
<span class="sd">            the `__init__` method and the corresponding container, the keys of</span>
<span class="sd">            statistics returned by the transition (as defined by the `statistics_type`</span>
<span class="sd">            attribute of transition). The mean over samples computed so far of the</span>
<span class="sd">            statistics associated with any valid key-pairs will be monitored during</span>
<span class="sd">            sampling by printing as postfix to progress bar.</span>
<span class="sd">        adapters: dictionary of sequences of `mici.adapters.Adapter` instances keyed by</span>
<span class="sd">            strings corresponding to the key of the transition in the `transitions`</span>
<span class="sd">            dictionary to apply the adapters to. Each adapter is able to adaptatively</span>
<span class="sd">            set the parameters of a transition while sampling a chain. Note that the</span>
<span class="sd">            adapter updates for each transition are applied in the order the adapters</span>
<span class="sd">            appear in the iterable and so if multiple adapters change the same</span>
<span class="sd">            parameter(s) the order will matter. Adaptation based on the chain state</span>
<span class="sd">            history breaks the Markov property and so any chain samples while adaptation</span>
<span class="sd">            is active should not be used in estimates of expectations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        final_state: State of chain after final iteration. May be used to resume</span>
<span class="sd">            sampling a chain by passing as the initial state to a new `sample_chain`</span>
<span class="sd">            call.</span>
<span class="sd">        adapter_states: dictionary of per-transition adapter states. dictionary is keyed</span>
<span class="sd">            by transition key (i.e. the key of a Markov transition in the `transitions`</span>
<span class="sd">            dict) with values lists of dictionaries corresponding to the states of any</span>
<span class="sd">            adapters applied to that transition.</span>
<span class="sd">        exception: Any handled exception which may affect how the returned outputs are</span>
<span class="sd">            processed by the caller.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">_check_and_process_init_state</span><span class="p">(</span><span class="n">init_state</span><span class="p">,</span> <span class="n">transitions</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">load_memmaps</span><span class="p">:</span>
        <span class="n">chain_traces</span> <span class="o">=</span> <span class="n">_file_paths_to_memmaps</span><span class="p">(</span><span class="n">chain_traces</span><span class="p">)</span>
        <span class="n">chain_stats</span> <span class="o">=</span> <span class="n">_file_paths_to_memmaps</span><span class="p">(</span><span class="n">chain_stats</span><span class="p">)</span>
    <span class="n">adapter_states</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">adapters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">trans_key</span><span class="p">,</span> <span class="n">adapter_list</span> <span class="ow">in</span> <span class="n">adapters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">adapter_states</span><span class="p">[</span><span class="n">trans_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">adapter</span> <span class="ow">in</span> <span class="n">adapter_list</span><span class="p">:</span>
                    <span class="n">adapter_states</span><span class="p">[</span><span class="n">trans_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">adapter</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">transitions</span><span class="p">[</span><span class="n">trans_key</span><span class="p">]),</span>
                    <span class="p">)</span>
    <span class="k">except</span> <span class="n">AdaptationError</span> <span class="k">as</span> <span class="n">exception</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Initialisation of </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> for chain &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chain_index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> failed: </span><span class="si">{</span><span class="n">exception</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="n">adapter_states</span><span class="p">,</span> <span class="n">exception</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sample_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">with</span> <span class="n">chain_iterator</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sample_index</span><span class="p">,</span> <span class="n">monitor_dict</span> <span class="ow">in</span> <span class="n">chain_iterator</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">trans_key</span><span class="p">,</span> <span class="n">transition</span> <span class="ow">in</span> <span class="n">transitions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">state</span><span class="p">,</span> <span class="n">trans_stats</span> <span class="o">=</span> <span class="n">transition</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">adapters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">trans_key</span> <span class="ow">in</span> <span class="n">adapters</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">adapter</span><span class="p">,</span> <span class="n">adapter_state</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                            <span class="n">adapters</span><span class="p">[</span><span class="n">trans_key</span><span class="p">],</span>
                            <span class="n">adapter_states</span><span class="p">[</span><span class="n">trans_key</span><span class="p">],</span>
                        <span class="p">):</span>
                            <span class="n">adapter</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                <span class="n">adapter_state</span><span class="p">,</span>
                                <span class="n">state</span><span class="p">,</span>
                                <span class="n">trans_stats</span><span class="p">,</span>
                                <span class="n">transition</span><span class="p">,</span>
                            <span class="p">)</span>
                    <span class="k">if</span> <span class="n">chain_stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">_update_chain_stats</span><span class="p">(</span>
                            <span class="n">sample_index</span> <span class="o">+</span> <span class="n">sampling_index_offset</span><span class="p">,</span>
                            <span class="n">chain_stats</span><span class="p">,</span>
                            <span class="n">trans_key</span><span class="p">,</span>
                            <span class="n">trans_stats</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">monitor_stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">_update_monitor_stats</span><span class="p">(</span>
                            <span class="n">monitor_stats</span><span class="p">,</span>
                            <span class="n">monitor_dict</span><span class="p">,</span>
                            <span class="n">trans_key</span><span class="p">,</span>
                            <span class="n">trans_stats</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">if</span> <span class="n">chain_traces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">trace_funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">trace_func</span> <span class="ow">in</span> <span class="n">trace_funcs</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">trace_func</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">chain_traces</span><span class="p">[</span><span class="n">key</span><span class="p">][</span>
                                <span class="n">sample_index</span> <span class="o">+</span> <span class="n">sampling_index_offset</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">exception</span> <span class="o">=</span> <span class="n">e</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sampling manually interrupted for chain </span><span class="si">{</span><span class="n">chain_index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> at&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; iteration </span><span class="si">{</span><span class="n">sample_index</span><span class="si">}</span><span class="s2">. Arrays containing chain traces and&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; statistics computed before interruption will be returned.&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exception</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># flush any updates to memory-mapped chain data to disk before exiting</span>
        <span class="n">_flush_memmap_chain_data</span><span class="p">(</span><span class="n">chain_traces</span><span class="p">,</span> <span class="n">chain_stats</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="n">adapter_states</span><span class="p">,</span> <span class="n">exception</span>


<span class="k">def</span> <span class="nf">_collate_chain_outputs</span><span class="p">(</span>
    <span class="n">chain_outputs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">ChainState</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">AdapterState</span><span class="p">]]]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">ChainState</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AdapterState</span><span class="p">]]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unzip list of tuples of chain outputs in to tuple of stacked outputs.&quot;&quot;&quot;</span>
    <span class="n">final_states_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">adapt_states_stack</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">final_state</span><span class="p">,</span> <span class="n">adapt_states</span> <span class="ow">in</span> <span class="n">chain_outputs</span><span class="p">:</span>
        <span class="n">final_states_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">trans_key</span><span class="p">,</span> <span class="n">adapt_state_list</span> <span class="ow">in</span> <span class="n">adapt_states</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">trans_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adapt_states_stack</span><span class="p">:</span>
                <span class="n">adapt_states_stack</span><span class="p">[</span><span class="n">trans_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">adapt_state_list</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">adapt_state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adapt_state_list</span><span class="p">):</span>
                    <span class="n">adapt_states_stack</span><span class="p">[</span><span class="n">trans_key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adapt_state</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">final_states_stack</span><span class="p">,</span> <span class="n">adapt_states_stack</span>


<span class="k">def</span> <span class="nf">_get_per_chain_rngs</span><span class="p">(</span><span class="n">base_rng</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">n_chain</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Generator</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct random number generators (RNGs) for each of a set of chains.</span>

<span class="sd">    If the base RNG bit generator has a `jumped` method this is used to produce a</span>
<span class="sd">    sequence of independent random substreams. Otherwise if the base RNG bit generator</span>
<span class="sd">    has a `_seed_seq` attribute this is used to spawn a sequence off generators.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">base_rng</span><span class="p">,</span> <span class="s2">&quot;bit_generator&quot;</span><span class="p">):</span>
        <span class="n">bit_generator</span> <span class="o">=</span> <span class="n">base_rng</span><span class="o">.</span><span class="n">bit_generator</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">base_rng</span><span class="p">,</span> <span class="s2">&quot;_bit_generator&quot;</span><span class="p">):</span>
        <span class="n">bit_generator</span> <span class="o">=</span> <span class="n">base_rng</span><span class="o">.</span><span class="n">_bit_generator</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bit_generator</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">bit_generator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bit_generator</span><span class="p">,</span> <span class="s2">&quot;jumped&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">default_rng</span><span class="p">(</span><span class="n">bit_generator</span><span class="o">.</span><span class="n">jumped</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">bit_generator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bit_generator</span><span class="p">,</span> <span class="s2">&quot;_seed_seq&quot;</span><span class="p">):</span>
        <span class="n">seed_sequence</span> <span class="o">=</span> <span class="n">bit_generator</span><span class="o">.</span><span class="n">_seed_seq</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span> <span class="k">for</span> <span class="n">seed</span> <span class="ow">in</span> <span class="n">seed_sequence</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">n_chain</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unsupported random number generator type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">base_rng</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sample_chains_sequential</span><span class="p">(</span>
    <span class="n">chain_iterators</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">ChainIterator</span><span class="p">],</span>
    <span class="n">per_chain_kwargs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span>
    <span class="o">**</span><span class="n">common_kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">ChainState</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AdapterState</span><span class="p">]]],</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample multiple chains sequentially in a single process.&quot;&quot;&quot;</span>
    <span class="n">chain_outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">exception</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">chain_index</span><span class="p">,</span> <span class="p">(</span><span class="n">chain_iterator</span><span class="p">,</span> <span class="n">chain_kwargs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">chain_iterators</span><span class="p">,</span> <span class="n">per_chain_kwargs</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="n">exception</span> <span class="o">=</span> <span class="n">_sample_chain</span><span class="p">(</span>
            <span class="n">chain_iterator</span><span class="o">=</span><span class="n">chain_iterator</span><span class="p">,</span>
            <span class="n">chain_index</span><span class="o">=</span><span class="n">chain_index</span><span class="p">,</span>
            <span class="o">**</span><span class="n">chain_kwargs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">common_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Returned exception being AdaptationError indicates chain terminated</span>
        <span class="c1"># due to adapter initialisation failing therefore do not store returned</span>
        <span class="c1"># chain outputs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exception</span><span class="p">,</span> <span class="n">AdaptationError</span><span class="p">):</span>
            <span class="n">chain_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="c1"># If returned handled exception was a manual interrupt break and return</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exception</span><span class="p">,</span> <span class="ne">KeyboardInterrupt</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">_collate_chain_outputs</span><span class="p">(</span><span class="n">chain_outputs</span><span class="p">),</span> <span class="n">exception</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sample_chains_worker</span><span class="p">(</span>
    <span class="n">chain_queue</span><span class="p">:</span> <span class="n">Queue</span><span class="p">,</span>
    <span class="n">iter_queue</span><span class="p">:</span> <span class="n">Queue</span><span class="p">,</span>
    <span class="n">common_kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ChainState</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">AdapterState</span><span class="p">]]]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Worker process function for parallel sampling of chains.</span>

<span class="sd">    Consumes chain arguments from a shared queue and outputs chain progress updates to a</span>
<span class="sd">    second shared queue.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chain_outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">chain_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">chain_index</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">,</span> <span class="n">chain_kwargs</span> <span class="o">=</span> <span class="n">chain_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">max_threads</span> <span class="o">=</span> <span class="n">common_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;max_threads_per_process&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">context</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">threadpool_limits</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="n">max_threads</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">THREADPOOLCTL_AVAILABLE</span>
                <span class="k">else</span> <span class="n">nullcontext</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">with</span> <span class="n">context</span><span class="p">:</span>
                <span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="n">exception</span> <span class="o">=</span> <span class="n">_sample_chain</span><span class="p">(</span>
                    <span class="n">chain_index</span><span class="o">=</span><span class="n">chain_index</span><span class="p">,</span>
                    <span class="n">chain_iterator</span><span class="o">=</span><span class="n">_ProxySequenceProgressBar</span><span class="p">(</span>
                        <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">),</span>
                        <span class="n">chain_index</span><span class="p">,</span>
                        <span class="n">iter_queue</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">load_memmaps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">chain_kwargs</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">common_kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># Returned exception being AdaptationError indicates chain</span>
            <span class="c1"># terminated due to adapter initialisation failing therefore do not</span>
            <span class="c1"># store returned chain outputs and put None value on iteration queue</span>
            <span class="c1"># to indicate to parent process chain terminated</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exception</span><span class="p">,</span> <span class="n">AdaptationError</span><span class="p">):</span>
                <span class="n">iter_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chain_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">chain_index</span><span class="p">,</span> <span class="n">outputs</span><span class="p">))</span>
            <span class="c1"># If returned handled exception was a manual interrupt put exception</span>
            <span class="c1"># on iteration queue to communicate to parent process and break</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exception</span><span class="p">,</span> <span class="ne">KeyboardInterrupt</span><span class="p">):</span>
                <span class="n">iter_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">exception</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exception</span><span class="p">:</span>  <span class="c1"># noqa: BLE001</span>
            <span class="c1"># Log exception here so that correct traceback is logged</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Exception encountered in chain worker process:&quot;</span><span class="p">,</span>
                <span class="n">exc_info</span><span class="o">=</span><span class="n">exception</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Put exception on iteration queue to be reraised in parent process</span>
            <span class="n">iter_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">exception</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chain_outputs</span>


<span class="k">def</span> <span class="nf">_finalize_adapters</span><span class="p">(</span><span class="n">adapter_states_dict</span><span class="p">,</span> <span class="n">chain_states</span><span class="p">,</span> <span class="n">adapters</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">rngs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finalize adapter updates to transitions based on final adapter states.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">trans_key</span><span class="p">,</span> <span class="n">adapter_states_list</span> <span class="ow">in</span> <span class="n">adapter_states_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">adapter_states</span><span class="p">,</span> <span class="n">adapter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adapter_states_list</span><span class="p">,</span> <span class="n">adapters</span><span class="p">[</span><span class="n">trans_key</span><span class="p">]):</span>
            <span class="n">adapter</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">adapter_states</span><span class="p">,</span> <span class="n">chain_states</span><span class="p">,</span> <span class="n">transitions</span><span class="p">[</span><span class="n">trans_key</span><span class="p">],</span> <span class="n">rngs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sample_chains_parallel</span><span class="p">(</span>
    <span class="n">chain_iterators</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">ChainIterator</span><span class="p">],</span>
    <span class="n">per_chain_kwargs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span>
    <span class="n">n_process</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">**</span><span class="n">common_kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">ChainState</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AdapterState</span><span class="p">]]],</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample multiple chains in parallel over multiple processes.&quot;&quot;&quot;</span>
    <span class="n">n_iters</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">chain_iterators</span><span class="p">]</span>
    <span class="n">n_chain</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_iterators</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">_ignore_sigint_manager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">,</span> <span class="n">_pool_context_manager</span><span class="p">(</span><span class="n">n_process</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">exception</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Shared queue for workers to output chain progress updates to</span>
            <span class="n">iter_queue</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
            <span class="c1"># Shared queue for workers to get arguments for _sample_chain calls</span>
            <span class="c1"># from on initialising each chain</span>
            <span class="n">chain_queue</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">chain_kwargs</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">per_chain_kwargs</span><span class="p">,</span> <span class="n">n_iters</span><span class="p">)):</span>
                <span class="c1"># Map memmaps to their filepaths prior to putting on argument queue to</span>
                <span class="c1"># avoid serializing potentially large memory mapped arrays</span>
                <span class="n">chain_kwargs</span><span class="p">[</span><span class="s2">&quot;chain_stats&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_memmaps_to_file_paths</span><span class="p">(</span>
                    <span class="n">chain_kwargs</span><span class="p">[</span><span class="s2">&quot;chain_stats&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">chain_kwargs</span><span class="p">[</span><span class="s2">&quot;chain_traces&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_memmaps_to_file_paths</span><span class="p">(</span>
                    <span class="n">chain_kwargs</span><span class="p">[</span><span class="s2">&quot;chain_traces&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">chain_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">,</span> <span class="n">chain_kwargs</span><span class="p">))</span>
            <span class="c1"># Start n_process worker processes which each have access to the</span>
            <span class="c1"># shared queues, returning results asynchronously</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap_async</span><span class="p">(</span>
                <span class="n">_sample_chains_worker</span><span class="p">,</span>
                <span class="p">[(</span><span class="n">chain_queue</span><span class="p">,</span> <span class="n">iter_queue</span><span class="p">,</span> <span class="n">common_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_process</span><span class="p">)],</span>
            <span class="p">)</span>
            <span class="c1"># Start loop to use chain progress updates outputted to iter_queue</span>
            <span class="c1"># by worker processes to update progress bars, using an ExitStack</span>
            <span class="c1"># to ensure all progress bars are context managed so that they</span>
            <span class="c1"># are closed properly on for example manual interrupts</span>
            <span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
                <span class="n">pbars</span> <span class="o">=</span> <span class="p">[</span><span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">chain_iterators</span><span class="p">]</span>
                <span class="c1"># Deadlock seems to occur when directly using results.ready()</span>
                <span class="c1"># method to check if all chains completed sampling in</span>
                <span class="c1"># while loop condition therefore manually keep track of</span>
                <span class="c1"># number of completed chains</span>
                <span class="n">chains_completed</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="n">iter_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span> <span class="ow">and</span> <span class="n">chains_completed</span> <span class="o">==</span> <span class="n">n_chain</span><span class="p">):</span>
                    <span class="n">iter_queue_item</span> <span class="o">=</span> <span class="n">iter_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="c1"># Queue item being None indicates a chain terminated early</span>
                    <span class="c1"># due to a non-fatal error e.g. an error in initialising an</span>
                    <span class="c1"># adapter. In this case we continue sampling any other</span>
                    <span class="c1"># remaining chains but increment the completed chains</span>
                    <span class="c1"># counter to ensure correct termination of chain progress</span>
                    <span class="c1"># update loop</span>
                    <span class="k">if</span> <span class="n">iter_queue_item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">chains_completed</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># If queue item is KeyboardInterrupt exception break out of</span>
                    <span class="c1"># chain progress update loop but do not reraise exception</span>
                    <span class="c1"># so that partial chain outputs are returned</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iter_queue_item</span><span class="p">,</span> <span class="ne">KeyboardInterrupt</span><span class="p">):</span>
                        <span class="n">exception</span> <span class="o">=</span> <span class="n">iter_queue_item</span>
                        <span class="k">break</span>
                    <span class="c1"># Re raise any other exception passed from worker processes</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iter_queue_item</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unhandled exception in chain worker process.&quot;</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">iter_queue_item</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Otherwise unpack and update progress bar</span>
                        <span class="n">chain_index</span><span class="p">,</span> <span class="n">sample_index</span><span class="p">,</span> <span class="n">data_dict</span> <span class="o">=</span> <span class="n">iter_queue_item</span>
                        <span class="n">pbars</span><span class="p">[</span><span class="n">chain_index</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sample_index</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">sample_index</span> <span class="o">==</span> <span class="n">n_iters</span><span class="p">[</span><span class="n">chain_index</span><span class="p">]:</span>
                            <span class="n">chains_completed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">PicklingError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">MULTIPROCESS_AVAILABLE</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">PicklingError</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;pickle&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Error encountered while trying to run chains on multipleprocesses &quot;</span>
                    <span class="s2">&quot;in parallel. The inbuilt multiprocessing module uses pickle to &quot;</span>
                    <span class="s2">&quot;communicate between processes and pickle does support pickling &quot;</span>
                    <span class="s2">&quot;anonymous or nested functions. If you use anonymous or nested &quot;</span>
                    <span class="s2">&quot;functions in your model functions or are using autograd to &quot;</span>
                    <span class="s2">&quot;automatically compute derivatives (autograd uses anonymous and &quot;</span>
                    <span class="s2">&quot;nested functions) then installing the Python package &quot;</span>
                    <span class="s2">&quot;multiprocess, which is able to serialise anonymous and nested &quot;</span>
                    <span class="s2">&quot;functions and will be used in preference to multiprocessing by &quot;</span>
                    <span class="s2">&quot;this package when available, may resolve this error.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Interrupts handled in child processes therefore ignore here</span>
            <span class="n">exception</span> <span class="o">=</span> <span class="n">e</span>
        <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Join all output lists from per-process workers in to single list</span>
            <span class="n">indexed_chain_outputs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">get</span><span class="p">()),</span> <span class="p">[])</span>
            <span class="c1"># Sort list by chain index (first element of tuple entries) and</span>
            <span class="c1"># then create new list with chain index removed</span>
            <span class="n">chain_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">outp</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">outp</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">indexed_chain_outputs</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chain_outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">_collate_chain_outputs</span><span class="p">(</span><span class="n">chain_outputs</span><span class="p">),</span> <span class="n">exception</span><span class="p">)</span>


<div class="viewcode-block" id="MCMCSampleChainsOutputs"><a class="viewcode-back" href="../../mici.samplers.html#mici.samplers.MCMCSampleChainsOutputs">[docs]</a><span class="k">class</span> <span class="nc">MCMCSampleChainsOutputs</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Outputs returned by :py:meth:`MarkovChainMonteCarloMethod.sample_chains` call.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        final_states: States of chains after final iteration. May be used to resume</span>
<span class="sd">            sampling a chain by passing as the initial states to a new</span>
<span class="sd">            :py:meth:`MarkovChainMonteCarloMethod.sample_chains` call.</span>
<span class="sd">        traces: Dictionary of chain trace arrays. Values in dictionary are list of</span>
<span class="sd">            arrays of variables outputted by trace functions in :code:`trace_funcs` with</span>
<span class="sd">            each array in the list corresponding to a single chain and the leading</span>
<span class="sd">            dimension of each array corresponding to the iteration (draw) index, within</span>
<span class="sd">            the main non-adaptive sampling stage if :code:`trace_warm_up=False` and</span>
<span class="sd">            across both warm-up and main sampling stages otherwise. The key for each</span>
<span class="sd">            value is the corresponding key in the dictionary returned by the trace</span>
<span class="sd">            function which computed the traced value.</span>
<span class="sd">        statistics: Dictionary of chain transition statistic dictionaries. Values in</span>
<span class="sd">            outer dictionary are dictionaries of statistics for each chain transition,</span>
<span class="sd">            keyed by the string key for the transition. The values in each inner</span>
<span class="sd">            transition dictionary are lists of arrays of chain statistic values with</span>
<span class="sd">            each array in the list corresponding to a single chain and the leading</span>
<span class="sd">            dimension of each array corresponding to the iteration (draw) index, within</span>
<span class="sd">            the main non-adaptive sampling stage if :code:`trace_warm_up=False` and</span>
<span class="sd">            across both warm-up and main sampling stages otherwise. The key for each</span>
<span class="sd">            value is a string description of the corresponding transition statistic.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">final_states</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ChainState</span><span class="p">]</span>
    <span class="n">traces</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">]]</span>
    <span class="n">statistics</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">]]]</span></div>


<div class="viewcode-block" id="MarkovChainMonteCarloMethod"><a class="viewcode-back" href="../../mici.samplers.html#mici.samplers.MarkovChainMonteCarloMethod">[docs]</a><span class="k">class</span> <span class="nc">MarkovChainMonteCarloMethod</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generic Markov chain Monte Carlo (MCMC) sampler.</span>

<span class="sd">    Generates a Markov chain from some initial state by iteratively applying a sequence</span>
<span class="sd">    of Markov transition operators.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rng</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">transitions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Transition</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            rng: Numpy random number generator.</span>
<span class="sd">            transitions: Ordered dictionary of Markov transitions kernels to</span>
<span class="sd">                sequentially sample from on each chain iteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Use of numpy.random.RandomState random number generators is &quot;</span>
                <span class="s2">&quot;deprecated. Please use a numpy.random.Generator instance &quot;</span>
                <span class="s2">&quot;instead for example from a call to numpy.random.default_rng.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">_bit_generator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">rng</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transitions</span> <span class="o">=</span> <span class="n">transitions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Transition</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of transition kernels sampled from in each chain iteration.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transitions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rng</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;NumPy random number generator object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span>

<div class="viewcode-block" id="MarkovChainMonteCarloMethod.sample_chains"><a class="viewcode-back" href="../../mici.samplers.html#mici.samplers.MarkovChainMonteCarloMethod.sample_chains">[docs]</a>    <span class="k">def</span> <span class="nf">sample_chains</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_warm_up_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">n_main_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">init_states</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ChainState</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">trace_funcs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TraceFunction</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">adapters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Adapter</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stager</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Stager</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_process</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">trace_warm_up</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_threads_per_process</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">force_memmap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">memmap_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">monitor_stats</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">display_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">progress_bar_class</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ProgressBar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MCMCSampleChainsOutputs</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample Markov chains from initial states with optional adaptive warm up.</span>

<span class="sd">        One or more Markov chains are sampled, with each chain iteration consisting of</span>
<span class="sd">        one or more Markov transitions. The chains are split into multiple *stages* with</span>
<span class="sd">        zero or more adaptive warm up stages followed by the main non-adaptive sampling</span>
<span class="sd">        stage. During the adaptive stage(s) parameters of the transition(s) are</span>
<span class="sd">        adaptively tuned based on the chain state and/or transition statistics.</span>

<span class="sd">        The chains (including both adaptive and non-adaptive stages) may be run in</span>
<span class="sd">        parallel across multiple independent processes or sequentially. In all cases all</span>
<span class="sd">        chains use independent random draws.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_warm_up_iter: Number of adaptive warm up iterations per chain. Depending</span>
<span class="sd">                on the :py:class:`mici.stagers.Stager` instance specified by the</span>
<span class="sd">                :code:`stager` argument the warm up iterations may be split between one</span>
<span class="sd">                or more adaptive stages. If zero, only a single non-adaptive stage is</span>
<span class="sd">                used.</span>
<span class="sd">            n_main_iter: Number of iterations (samples to draw) per chain during main</span>
<span class="sd">                (non-adaptive) sampling stage.</span>
<span class="sd">            init_states: Initial chain states. Each entry can be either a</span>
<span class="sd">                :py:class:`ChainState` object or a dictionary with entries specifying</span>
<span class="sd">                initial values for all state variables used by chain transition</span>
<span class="sd">                :code:`sample` methods.</span>
<span class="sd">            trace_funcs: Sequence of functions which compute the variables to be</span>
<span class="sd">                recorded at each chain iteration (during only the main non-adaptive</span>
<span class="sd">                sampling stage if :code:`trace_warm_up == False`), with each trace</span>
<span class="sd">                function passed the current state and returning a dictionary of scalar</span>
<span class="sd">                or array values corresponding to the variable(s) to be stored. The keys</span>
<span class="sd">                in the returned dictionaries are used to index the trace arrays in the</span>
<span class="sd">                returned traces dictionary. If a key appears in multiple dictionaries</span>
<span class="sd">                only the the value corresponding to the last trace function to return</span>
<span class="sd">                that key will be stored. If :code:`None` or an empty sequence no</span>
<span class="sd">                variables are traced.</span>
<span class="sd">            adapters: Dictionary of sequences of :py:class:`mici.adapters.Adapter`</span>
<span class="sd">                instances keyed by strings corresponding to the key of the transition in</span>
<span class="sd">                the :py:attr:`transitions` dictionary to apply the adapters to, to use</span>
<span class="sd">                to adaptatively set parameters of the transitions during the adaptive</span>
<span class="sd">                stages of the chains. Note that the adapter updates are applied in the</span>
<span class="sd">                order the adapters appear in the sequence and so if multiple adapters</span>
<span class="sd">                change the same parameter(s) the order will matter. If :code:`None` or</span>
<span class="sd">                an empty sequence no adapters are used.</span>
<span class="sd">            stager: Chain iteration stager object which controls the split of the chain</span>
<span class="sd">                iterations into the adaptive warm up and non-adaptive main stages. If</span>
<span class="sd">                set to :code:`None` (the default) and all adapters specified by the</span>
<span class="sd">                :code:`adapters` argument are of the fast type (i.e. their</span>
<span class="sd">                :code:`is_fast` attribute is :code:`True`) then a</span>
<span class="sd">                :py:class:`mici.stagers.WarmUpStager` instance will be used</span>
<span class="sd">                corresponding to using a single adaptive warm up stage will all adapters</span>
<span class="sd">                active. If set to :code:`None` and the adapters specified by the</span>
<span class="sd">                adapters argument are not all of the fast type, then a</span>
<span class="sd">                :py:class:`mici.stagers.WindowedWarmUpStager` (with its default</span>
<span class="sd">                arguments) will be used, corresponding to using multiple adaptive warm</span>
<span class="sd">                up stages with only the fast-type adapters active in some - see</span>
<span class="sd">                documentation of :py:class:`mici.stagers.WarmUpStager` for details.</span>
<span class="sd">            n_process: Number of parallel processes to run chains over. If </span>
<span class="sd">                :code:`n_process=1` then chains will be run sequentially otherwise a</span>
<span class="sd">                :py:class:`multiprocessing.Pool` object will be used to dynamically</span>
<span class="sd">                assign the chains across multiple processes. If set to :code:`None` then</span>
<span class="sd">                the number of processes will be set to the output of</span>
<span class="sd">                :py:func:`os.cpu_count()`. Default is :code:`n_process=1`.</span>
<span class="sd">            trace_warm_up: Whether to record chain traces and statistics during warm-up</span>
<span class="sd">                stage iterations (:code:`True`) or only record traces and statistics in</span>
<span class="sd">                the iterations of the final non-adaptive stage (:code:`False`, the</span>
<span class="sd">                default).</span>
<span class="sd">            max_threads_per_process: If :py:mod:`threadpoolctl` is available this</span>
<span class="sd">                argument may be used to limit the maximum number of threads that can be</span>
<span class="sd">                used in thread pools used in libraries supported by</span>
<span class="sd">                :py:mod:`threadpoolctl`, which include BLAS and OpenMP implementations.</span>
<span class="sd">                This argument will only have an effect if :code:`n_process &gt; 1` such</span>
<span class="sd">                that chains are being run on multiple processes and only if</span>
<span class="sd">                :py:mod:`threadpoolctl` is installed in the current Python environment.</span>
<span class="sd">                If set to :code:`None` (the default) no limits are set.</span>
<span class="sd">            force_memmap: Whether to force arrays used to store chain data to be</span>
<span class="sd">                memory-mapped to files on disk to avoid excessive system memory usage</span>
<span class="sd">                for long chains and/or large chain states. The chain data is written to</span>
<span class="sd">                `.npy` files in the directory specified by :code:`memmap_path` (or a</span>
<span class="sd">                temporary directory if :code:`memmap_path` is `None`). Chain data is</span>
<span class="sd">                always memory mapped when sampling chains in parallel on multiple</span>
<span class="sd">                processes.</span>
<span class="sd">            memmap_path: Path to directory to write memory-mapped chain data to. If</span>
<span class="sd">                :code:`None` (the default) and memory-mapping is enabled then a</span>
<span class="sd">                temporary directory will be created and the chain data written to files</span>
<span class="sd">                there, with the created files being deleted in this case once the last</span>
<span class="sd">                reference to them is closed.</span>
<span class="sd">            monitor_stats: String-keyed dictionary of lists of strings, with dictionary</span>
<span class="sd">                key the key of a Markov transition in the :code:`transitions` dict</span>
<span class="sd">                passed to the the :py:meth:`__init__` method and the corresponding list,</span>
<span class="sd">                the keys of statistics returned by the transition (as defined by the</span>
<span class="sd">                :py:attr:`mici.transitions.Transition.statistics_type` attribute of</span>
<span class="sd">                transition). The mean over samples computed so far of the statistics</span>
<span class="sd">                associated with any valid key-pairs will be monitored during sampling by</span>
<span class="sd">                printing as postfix to progress bar. If :code:`None` no statistics are</span>
<span class="sd">                monitored.</span>
<span class="sd">            display_progress: Whether to display a progress bar to track the completed</span>
<span class="sd">                chain sampling iterations. Default value is :code:`True`, i.e. to</span>
<span class="sd">                display progress bar.</span>
<span class="sd">            progress_bar_class: Class or factory function for progress bar to use to</span>
<span class="sd">                show chain progress if enabled (:code:`display_progress=True`). Defaults</span>
<span class="sd">                to :py:class:`mici.progressbars.SequenceProgressBar` if :code:`None` and</span>
<span class="sd">                :code:`display_progress=True`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Named tuple :code:`(final_states, traces, statistics)` corresponding to</span>
<span class="sd">            states of chains after final interatinos, dictionary of chain trace arrays</span>
<span class="sd">            and dictionary of chain statistics dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">display_progress</span><span class="p">:</span>
            <span class="n">progress_bar_class</span> <span class="o">=</span> <span class="n">DummyProgressBar</span>
        <span class="k">elif</span> <span class="n">progress_bar_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">progress_bar_class</span> <span class="o">=</span> <span class="n">SequenceProgressBar</span>
        <span class="n">n_chain</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_states</span><span class="p">)</span>
        <span class="n">n_trace_iter</span> <span class="o">=</span> <span class="n">n_warm_up_iter</span> <span class="o">+</span> <span class="n">n_main_iter</span> <span class="k">if</span> <span class="n">trace_warm_up</span> <span class="k">else</span> <span class="n">n_main_iter</span>
        <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_check_and_process_init_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">init_states</span>
        <span class="p">]</span>
        <span class="c1"># memory-mapping of chain data used if force_memmap flag set or sampling chains</span>
        <span class="c1"># in parallel</span>
        <span class="n">use_memmap</span> <span class="o">=</span> <span class="n">force_memmap</span> <span class="ow">or</span> <span class="n">n_process</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="c1"># use context-manager to ensure any temporary directory created for memory-maps</span>
        <span class="c1"># deleted before exiting</span>
        <span class="k">if</span> <span class="n">use_memmap</span> <span class="ow">and</span> <span class="n">memmap_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memmap_path_context</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">memmap_path_context</span> <span class="o">=</span> <span class="n">nullcontext</span><span class="p">(</span><span class="n">memmap_path</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">memmap_path_context</span> <span class="k">as</span> <span class="n">memmap_path</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">None</span>
                <span class="k">if</span> <span class="n">trace_funcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace_funcs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">else</span> <span class="n">_init_traces</span><span class="p">(</span>
                    <span class="n">trace_funcs</span><span class="p">,</span>
                    <span class="n">init_states</span><span class="p">,</span>
                    <span class="n">n_trace_iter</span><span class="p">,</span>
                    <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span>
                    <span class="n">memmap_path</span><span class="o">=</span><span class="n">memmap_path</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="n">_init_stats</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">,</span>
                <span class="n">n_chain</span><span class="p">,</span>
                <span class="n">n_trace_iter</span><span class="p">,</span>
                <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span>
                <span class="n">memmap_path</span><span class="o">=</span><span class="n">memmap_path</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">per_chain_rngs</span> <span class="o">=</span> <span class="n">_get_per_chain_rngs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">n_chain</span><span class="p">)</span>
            <span class="n">per_chain_traces</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_chain</span> <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">_zip_dict</span><span class="p">(</span><span class="o">**</span><span class="n">traces</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">per_chain_stats</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">_zip_dict</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_zip_dict</span><span class="p">(</span><span class="o">**</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">items</span><span class="p">()}),</span>
            <span class="p">)</span>
            <span class="n">common_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;transitions&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">,</span>
                <span class="s2">&quot;monitor_stats&quot;</span><span class="p">:</span> <span class="n">monitor_stats</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">n_process</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Using single process therefore run chains sequentially</span>
                <span class="n">sample_chains_func</span> <span class="o">=</span> <span class="n">_sample_chains_sequential</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Run chains in parallel using a multiprocess(ing).Pool</span>
                <span class="n">common_kwargs</span><span class="p">[</span><span class="s2">&quot;n_process&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_process</span>
                <span class="n">common_kwargs</span><span class="p">[</span><span class="s2">&quot;max_threads_per_process&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_threads_per_process</span>
                <span class="n">sample_chains_func</span> <span class="o">=</span> <span class="n">_sample_chains_parallel</span>
            <span class="k">if</span> <span class="n">stager</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># use single warm-up stage stager if no adapters or all fast type</span>
                <span class="k">if</span> <span class="n">adapters</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">is_fast</span> <span class="k">for</span> <span class="n">a_list</span> <span class="ow">in</span> <span class="n">adapters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">a_list</span>
                <span class="p">):</span>
                    <span class="n">stager</span> <span class="o">=</span> <span class="n">WarmUpStager</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stager</span> <span class="o">=</span> <span class="n">WindowedWarmUpStager</span><span class="p">()</span>
            <span class="n">sampling_stages</span> <span class="o">=</span> <span class="n">stager</span><span class="o">.</span><span class="n">stages</span><span class="p">(</span>
                <span class="n">n_warm_up_iter</span><span class="p">,</span>
                <span class="n">n_main_iter</span><span class="p">,</span>
                <span class="n">adapters</span><span class="p">,</span>
                <span class="n">trace_funcs</span><span class="p">,</span>
                <span class="n">trace_warm_up</span><span class="o">=</span><span class="n">trace_warm_up</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">chain_states</span> <span class="o">=</span> <span class="n">init_states</span>
            <span class="n">sampling_index_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">with</span> <span class="n">LabelledSequenceProgressBar</span><span class="p">(</span>
                <span class="n">sampling_stages</span><span class="p">,</span>
                <span class="s2">&quot;Sampling stage&quot;</span><span class="p">,</span>
                <span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_chain</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">sampling_stages_pb</span><span class="p">:</span>
                <span class="n">chain_iterators</span> <span class="o">=</span> <span class="n">_construct_chain_iterators</span><span class="p">(</span>
                    <span class="mi">1</span><span class="p">,</span>
                    <span class="n">progress_bar_class</span><span class="p">,</span>
                    <span class="n">n_chain</span><span class="p">,</span>
                    <span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">stage</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sampling_stages_pb</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">chain_it</span> <span class="ow">in</span> <span class="n">chain_iterators</span><span class="p">:</span>
                        <span class="n">chain_it</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="n">chain_states</span><span class="p">,</span> <span class="n">adapter_states</span><span class="p">,</span> <span class="n">exception</span> <span class="o">=</span> <span class="n">sample_chains_func</span><span class="p">(</span>
                        <span class="n">chain_iterators</span><span class="o">=</span><span class="n">chain_iterators</span><span class="p">,</span>
                        <span class="n">per_chain_kwargs</span><span class="o">=</span><span class="n">_zip_dict</span><span class="p">(</span>
                            <span class="n">init_state</span><span class="o">=</span><span class="n">chain_states</span><span class="p">,</span>
                            <span class="n">rng</span><span class="o">=</span><span class="n">per_chain_rngs</span><span class="p">,</span>
                            <span class="n">chain_traces</span><span class="o">=</span><span class="n">per_chain_traces</span>
                            <span class="k">if</span> <span class="n">stage</span><span class="o">.</span><span class="n">trace_funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                            <span class="k">else</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_chain</span><span class="p">,</span>
                            <span class="n">chain_stats</span><span class="o">=</span><span class="n">per_chain_stats</span>
                            <span class="k">if</span> <span class="n">stage</span><span class="o">.</span><span class="n">record_stats</span>
                            <span class="k">else</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_chain</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="n">sampling_index_offset</span><span class="o">=</span><span class="n">sampling_index_offset</span><span class="p">,</span>
                        <span class="n">trace_funcs</span><span class="o">=</span><span class="n">stage</span><span class="o">.</span><span class="n">trace_funcs</span><span class="p">,</span>
                        <span class="n">adapters</span><span class="o">=</span><span class="n">stage</span><span class="o">.</span><span class="n">adapters</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">common_kwargs</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">adapter_states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">_finalize_adapters</span><span class="p">(</span>
                            <span class="n">adapter_states</span><span class="p">,</span>
                            <span class="n">chain_states</span><span class="p">,</span>
                            <span class="n">stage</span><span class="o">.</span><span class="n">adapters</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">,</span>
                            <span class="n">per_chain_rngs</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">stage</span><span class="o">.</span><span class="n">trace_funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">stage</span><span class="o">.</span><span class="n">record_stats</span><span class="p">:</span>
                        <span class="n">sampling_index_offset</span> <span class="o">+=</span> <span class="n">stage</span><span class="o">.</span><span class="n">n_iter</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exception</span><span class="p">,</span> <span class="ne">KeyboardInterrupt</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">MCMCSampleChainsOutputs</span><span class="p">(</span><span class="n">chain_states</span><span class="p">,</span> <span class="n">traces</span><span class="p">,</span> <span class="n">stats</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MCMCSampleChainsOutputs</span><span class="p">(</span><span class="n">chain_states</span><span class="p">,</span> <span class="n">traces</span><span class="p">,</span> <span class="n">stats</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HMCSampleChainsOutputs"><a class="viewcode-back" href="../../mici.samplers.html#mici.samplers.HMCSampleChainsOutputs">[docs]</a><span class="k">class</span> <span class="nc">HMCSampleChainsOutputs</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Outputs returned by :py:meth:`HamiltonianMonteCarlo.sample_chains` call.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        final_states: States of chains after final iteration. May be used to resume</span>
<span class="sd">            sampling a chain by passing as the initial states to a new</span>
<span class="sd">            :py:meth:`HamiltonianMonteCarlo.sample_chains` call.</span>
<span class="sd">        traces: Dictionary of chain trace arrays. Values in dictionary are list of</span>
<span class="sd">            arrays of variables outputted by trace functions in :code:`trace_funcs` with</span>
<span class="sd">            each array in the list corresponding to a single chain and the leading</span>
<span class="sd">            dimension of each array corresponding to the iteration (draw) index, within</span>
<span class="sd">            the main non-adaptive sampling stage if :code:`trace_warm_up=False` and</span>
<span class="sd">            across both warm-up and main sampling stages otherwise. The key for each</span>
<span class="sd">            value is the corresponding key in the dictionary returned by the trace</span>
<span class="sd">            function which computed the traced value.</span>
<span class="sd">        statistics: Dictionary of chain transition statistic dictionaries. Values in</span>
<span class="sd">            dictionary are lists of arrays of chain statistic values with each array in</span>
<span class="sd">            the list corresponding to a single chain and the leading dimension of each</span>
<span class="sd">            array corresponding to the iteration (draw) index, within the main</span>
<span class="sd">            non-adaptive sampling stage if :code:`trace_warm_up=False` and across both</span>
<span class="sd">            warm-up and main sampling stages otherwise. The key for each value is a</span>
<span class="sd">            string description of the corresponding integration transition statistic.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">final_states</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ChainState</span><span class="p">]</span>
    <span class="n">traces</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">]]</span>
    <span class="n">statistics</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">]]</span></div>


<div class="viewcode-block" id="HamiltonianMonteCarlo"><a class="viewcode-back" href="../../mici.samplers.html#mici.samplers.HamiltonianMonteCarlo">[docs]</a><span class="k">class</span> <span class="nc">HamiltonianMonteCarlo</span><span class="p">(</span><span class="n">MarkovChainMonteCarloMethod</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper class for Hamiltonian Monte Carlo (HMC) methods.</span>

<span class="sd">    Here HMC is defined as a Markov chain Monte Carlo method which augments the original</span>
<span class="sd">    target variable (henceforth position variable) with a momentum variable with a user</span>
<span class="sd">    specified conditional distribution given the position variable. In each chain</span>
<span class="sd">    iteration two Markov transitions leaving the resulting joint distribution on</span>
<span class="sd">    position and momentum variables invariant are applied - the momentum variables are</span>
<span class="sd">    updated in a transition which leaves their conditional distribution invariant</span>
<span class="sd">    (momentum transition) and then a trajectory in the joint space is generated by</span>
<span class="sd">    numerically integrating a Hamiltonian dynamic with an appropriate symplectic</span>
<span class="sd">    integrator which is exactly reversible, volume preserving and approximately</span>
<span class="sd">    conserves the joint probability density of the target-momentum state pair; one state</span>
<span class="sd">    from the resulting trajectory is then selected as the next joint chain state using</span>
<span class="sd">    an appropriate sampling scheme such that the joint distribution is left exactly</span>
<span class="sd">    invariant (integration transition).</span>

<span class="sd">    There are various options available for both the momentum transition and integration</span>
<span class="sd">    transition, with by default the momentum transition set to be independent resampling</span>
<span class="sd">    of the momentum variables from their conditional distribution.</span>

<span class="sd">    References:</span>
<span class="sd">      1. Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.</span>
<span class="sd">         Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.</span>
<span class="sd">      2. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.</span>
<span class="sd">         Handbook of Markov Chain Monte Carlo, 2(11), p.2.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">rng</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span>
        <span class="n">integration_transition</span><span class="p">:</span> <span class="n">IntegrationTransition</span><span class="p">,</span>
        <span class="n">momentum_transition</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MomentumTransition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to be simulated, corresponding to joint</span>
<span class="sd">                distribution on augmented space.</span>
<span class="sd">            rng: Numpy random number generator.</span>
<span class="sd">            integration_transition: Markov transition kernel which leaves joint</span>
<span class="sd">                distribution invariant and jointly updates the position and momentum</span>
<span class="sd">                components of the chain state by integrating the Hamiltonian dynamics of</span>
<span class="sd">                the system to propose new values for the state.</span>
<span class="sd">            momentum_transition: Markov transition kernel which leaves the conditional</span>
<span class="sd">                distribution on the momentum under the join distribution invariant,</span>
<span class="sd">                updating only the momentum component of the chain state. If set to</span>
<span class="sd">                :py:const:`None` the momentum transition operator</span>
<span class="sd">                :py:class:`mici.transitions.IndependentMomentumTransition` will be used,</span>
<span class="sd">                which independently samples the momentum from its conditional</span>
<span class="sd">                distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_system</span> <span class="o">=</span> <span class="n">system</span>
        <span class="k">if</span> <span class="n">momentum_transition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">momentum_transition</span> <span class="o">=</span> <span class="n">IndependentMomentumTransition</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">rng</span><span class="p">,</span>
            <span class="p">{</span>
                <span class="s2">&quot;momentum_transition&quot;</span><span class="p">:</span> <span class="n">momentum_transition</span><span class="p">,</span>
                <span class="s2">&quot;integration_transition&quot;</span><span class="p">:</span> <span class="n">integration_transition</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">system</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hamiltonian system corresponding to joint distribution on augmented space.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_system</span>

    <span class="k">def</span> <span class="nf">_preprocess_init_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">init_state</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">ChainState</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ChainState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make sure initial state is a ChainState and has momentum.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_state</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># If array use to set position component of new ChainState</span>
            <span class="n">init_state</span> <span class="o">=</span> <span class="n">ChainState</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">init_state</span><span class="p">,</span> <span class="n">mom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_state</span><span class="p">,</span> <span class="n">ChainState</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;mom&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">init_state</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;init_state should be an array or `ChainState` with `mom` attribute.&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init_state</span><span class="o">.</span><span class="n">mom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">sample_momentum</span><span class="p">(</span><span class="n">init_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">init_state</span>

    <span class="k">def</span> <span class="nf">_default_trace_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Default function of the chain state traced while sampling.&quot;&quot;&quot;</span>
        <span class="c1"># This needs to be a method rather than for example a local nested</span>
        <span class="c1"># function in the __set_sample_chains_kwargs_defaults method to ensure</span>
        <span class="c1"># that it remains pickleable and so can be piped to a separate process</span>
        <span class="c1"># when running multiple chains using multiprocessing</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;pos&quot;</span><span class="p">:</span> <span class="n">state</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="s2">&quot;hamiltonian&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">state</span><span class="p">)}</span>

<div class="viewcode-block" id="HamiltonianMonteCarlo.sample_chains"><a class="viewcode-back" href="../../mici.samplers.html#mici.samplers.HamiltonianMonteCarlo.sample_chains">[docs]</a>    <span class="k">def</span> <span class="nf">sample_chains</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_warm_up_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">n_main_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">init_states</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ChainState</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HMCSampleChainsOutputs</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample Markov chains from given initial states with adaptive warm up.</span>

<span class="sd">        One or more Markov chains are sampled, with each chain iteration consisting of a</span>
<span class="sd">        momentum transition followed by an integration transition. The chains are split</span>
<span class="sd">        into multiple *stages* with zero or more adaptive warm up stages followed by the</span>
<span class="sd">        main non-adaptive sampling stage. During the adaptive stage(s) parameters of the</span>
<span class="sd">        integration transition such as the integrator step size are adaptively tuned</span>
<span class="sd">        based on the chain state and/or transition statistics.</span>

<span class="sd">        The default settings use a single (fast)</span>
<span class="sd">        :py:class:`DualAveragingStepSizeAdapter` adapter instance which adapts the</span>
<span class="sd">        integrator step-size using a dual-averaging algorithm in a single adaptive</span>
<span class="sd">        stage.</span>

<span class="sd">        The chains (including both adaptive and non-adaptive stages) may be run in</span>
<span class="sd">        parallel across multiple independent processes or sequentially. In all cases all</span>
<span class="sd">        chains use independent random draws.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_warm_up_iter: Number of adaptive warm up iterations per chain. Depending</span>
<span class="sd">                on the :py:class:`mici.stagers.Stager` instance specified by the</span>
<span class="sd">                :code:`stager` argument the warm up iterations may be split between one</span>
<span class="sd">                or more adaptive stages. If zero, only a single non-adaptive stage is</span>
<span class="sd">                used.</span>
<span class="sd">            n_main_iter: Number of iterations (samples to draw) per chain during main</span>
<span class="sd">                (non-adaptive) sampling stage.</span>
<span class="sd">            init_states: Initial chain states. Each state can be either an array</span>
<span class="sd">                specifying the state position component or a</span>
<span class="sd">                :py:class:`mici.states.ChainState` instance. If an array is passed or</span>
<span class="sd">                the :code:`mom` attribute of the state is not set, a momentum component</span>
<span class="sd">                will be independently sampled from its conditional distribution. One</span>
<span class="sd">                chain will be run for each state in the iterable.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            trace_funcs: Sequence of functions which compute the variables to be</span>
<span class="sd">                recorded at each chain iteration (during only the main non-adaptive</span>
<span class="sd">                sampling stage if :code:`trace_warm_up` is False), with each trace</span>
<span class="sd">                function passed the current state and returning a dictionary of scalar</span>
<span class="sd">                or array values corresponding to the variable(s) to be stored. The keys</span>
<span class="sd">                in the returned dictionaries are used to index the trace arrays in the</span>
<span class="sd">                returned traces dictionary. If a key appears in multiple dictionaries</span>
<span class="sd">                only the the value corresponding to the last trace function to return</span>
<span class="sd">                that key will be stored. Default is to use a single function which</span>
<span class="sd">                records the position component of the state under the key :code:`&quot;pos&quot;`</span>
<span class="sd">                and the Hamiltonian at the state under the key :code:`&quot;hamiltonian&quot;`.</span>
<span class="sd">            adapters: Sequence of :py:class:`mici.adapters.Adapter` instances to use to</span>
<span class="sd">                adaptatively set parameters of the integration transition such as the</span>
<span class="sd">                step size during the adaptive stages of the chains. Note that the</span>
<span class="sd">                adapter updates are applied in the order the adapters appear in the</span>
<span class="sd">                sequence and so if multiple adapters change the same parameter(s) the</span>
<span class="sd">                order will matter. If :code:`None` or an empty sequence no adapters are</span>
<span class="sd">                used. Default is to use a single instance of</span>
<span class="sd">                :py:class:`mici.adapters.DualAveragingStepSizeAdapter` with its default</span>
<span class="sd">                parameters.</span>
<span class="sd">            stager: Chain iteration stager object which controls the split of the chain</span>
<span class="sd">                iterations into the adaptive warm up and non-adaptive main stages. If</span>
<span class="sd">                set to :code:`None` (the default) and all adapters specified by the</span>
<span class="sd">                :code:`adapters` argument are of the fast type (i.e. their</span>
<span class="sd">                :code:`is_fast` attribute is :code:`True`) then a</span>
<span class="sd">                :py:class:`mici.stagers.WarmUpStager` instance will be used</span>
<span class="sd">                corresponding to using a single adaptive warm up stage will all adapters</span>
<span class="sd">                active. If set to :code:`None` and the adapters specified by the</span>
<span class="sd">                adapters argument are not all of the fast type, then a</span>
<span class="sd">                :py:class:`mici.stagers.WindowedWarmUpStager` (with its default</span>
<span class="sd">                arguments) will be used, corresponding to using multiple adaptive warm</span>
<span class="sd">                up stages with only the fast-type adapters active in some - see</span>
<span class="sd">                documentation of :py:class:`mici.stagers.WarmUpStager` for details.</span>
<span class="sd">            n_process: Number of parallel processes to run chains over. If </span>
<span class="sd">                :code:`n_process=1` then chains will be run sequentially otherwise a</span>
<span class="sd">                :py:class:`multiprocessing.Pool` object will be used to dynamically</span>
<span class="sd">                assign the chains across multiple processes. If set to :code:`None` then</span>
<span class="sd">                the number of processes will be set to the output of</span>
<span class="sd">                :py:func:`os.cpu_count()`. Default is :code:`n_process=1`.</span>
<span class="sd">            trace_warm_up: Whether to record chain traces and statistics during warm-up</span>
<span class="sd">                stage iterations (:code:`True`) or only record traces and statistics in</span>
<span class="sd">                the iterations of the final non-adaptive stage (:code:`False`, the</span>
<span class="sd">                default).</span>
<span class="sd">            max_threads_per_process: If :py:mod:`threadpoolctl` is available this</span>
<span class="sd">                argument may be used to limit the maximum number of threads that can be</span>
<span class="sd">                used in thread pools used in libraries supported by</span>
<span class="sd">                :py:mod:`threadpoolctl`, which include BLAS and OpenMP implementations.</span>
<span class="sd">                This argument will only have an effect if :code:`n_process &gt; 1` such</span>
<span class="sd">                that chains are being run on multiple processes and only if</span>
<span class="sd">                :py:mod:`threadpoolctl` is installed in the current Python environment.</span>
<span class="sd">                If set to :code:`None` (the default) no limits are set.</span>
<span class="sd">            force_memmap: Whether to force arrays used to store chain data to be</span>
<span class="sd">                memory-mapped to files on disk to avoid excessive system memory usage</span>
<span class="sd">                for long chains and/or large chain states. The chain data is written to</span>
<span class="sd">                `.npy` files in the directory specified by :code:`memmap_path` (or a</span>
<span class="sd">                temporary directory if :code:`memmap_path` is :code:`None`). Chain data</span>
<span class="sd">                is always memory mapped when sampling chains in parallel on multiple</span>
<span class="sd">                processes.</span>
<span class="sd">            memmap_path: Path to directory to write memory-mapped chain data to. If</span>
<span class="sd">                :code:`None` (the default) and memory-mapping is enabled then a</span>
<span class="sd">                temporary directory will be created and the chain data written to files</span>
<span class="sd">                there, with the created files being deleted in this case once the last</span>
<span class="sd">                reference to them is closed.</span>
<span class="sd">            monitor_stats: Sequence of string keys of (integration) transition</span>
<span class="sd">                statistics to monitor mean of over samples computed so far during</span>
<span class="sd">                sampling by printing as postfix to progress bar. Default is to print</span>
<span class="sd">                only the mean `accept_stat` (acceptance statistic).</span>
<span class="sd">            display_progress: Whether to display a progress bar to track the completed</span>
<span class="sd">                chain sampling iterations. Default value is :code:`True`, i.e. to</span>
<span class="sd">                display progress bar.</span>
<span class="sd">            progress_bar_class: Class or factory function for progress bar to use to</span>
<span class="sd">                show chain progress if enabled (:code:`display_progress=True`). Defaults</span>
<span class="sd">                to :py:class:`mici.progressbars.SequenceProgressBar`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Named tuple :code:`(final_states, traces, statistics)` corresponding to</span>
<span class="sd">            states of chains after final iteration, dictionary of chain trace arrays</span>
<span class="sd">            and dictionary of chain statistics dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_init_state</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">init_states</span><span class="p">]</span>
        <span class="c1"># default to single dual-averaging step size adapter</span>
        <span class="k">if</span> <span class="s2">&quot;adapters&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;adapters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">DualAveragingStepSizeAdapter</span><span class="p">()]</span>
        <span class="c1"># default to tracing position component of state and Hamiltonian</span>
        <span class="k">if</span> <span class="s2">&quot;trace_funcs&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;trace_funcs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_trace_func</span><span class="p">]</span>
        <span class="c1"># if `monitor_stats` specified, expand all statistics keys to key pairs</span>
        <span class="c1"># with transition key set to `integration_transition`</span>
        <span class="k">if</span> <span class="s2">&quot;monitor_stats&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;monitor_stats&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;monitor_stats&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;integration_transition&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;monitor_stats&quot;</span><span class="p">],</span>
                <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;monitor_stats&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;accept_stat&quot;</span><span class="p">]}</span>
        <span class="c1"># if adapters kwarg specified, wrap adapter list in dictionary with</span>
        <span class="c1"># adapters applied to integration transition</span>
        <span class="k">if</span> <span class="s2">&quot;adapters&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;adapters&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;adapters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;adapters&quot;</span><span class="p">]}</span>
        <span class="n">final_states</span><span class="p">,</span> <span class="n">traces</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">sample_chains</span><span class="p">(</span>
            <span class="n">n_warm_up_iter</span><span class="p">,</span>
            <span class="n">n_main_iter</span><span class="p">,</span>
            <span class="n">init_states</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">return</span> <span class="n">HMCSampleChainsOutputs</span><span class="p">(</span><span class="n">final_states</span><span class="p">,</span> <span class="n">traces</span><span class="p">,</span> <span class="n">stats</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="StaticMetropolisHMC"><a class="viewcode-back" href="../../mici.samplers.html#mici.samplers.StaticMetropolisHMC">[docs]</a><span class="k">class</span> <span class="nc">StaticMetropolisHMC</span><span class="p">(</span><span class="n">HamiltonianMonteCarlo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Static integration time HMC method with Metropolis sampling.</span>

<span class="sd">    In each transition a trajectory is generated by integrating the Hamiltonian dynamics</span>
<span class="sd">    from the current state in the current integration time direction for a fixed integer</span>
<span class="sd">    number of integrator steps.</span>

<span class="sd">    The state at the end of the trajectory with the integration direction negated (this</span>
<span class="sd">    ensuring the proposed move is an involution) is used as the proposal in a Metropolis</span>
<span class="sd">    acceptance step. The integration direction is then deterministically negated again</span>
<span class="sd">    irrespective of the accept decision, with the effect being that on acceptance the</span>
<span class="sd">    integration direction will be equal to its initial value and on rejection the</span>
<span class="sd">    integration direction will be the negation of its initial value.</span>

<span class="sd">    This is original proposed Hybrid Monte Carlo (often now instead termed Hamiltonian</span>
<span class="sd">    Monte Carlo) algorithm (Duane et al., 1987; Neal, 2011).</span>

<span class="sd">    References:</span>
<span class="sd">      1. Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.</span>
<span class="sd">         Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.</span>
<span class="sd">      2. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.</span>
<span class="sd">         Handbook of Markov Chain Monte Carlo, 2(11), p.2.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">integrator</span><span class="p">:</span> <span class="n">Integrator</span><span class="p">,</span>
        <span class="n">rng</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span>
        <span class="n">n_step</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">momentum_transition</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MomentumTransition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to be simulated.</span>
<span class="sd">            rng: Numpy random number generator.</span>
<span class="sd">            integrator: Symplectic integrator to use to simulate dynamics in integration</span>
<span class="sd">                transition.</span>
<span class="sd">            n_step: Number of integrator steps to simulate in each integration</span>
<span class="sd">                transition.</span>
<span class="sd">            momentum_transition: Markov transition kernel which leaves the conditional</span>
<span class="sd">                distribution on the momentum under the canonical distribution invariant,</span>
<span class="sd">                updating only the momentum component of the chain state. If set to</span>
<span class="sd">                `None` the momentum transition operator</span>
<span class="sd">                `mici.transitions.IndependentMomentumTransition` will be used, which</span>
<span class="sd">                independently samples the momentum from its conditional distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">integration_transition</span> <span class="o">=</span> <span class="n">MetropolisStaticIntegrationTransition</span><span class="p">(</span>
            <span class="n">system</span><span class="o">=</span><span class="n">system</span><span class="p">,</span>
            <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span>
            <span class="n">n_step</span><span class="o">=</span><span class="n">n_step</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">integration_transition</span><span class="p">,</span> <span class="n">momentum_transition</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_step</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of integrator steps per integrator transition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">n_step</span>

    <span class="nd">@n_step</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n_step must be non-negative&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">n_step</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="RandomMetropolisHMC"><a class="viewcode-back" href="../../mici.samplers.html#mici.samplers.RandomMetropolisHMC">[docs]</a><span class="k">class</span> <span class="nc">RandomMetropolisHMC</span><span class="p">(</span><span class="n">HamiltonianMonteCarlo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Random integration time HMC method with Metropolis sampling of new state.</span>

<span class="sd">    In each transition a trajectory is generated by integrating the Hamiltonian dynamics</span>
<span class="sd">    from the current state in the current integration time direction for a random</span>
<span class="sd">    integer number of integrator steps sampled from the uniform distribution on an</span>
<span class="sd">    integer interval.</span>

<span class="sd">    The state at the end of the trajectory with the integration direction negated (this</span>
<span class="sd">    ensuring the proposed move is an involution) is used as the proposal in a Metropolis</span>
<span class="sd">    acceptance step. The integration direction is then deterministically negated again</span>
<span class="sd">    irrespective of the accept decision, with the effect being that on acceptance the</span>
<span class="sd">    integration direction will be equal to its initial value and on rejection the</span>
<span class="sd">    integration direction will be the negation of its initial value.</span>

<span class="sd">    The randomisation of the number of integration steps avoids the potential of the</span>
<span class="sd">    chain mixing poorly due to using an integration time close to the period of (near)</span>
<span class="sd">    periodic systems (Neal, 2011; Mackenzie, 1989).</span>

<span class="sd">    References:</span>
<span class="sd">      1. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.</span>
<span class="sd">         Handbook of Markov Chain Monte Carlo, 2(11), p.2.</span>
<span class="sd">      2. Mackenzie, P.B., 1989. An improved hybrid Monte Carlo method.</span>
<span class="sd">         Physics Letters B, 226(3-4), pp.369-371.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">integrator</span><span class="p">:</span> <span class="n">Integrator</span><span class="p">,</span>
        <span class="n">rng</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span>
        <span class="n">n_step_range</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">momentum_transition</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MomentumTransition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to be simulated.</span>
<span class="sd">            rng: Numpy random number generator.</span>
<span class="sd">            integrator: Symplectic integrator to use to simulate dynamics in integration</span>
<span class="sd">                transition.</span>
<span class="sd">            n_step_range: tuple `(lower, upper)` with two positive integer entries</span>
<span class="sd">                `lower` and `upper` (with `upper &gt; lower`) specifying respectively the</span>
<span class="sd">                lower and upper bounds (inclusive) of integer interval to uniformly draw</span>
<span class="sd">                random number integrator steps to simulate in each integration</span>
<span class="sd">                transition.</span>
<span class="sd">            momentum_transition: Markov transition kernel which leaves the conditional</span>
<span class="sd">                distribution on the momentum under the canonical distribution invariant,</span>
<span class="sd">                updating only the momentum component of the chain state. If set to</span>
<span class="sd">                :code:`None` the momentum transition operator</span>
<span class="sd">                :py:class:`mici.transitions.IndependentMomentumTransition` will be used,</span>
<span class="sd">                which independently samples the momentum from its conditional</span>
<span class="sd">                distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">integration_transition</span> <span class="o">=</span> <span class="n">MetropolisRandomIntegrationTransition</span><span class="p">(</span>
            <span class="n">system</span><span class="o">=</span><span class="n">system</span><span class="p">,</span>
            <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span>
            <span class="n">n_step_range</span><span class="o">=</span><span class="n">n_step_range</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">integration_transition</span><span class="p">,</span> <span class="n">momentum_transition</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_step_range</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interval to uniformly draw number of integrator steps from.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">n_step_range</span>

    <span class="nd">@n_step_range</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_step_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="n">n_step_lower</span><span class="p">,</span> <span class="n">n_step_upper</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n_step_lower</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n_step_lower</span> <span class="o">&lt;</span> <span class="n">n_step_upper</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Range bounds must be non-negative and first entry less than last.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">n_step_range</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="DynamicMultinomialHMC"><a class="viewcode-back" href="../../mici.samplers.html#mici.samplers.DynamicMultinomialHMC">[docs]</a><span class="k">class</span> <span class="nc">DynamicMultinomialHMC</span><span class="p">(</span><span class="n">HamiltonianMonteCarlo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dynamic integration time HMC method with multinomial sampling from trajectory.</span>

<span class="sd">    In each transition a binary tree of states is recursively computed by integrating</span>
<span class="sd">    randomly forward and backward in time by a number of steps equal to the previous</span>
<span class="sd">    tree size (Hoffman and Gelman, 2014; Betancourt, 2017) until a termination criteria</span>
<span class="sd">    on the tree leaves is met. The next chain state is chosen from the candidate states</span>
<span class="sd">    using a progressive multinomial sampling scheme (Betancourt, 2017) based on the</span>
<span class="sd">    relative probability densities of the different candidate states, with the</span>
<span class="sd">    resampling biased towards states further from the current state.</span>

<span class="sd">    When used with the default settings of</span>
<span class="sd">    :py:class:`mici.transitions.riemannian_no_u_turn_criterion` termination criterion</span>
<span class="sd">    and extra subtree checks enabled (:code:`do_extra_subtree_checks == True`), this</span>
<span class="sd">    sampler is equivalent to the default &#39;NUTS&#39; MCMC algorithm (minus adaptation) used</span>
<span class="sd">    in `Stan &lt;https://mc-stan.org/&gt;`_ as of version v2.23.</span>

<span class="sd">    References:</span>
<span class="sd">      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler: adaptively setting</span>
<span class="sd">         path lengths in Hamiltonian Monte Carlo. Journal of Machine Learning Research,</span>
<span class="sd">         15(1), pp.1593-1623.</span>
<span class="sd">      2. Betancourt, M., 2017. A conceptual introduction to Hamiltonian Monte Carlo.</span>
<span class="sd">         arXiv preprint arXiv:1701.02434.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">integrator</span><span class="p">:</span> <span class="n">Integrator</span><span class="p">,</span>
        <span class="n">rng</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">max_tree_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">max_delta_h</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">termination_criterion</span><span class="p">:</span> <span class="n">TerminationCriterion</span> <span class="o">=</span> <span class="n">riemannian_no_u_turn_criterion</span><span class="p">,</span>
        <span class="n">do_extra_subtree_checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">momentum_transition</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MomentumTransition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to be simulated.</span>
<span class="sd">            rng: Numpy random number generator.</span>
<span class="sd">            integrator: Symplectic integrator to use to simulate dynamics in integration</span>
<span class="sd">                transition.</span>
<span class="sd">            max_tree_depth: Maximum depth to expand trajectory binary tree to in</span>
<span class="sd">                integrator transition. The maximum number of integrator steps</span>
<span class="sd">                corresponds to :code:`2**max_tree_depth`.</span>
<span class="sd">            max_delta_h : Maximum change to tolerate in the Hamiltonian function over a</span>
<span class="sd">                trajectory in integrator transition before signalling a divergence.</span>
<span class="sd">            termination_criterion: Function computing criterion to use to determine when</span>
<span class="sd">                to terminate trajectory tree expansion. The function should take a</span>
<span class="sd">                Hamiltonian system as its first argument, a pair of states corresponding</span>
<span class="sd">                to the two edge nodes in the trajectory (sub-)tree being checked and an</span>
<span class="sd">                array containing the sum of the momentums over the trajectory</span>
<span class="sd">                (sub)-tree. Defaults to</span>
<span class="sd">                :py:class:`mici.transitions.riemannian_no_u_turn_criterion`.</span>
<span class="sd">            do_extra_subtree_checks: Whether to perform additional termination criterion</span>
<span class="sd">                checks on overlapping subtrees of the current tree to improve robustness</span>
<span class="sd">                in systems with dynamics which are well approximated by independent</span>
<span class="sd">                system of simple harmonic oscillators. In such systems (corresponding to</span>
<span class="sd">                e.g. a standard normal target distribution and identity metric matrix</span>
<span class="sd">                representation) at certain step sizes a &#39;resonant&#39; behaviour is seen by</span>
<span class="sd">                which the termination criterion fails to detect that the trajectory has</span>
<span class="sd">                expanded past a half-period i.e. has &#39;U-turned&#39; resulting in</span>
<span class="sd">                trajectories continuing to expand, potentially up until the</span>
<span class="sd">                `max_tree_depth` limit is hit. For more details see `this Stan Discourse</span>
<span class="sd">                discussion &lt;kutt.it/yAkIES&gt;`_. If :code:`do_extra_subtree_checks` is set</span>
<span class="sd">                to :code:`True` additional termination criterion checks are performed on</span>
<span class="sd">                overlapping subtrees which help to reduce this resonant behaviour at the</span>
<span class="sd">                cost of more conservative trajectory termination in some correlated</span>
<span class="sd">                models and some overhead from additional checks.</span>
<span class="sd">            momentum_transition: Markov transition kernel which leaves the conditional</span>
<span class="sd">                distribution on the momentum under the canonical distribution invariant,</span>
<span class="sd">                updating only the momentum component of the chain state. If set to</span>
<span class="sd">                :code:`None` the momentum transition operator</span>
<span class="sd">                :py:class:`mici.transitions.IndependentMomentumTransition` will be used,</span>
<span class="sd">                which independently samples the momentum from its conditional</span>
<span class="sd">                distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">integration_transition</span> <span class="o">=</span> <span class="n">MultinomialDynamicIntegrationTransition</span><span class="p">(</span>
            <span class="n">system</span><span class="o">=</span><span class="n">system</span><span class="p">,</span>
            <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span>
            <span class="n">max_tree_depth</span><span class="o">=</span><span class="n">max_tree_depth</span><span class="p">,</span>
            <span class="n">max_delta_h</span><span class="o">=</span><span class="n">max_delta_h</span><span class="p">,</span>
            <span class="n">termination_criterion</span><span class="o">=</span><span class="n">termination_criterion</span><span class="p">,</span>
            <span class="n">do_extra_subtree_checks</span><span class="o">=</span><span class="n">do_extra_subtree_checks</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">integration_transition</span><span class="p">,</span> <span class="n">momentum_transition</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_tree_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum depth to expand trajectory binary tree to.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max_tree_depth</span>

    <span class="nd">@max_tree_depth</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">max_tree_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;max_tree_depth must be non-negative&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max_tree_depth</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_delta_h</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change in Hamiltonian over trajectory to trigger divergence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max_delta_h</span>

    <span class="nd">@max_delta_h</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">max_delta_h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max_delta_h</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="DynamicSliceHMC"><a class="viewcode-back" href="../../mici.samplers.html#mici.samplers.DynamicSliceHMC">[docs]</a><span class="k">class</span> <span class="nc">DynamicSliceHMC</span><span class="p">(</span><span class="n">HamiltonianMonteCarlo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dynamic integration time HMC method with slice sampling from trajectory.</span>

<span class="sd">    In each transition a binary tree of states is recursively computed by integrating</span>
<span class="sd">    randomly forward and backward in time by a number of steps equal to the previous</span>
<span class="sd">    tree size (Hoffman and Gelman, 2014) until a termination criteria on the tree leaves</span>
<span class="sd">    is met. The next chain state is chosen from the candidate states using a progressive</span>
<span class="sd">    slice sampling scheme (Hoffman and Gelman, 2014) based on the relative probability</span>
<span class="sd">    densities of the different candidate states, with the sampling biased towards states</span>
<span class="sd">    further from the current state.</span>

<span class="sd">    When used with the default setting of `euclidean_no_u_turn_criterion` termination</span>
<span class="sd">    criterion and extra subtree checks disabled, this sampler is equivalent to</span>
<span class="sd">    &#39;Algorithm 3: Efficient No-U-Turn Sampler&#39; in Hoffman and Gelman (2014), i.e. the</span>
<span class="sd">    &#39;classic NUTS&#39; algorithm.</span>

<span class="sd">    References:</span>
<span class="sd">      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:</span>
<span class="sd">         adaptively setting path lengths in Hamiltonian Monte Carlo.</span>
<span class="sd">         Journal of Machine Learning Research, 15(1), pp.1593-1623.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">integrator</span><span class="p">:</span> <span class="n">Integrator</span><span class="p">,</span>
        <span class="n">rng</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">max_tree_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">max_delta_h</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1000.0</span><span class="p">,</span>
        <span class="n">termination_criterion</span><span class="p">:</span> <span class="n">TerminationCriterion</span> <span class="o">=</span> <span class="n">euclidean_no_u_turn_criterion</span><span class="p">,</span>
        <span class="n">do_extra_subtree_checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">momentum_transition</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MomentumTransition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to be simulated.</span>
<span class="sd">            rng: Numpy random number generator.</span>
<span class="sd">            integrator: Symplectic integrator to use to simulate dynamics in integration</span>
<span class="sd">                transition.</span>
<span class="sd">            max_tree_depth: Maximum depth to expand trajectory binary tree to in</span>
<span class="sd">                integrator transition. The maximum number of integrator steps</span>
<span class="sd">                corresponds to :code:`2**max_tree_depth`.</span>
<span class="sd">            max_delta_h: Maximum change to tolerate in the Hamiltonian function over a</span>
<span class="sd">                trajectory in integrator transition before signalling a divergence.</span>
<span class="sd">            termination_criterion: Function computing criterion to use to determine when</span>
<span class="sd">                to terminate trajectory tree expansion. The function should take a</span>
<span class="sd">                Hamiltonian system as its first argument, a pair of states corresponding</span>
<span class="sd">                to the two edge nodes in the trajectory (sub-)tree being checked and an</span>
<span class="sd">                array containing the sum of the momentums over the trajectory</span>
<span class="sd">                (sub)-tree. Defaults to</span>
<span class="sd">                :py:class:`mici.transitions.euclidean_no_u_turn_criterion`.</span>
<span class="sd">            do_extra_subtree_checks: Whether to perform additional termination criterion</span>
<span class="sd">                checks on overlapping subtrees of the current tree to improve robustness</span>
<span class="sd">                in systems with dynamics which are well approximated by independent</span>
<span class="sd">                system of simple harmonic oscillators. In such systems (corresponding to</span>
<span class="sd">                e.g. a standard normal target distribution and identity metric matrix</span>
<span class="sd">                representation) at certain step sizes a &#39;resonant&#39; behaviour is seen by</span>
<span class="sd">                which the termination criterion fails to detect that the trajectory has</span>
<span class="sd">                expanded past a half-period i.e. has &#39;U-turned&#39; resulting in</span>
<span class="sd">                trajectories continuing to expand, potentially up until the</span>
<span class="sd">                `max_tree_depth` limit is hit. For more details see `this Stan Discourse</span>
<span class="sd">                discussion &lt;kutt.it/yAkIES&gt;`_. If :code:`do_extra_subtree_checks` is set</span>
<span class="sd">                to :code:`True` additional termination criterion checks are performed on</span>
<span class="sd">                overlapping subtrees which help to reduce this resonant behaviour at the</span>
<span class="sd">                cost of more conservative trajectory termination in some correlated</span>
<span class="sd">                models and some overhead from additional checks.</span>
<span class="sd">            momentum_transition: Markov transition kernel which leaves the conditional</span>
<span class="sd">                distribution on the momentum under the canonical distribution invariant,</span>
<span class="sd">                updating only the momentum component of the chain state. If set to</span>
<span class="sd">                :code:`None` the momentum transition operator</span>
<span class="sd">                :py:class:`mici.transitions.IndependentMomentumTransition` will be used,</span>
<span class="sd">                which independently samples the momentum from its conditional</span>
<span class="sd">                distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">integration_transition</span> <span class="o">=</span> <span class="n">SliceDynamicIntegrationTransition</span><span class="p">(</span>
            <span class="n">system</span><span class="o">=</span><span class="n">system</span><span class="p">,</span>
            <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span>
            <span class="n">max_tree_depth</span><span class="o">=</span><span class="n">max_tree_depth</span><span class="p">,</span>
            <span class="n">max_delta_h</span><span class="o">=</span><span class="n">max_delta_h</span><span class="p">,</span>
            <span class="n">termination_criterion</span><span class="o">=</span><span class="n">termination_criterion</span><span class="p">,</span>
            <span class="n">do_extra_subtree_checks</span><span class="o">=</span><span class="n">do_extra_subtree_checks</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">integration_transition</span><span class="p">,</span> <span class="n">momentum_transition</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_tree_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum depth to expand trajectory binary tree to.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max_tree_depth</span>

    <span class="nd">@max_tree_depth</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">max_tree_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;max_tree_depth must be non-negative&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max_tree_depth</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_delta_h</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change in Hamiltonian over trajectory to trigger divergence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max_delta_h</span>

    <span class="nd">@max_delta_h</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">max_delta_h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="s2">&quot;integration_transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max_delta_h</span> <span class="o">=</span> <span class="n">value</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Matt Graham.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>