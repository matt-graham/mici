<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mici.integrators &mdash; Mici 0.2.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/mici-logo-rectangular.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mici.html">mici package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Mici</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mici.integrators</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mici.integrators</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Symplectic integrators for simulation of Hamiltonian dynamics.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">mici.errors</span> <span class="kn">import</span> <span class="n">AdaptationError</span><span class="p">,</span> <span class="n">NonReversibleStepError</span>
<span class="kn">from</span> <span class="nn">mici.solvers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">FixedPointSolver</span><span class="p">,</span>
    <span class="n">ProjectionSolver</span><span class="p">,</span>
    <span class="n">maximum_norm</span><span class="p">,</span>
    <span class="n">solve_fixed_point_direct</span><span class="p">,</span>
    <span class="n">solve_projection_onto_manifold_newton</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span>

    <span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span>

    <span class="kn">from</span> <span class="nn">mici.states</span> <span class="kn">import</span> <span class="n">ChainState</span>
    <span class="kn">from</span> <span class="nn">mici.systems</span> <span class="kn">import</span> <span class="n">ConstrainedTractableFlowSystem</span><span class="p">,</span> <span class="n">System</span><span class="p">,</span> <span class="n">TractableFlowSystem</span>
    <span class="kn">from</span> <span class="nn">mici.types</span> <span class="kn">import</span> <span class="n">NormFunction</span>


<div class="viewcode-block" id="Integrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.Integrator">[docs]</a><span class="k">class</span> <span class="nc">Integrator</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Base class for integrators for simulating Hamiltonian dynamics.</span>

<span class="sd">    For a Hamiltonian function :math:`h` with position variables :math:`q` and momentum</span>
<span class="sd">    variables :math:`p`, the canonical Hamiltonian dynamic is defined by the ordinary</span>
<span class="sd">    differential equation system</span>

<span class="sd">    .. math::</span>

<span class="sd">        \dot{q} = \nabla_2 h(q, p),  \qquad \dot{p} = -\nabla_1 h(q, p),</span>

<span class="sd">    with the flow map :math:`\Phi` corresponding to the solution of the corresponding</span>
<span class="sd">    initial value problem a time-reversible and symplectic (and by consequence</span>
<span class="sd">    volume-preserving) map.</span>

<span class="sd">    Derived classes implement a :py:meth:`step` method which approximates the flow-map</span>
<span class="sd">    with :math:`\Psi(t) \approx \Phi(t)` over some small time interval :math:`t`, while</span>
<span class="sd">    conserving the properties of being time-reversible and symplectic, with composition</span>
<span class="sd">    of this integrator step method allowing simulation of time-discretised trajectories</span>
<span class="sd">    of the Hamiltonian dynamics.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span> <span class="o">=</span> <span class="n">system</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span>

<div class="viewcode-block" id="Integrator.step"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.Integrator.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ChainState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a single integrator step from a supplied state.</span>

<span class="sd">        Args:</span>
<span class="sd">            state: System state to perform integrator step from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            New object corresponding to stepped state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Integrator `step_size` is `None`. This value should only be used if a &quot;</span>
                <span class="s2">&quot;step size adapter is being used to set the step size.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">AdaptationError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dir</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Implementation of single integrator step.</span>

<span class="sd">        Args:</span>
<span class="sd">            state: System state to perform integrator step from. Updated in place.</span>
<span class="sd">            time_step: Integrator time step. May be positive or negative.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="TractableFlowIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.TractableFlowIntegrator">[docs]</a><span class="k">class</span> <span class="nc">TractableFlowIntegrator</span><span class="p">(</span><span class="n">Integrator</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Base class for integrators for Hamiltonian systems with tractable flows.</span>

<span class="sd">    The Hamiltonian function is assumed to be expressible as the sum of two analytically</span>
<span class="sd">    tractable components for which the corresponding Hamiltonian flows can be exactly</span>
<span class="sd">    simulated. Specifically it is assumed that the Hamiltonian function :math:`h` takes</span>
<span class="sd">    the form</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(q, p),</span>

<span class="sd">    where :math:`q` and :math:`p` are the position and momentum variables respectively,</span>
<span class="sd">    and :math:`h_1` and :math:`h_2` are Hamiltonian component functions for which the</span>
<span class="sd">    exact flow maps, :math:`\Phi_1` and :math:`\Phi_2` respectively, can be computed</span>
<span class="sd">    exactly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">TractableFlowSystem</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of with tractable</span>
<span class="sd">                Hamiltonian component flows.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="s2">&quot;h1_flow&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="s2">&quot;h2_flow&quot;</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> can only be used for systems with explicit `h1_flow` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;and `h2_flow` Hamiltonian component flow maps. For systems in which &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;only `h1_flow` is available the `ImplicitLeapfrogIntegrator` class &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;may be used instead and for systems in which neither `h1_flow` or &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`h2_flow` is available the `ImplicitMidpointIntegrator` class may be &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;used.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="LeapfrogIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.LeapfrogIntegrator">[docs]</a><span class="k">class</span> <span class="nc">LeapfrogIntegrator</span><span class="p">(</span><span class="n">TractableFlowIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Leapfrog integrator for Hamiltonian systems with tractable component flows.</span>

<span class="sd">    The overall integrator step :math:`\Psi` is defined by the symmetric composition</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Psi(t) = \Phi_1(t/2) \circ \Phi_2(t) \circ \Phi_1(t/2)</span>

<span class="sd">    where :math:`\Phi_1` and :math:`\Phi_2` are the exact flow maps associated with the</span>
<span class="sd">    Hamiltonian components :math:`h_1` and :math:`h_2` respectively.</span>

<span class="sd">    For separable Hamiltonians of the</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(p),</span>

<span class="sd">    where :math:`h_1` is the potential energy and :math:`h_2` is the kinetic energy,</span>
<span class="sd">    this integrator corresponds to the classic (position) Störmer-Verlet method.</span>

<span class="sd">    The integrator can also be applied to the more general Hamiltonian splitting</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(q, p),</span>

<span class="sd">    providing the flows for :math:`h_1` and :math:`h_2` are both tractable.</span>

<span class="sd">    For more details see Sections 2.6 and 4.2.2 in Leimkuhler and Reich (2004).</span>

<span class="sd">    References:</span>
<span class="sd">      1. Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).</span>
<span class="sd">         Cambridge University Press.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h2_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span></div>


<div class="viewcode-block" id="SymmetricCompositionIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.SymmetricCompositionIntegrator">[docs]</a><span class="k">class</span> <span class="nc">SymmetricCompositionIntegrator</span><span class="p">(</span><span class="n">TractableFlowIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Symmetric composition integrator for Hamiltonians with tractable flows.</span>

<span class="sd">    The Hamiltonian function is assumed to be expressible as the sum of two analytically</span>
<span class="sd">    tractable components for which the corresponding Hamiltonian flows can be exactly</span>
<span class="sd">    simulated. Specifically it is assumed that the Hamiltonian function :math:`h` takes</span>
<span class="sd">    the form</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(q, p),</span>

<span class="sd">    where :math:`q` and :math:`p` are the position and momentum variables respectively,</span>
<span class="sd">    and :math:`h_1` and :math:`h_2` are Hamiltonian component functions for which the</span>
<span class="sd">    exact flows, respectively :math:`\Phi_1` and :math:`\Phi_2`, can be computed. An</span>
<span class="sd">    alternating composition can then be formed as</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Psi(t) = A(a_S t) \circ B(b_S t) \circ \dots \circ</span>
<span class="sd">                  A(a_1 t) \circ B(b_1 t) \circ A(a_0 t),</span>

<span class="sd">    where :math:`A = \Phi_1` and :math:`B = \Phi_2` or :math:`A = \Phi_2` and :math:`B =</span>
<span class="sd">    \Phi_1`, and :math:`(a_0,\dots, a_S)` and :math:`(b_1, \dots, b_S)` are a set of</span>
<span class="sd">    coefficients to be determined with :math:`S \geq 1`.</span>

<span class="sd">    To ensure a consistency (i.e. the integrator is at least order one) we require that</span>

<span class="sd">    .. math::</span>

<span class="sd">        \sum_{s=0}^S a_s = \sum_{s=1}^S b_s = 1.</span>

<span class="sd">    For symmetric compositions we restrict that</span>

<span class="sd">    .. math::</span>

<span class="sd">        a_{S-m} = a_m, \quad b_{S+1-m} = b_m,</span>

<span class="sd">    with symmetric consistent methods of at least order two.</span>

<span class="sd">    The combination of the symmetry and consistency requirements mean that for each</span>
<span class="sd">    :math:`S \geq 1` a symmetric composition method can be described by :math:`S - 1`</span>
<span class="sd">    &#39;free&#39; coefficients :math:`(a_0, b_1, \dots, a_{K-1}, b_K)`  with</span>
<span class="sd">    :math:`K = (S - 1) / 2` if :math:`S &gt; 1` is odd (with no free coefficients for</span>
<span class="sd">    :math:`S = 1` case) or :math:`(a_0, b_1, \dots, a_K)` with :math:`K = (S - 2) / 2`</span>
<span class="sd">    if :math:`S &gt; 2` is even (with a single free coefficient :math:`a_0` for :math:`S=2`</span>
<span class="sd">    case).</span>

<span class="sd">    The Störmer-Verlet &#39;leapfrog&#39; integrator is the special case corresponding to the</span>
<span class="sd">    unique (symmetric and consistent) &#39;1-stage&#39; (:math:`S = 1`) integrator.</span>

<span class="sd">    For more details see Section 6.2 in Leimkuhler and Reich (2004).</span>

<span class="sd">    References:</span>
<span class="sd">      1. Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).</span>
<span class="sd">         Cambridge University Press.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">TractableFlowSystem</span><span class="p">,</span>
        <span class="n">free_coefficients</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">initial_h1_flow_step</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of with tractable</span>
<span class="sd">                Hamiltonian component flows.</span>
<span class="sd">            free_coefficients: Sequence of :math:`S - 1` scalar values, where :math:`S`</span>
<span class="sd">                is the number of stages in the symmetric composition, specifying the</span>
<span class="sd">                free coefficients :math:`(a_0, b_1, a_1, \dots, a_K, b_K)` with :math:`K</span>
<span class="sd">                = (S - 1) / 2` if :math:`S` is odd or :math:`(a_0, b_1, a_1, \dots,</span>
<span class="sd">                a_K)` with :math:`k = (S - 2) / 2` if `S` is even.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">            initial_h1_flow_step: Whether the initial :math:`A` flow in the composition</span>
<span class="sd">                should correspond to the flow of the `h_1` Hamiltonian component</span>
<span class="sd">                (:code:`True`) or to the flow of the :math:`h_2` component</span>
<span class="sd">                (:code:`False`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_h1_flow_step</span> <span class="o">=</span> <span class="n">initial_h1_flow_step</span>
        <span class="n">n_free_coefficients</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_coefficients</span><span class="p">)</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">free_coefficients</span><span class="p">)</span>
        <span class="n">coefficients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="mf">0.5</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">free_coefficients</span><span class="p">[(</span><span class="n">n_free_coefficients</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">::</span> <span class="mi">2</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="n">coefficients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">free_coefficients</span><span class="p">[(</span><span class="n">n_free_coefficients</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">::</span> <span class="mi">2</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">=</span> <span class="n">coefficients</span> <span class="o">+</span> <span class="n">coefficients</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">flow_a</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span> <span class="k">if</span> <span class="n">initial_h1_flow_step</span> <span class="k">else</span> <span class="n">system</span><span class="o">.</span><span class="n">h2_flow</span>
        <span class="n">flow_b</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">h2_flow</span> <span class="k">if</span> <span class="n">initial_h1_flow_step</span> <span class="k">else</span> <span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flows</span> <span class="o">=</span> <span class="p">[</span><span class="n">flow_a</span><span class="p">,</span> <span class="n">flow_b</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_free_coefficients</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">flow_a</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">flow</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">):</span>
            <span class="n">flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">coefficient</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span></div>


<div class="viewcode-block" id="BCSSTwoStageIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.BCSSTwoStageIntegrator">[docs]</a><span class="k">class</span> <span class="nc">BCSSTwoStageIntegrator</span><span class="p">(</span><span class="n">SymmetricCompositionIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Two-stage symmetric composition integrator due to Blanes, Casas &amp; Sanz-Serna.</span>

<span class="sd">    Described in equation (6.4) in Blanes, Casas, Sanz-Serna (2014).</span>

<span class="sd">    Corresponds to specific instance of :py:class:`SymmetricCompositionIntegrator` with</span>
<span class="sd">    :math:`S = 2` and free coefficient :math:`a_0 = (3 - \sqrt{3}) / 6`.</span>

<span class="sd">    References:</span>
<span class="sd">      1. Blanes, S., Casas, F., &amp; Sanz-Serna, J. M. (2014).</span>
<span class="sd">         Numerical integrators for the Hybrid Monte Carlo method.</span>
<span class="sd">         SIAM Journal on Scientific Computing, 36(4), A1556-A1580.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">TractableFlowSystem</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of with tractable</span>
<span class="sd">                Hamiltonian component flows.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a_0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="p">(</span><span class="n">a_0</span><span class="p">,),</span> <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span> <span class="n">initial_h1_flow_step</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="BCSSThreeStageIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.BCSSThreeStageIntegrator">[docs]</a><span class="k">class</span> <span class="nc">BCSSThreeStageIntegrator</span><span class="p">(</span><span class="n">SymmetricCompositionIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Three-stage symmetric composition integrator due to Blanes, Casas &amp; Sanz-Serna.</span>

<span class="sd">    Described in equation (6.7) in Blanes, Casas, Sanz-Serna (2014).</span>

<span class="sd">    Corresponds to specific instance of :py:class:`SymmetricCompositionIntegrator` with</span>
<span class="sd">    :math:`S = 3` and free coefficients :math:`a_0 = 0.11888010966548` and</span>
<span class="sd">    :math:`b_1 = 0.29619504261126`.</span>

<span class="sd">    References:</span>
<span class="sd">      1. Blanes, S., Casas, F., &amp; Sanz-Serna, J. M. (2014).</span>
<span class="sd">         Numerical integrators for the Hybrid Monte Carlo method.</span>
<span class="sd">         SIAM Journal on Scientific Computing, 36(4), A1556-A1580.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">TractableFlowSystem</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of with tractable</span>
<span class="sd">                Hamiltonian component flows.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a_0</span> <span class="o">=</span> <span class="mf">0.11888010966548</span>
        <span class="n">b_1</span> <span class="o">=</span> <span class="mf">0.29619504261126</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">system</span><span class="p">,</span>
            <span class="p">(</span><span class="n">a_0</span><span class="p">,</span> <span class="n">b_1</span><span class="p">),</span>
            <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span>
            <span class="n">initial_h1_flow_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BCSSFourStageIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.BCSSFourStageIntegrator">[docs]</a><span class="k">class</span> <span class="nc">BCSSFourStageIntegrator</span><span class="p">(</span><span class="n">SymmetricCompositionIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Four-stage symmetric composition integrator due to Blanes, Casas &amp; Sanz-Serna.</span>

<span class="sd">    Described in equation (6.8) in Blanes, Casas, Sanz-Serna (2014).</span>

<span class="sd">    Corresponds to specific instance of :py:class:`SymmetricCompositionIntegrator` with</span>
<span class="sd">    :math:`S = 4` and free coefficients :math:`a_0 = 0.071353913450279725904`,</span>
<span class="sd">    :math:`b_1 = 0.191667800000000000000` and :math:`a_1 = 0.268548791161230105820`.</span>

<span class="sd">    References:</span>
<span class="sd">      1. Blanes, S., Casas, F., &amp; Sanz-Serna, J. M. (2014).</span>
<span class="sd">         Numerical integrators for the Hybrid Monte Carlo method.</span>
<span class="sd">         SIAM Journal on Scientific Computing, 36(4), A1556-A1580.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">TractableFlowSystem</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of with tractable</span>
<span class="sd">                Hamiltonian component flows.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that</span>
<span class="sd">                a step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a_0</span> <span class="o">=</span> <span class="mf">0.071353913450279725904</span>
        <span class="n">b_1</span> <span class="o">=</span> <span class="mf">0.191667800000000000000</span>
        <span class="n">a_1</span> <span class="o">=</span> <span class="mf">0.268548791161230105820</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">system</span><span class="p">,</span>
            <span class="p">(</span><span class="n">a_0</span><span class="p">,</span> <span class="n">b_1</span><span class="p">,</span> <span class="n">a_1</span><span class="p">),</span>
            <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span>
            <span class="n">initial_h1_flow_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ImplicitLeapfrogIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.ImplicitLeapfrogIntegrator">[docs]</a><span class="k">class</span> <span class="nc">ImplicitLeapfrogIntegrator</span><span class="p">(</span><span class="n">Integrator</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Implicit leapfrog integrator for Hamiltonians with a non-separable component.</span>

<span class="sd">    Also known as the generalised leapfrog method.</span>

<span class="sd">    The Hamiltonian function :math:`h` is assumed to take the form</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(q, p),</span>

<span class="sd">    where :math:`q` and :math:`p` are the position and momentum variables respectively,</span>
<span class="sd">    :math:`h_1` is a Hamiltonian component function for which the exact flow can be</span>
<span class="sd">    computed and :math:`h_2` is a Hamiltonian component function of the position and</span>
<span class="sd">    momentum variables, which may be non-separable and for which exact simulation of the</span>
<span class="sd">    correspond Hamiltonian flow may not be possible.</span>

<span class="sd">    The overall integrator step :math:`\Psi` is defined by the symmetric composition</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Psi(t) =</span>
<span class="sd">        A(t/2) \circ B(t/2) \circ C(t/2) \circ C^*(t/2) \circ B^*(t/2) \circ A^*(t/2),</span>

<span class="sd">    where the *adjoint* of a flow map :math:`X` is defined such that :math:`X^*(t) =</span>
<span class="sd">    X(-t)^{-1}` and the component maps are defined by</span>

<span class="sd">    .. math::</span>

<span class="sd">        A(t)(q, p) = A^*(t)(q, p) = (q, p - t\nabla h_1(q)), \\</span>
<span class="sd">        B(t)(q, p) = \lbrace (q, p&#39;) : p&#39; = p - t \nabla_1 h_2(q, p&#39;) \rbrace, \\</span>
<span class="sd">        B^*(t)(q, p) = (q, p - t \nabla_1 h_2(q, p)), \\</span>
<span class="sd">        C(t)(q, p) = (q + t \nabla_2 h_2(q, p), p), \\</span>
<span class="sd">        C^*(t)(q, p) = \lbrace (q&#39;, p) : q&#39; = q + t \nabla_2 h_2(q&#39;, p) \rbrace.</span>

<span class="sd">    The resulting implicit integrator is a symmetric second-order method corresponding</span>
<span class="sd">    to a symplectic partitioned Runge-Kutta method. See Section 6.3.2 in Leimkuhler and</span>
<span class="sd">    Reich (2004) for more details.</span>

<span class="sd">    Fixed-point iterations are used to solve the non-linear systems of equations in the</span>
<span class="sd">    implicit component updates (:math:`B` and :math:`C^*`). As the iterative solves may</span>
<span class="sd">    fail to converge, or may converge to one of multiple solutions, following the</span>
<span class="sd">    approach proposed by Zappa, Holmes-Cerfon and Goodman (2018), an explicit</span>
<span class="sd">    *reversibility check* is performed to ensure the overall integrator step is</span>
<span class="sd">    time-reversible. If the reversibility check fails or the iterative solver fails to</span>
<span class="sd">    converge an appropriate error is raised</span>
<span class="sd">    (:py:exc:`mici.errors.NonReversibleStepError` and</span>
<span class="sd">    :py:exc:`mici.errors.ConvergenceError` respectively).</span>

<span class="sd">    References:</span>
<span class="sd">      1. Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).</span>
<span class="sd">         Cambridge University Press.</span>
<span class="sd">      2. Zappa, E., Holmes-Cerfon, M., &amp; Goodman, J. (2018). Monte Carlo on manifolds:</span>
<span class="sd">         sampling densities and integrating functions. Communications on Pure and</span>
<span class="sd">         Applied Mathematics, 71(12), 2609-2647.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reverse_check_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2e-8</span><span class="p">,</span>
        <span class="n">reverse_check_norm</span><span class="p">:</span> <span class="n">NormFunction</span> <span class="o">=</span> <span class="n">maximum_norm</span><span class="p">,</span>
        <span class="n">fixed_point_solver</span><span class="p">:</span> <span class="n">FixedPointSolver</span> <span class="o">=</span> <span class="n">solve_fixed_point_direct</span><span class="p">,</span>
        <span class="n">fixed_point_solver_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">            reverse_check_tol: Tolerance for check of reversibility of implicit</span>
<span class="sd">                sub-steps which involve iterative solving of a non-linear system of</span>
<span class="sd">                equations. The step is assumed to be reversible if sequentially applying</span>
<span class="sd">                the forward and adjoint updates to a state returns to a state with a</span>
<span class="sd">                position component within a distance (defined by the</span>
<span class="sd">                :code:`reverse_check_norm` argument) of :code:`reverse_check_tol` of the</span>
<span class="sd">                original state position component. If this condition is not met a</span>
<span class="sd">                :py:exc:`mici.errors.NonReversibleStepError` exception is raised.</span>
<span class="sd">            reverse_check_norm: Norm function accepting a single one-dimensional array</span>
<span class="sd">                input and returning a non-negative floating point value defining the</span>
<span class="sd">                distance to use in the reversibility check. Defaults to</span>
<span class="sd">                :py:func:`mici.solvers.maximum_norm`.</span>
<span class="sd">            fixed_point_solver:  Function which given a function :code:`func` and</span>
<span class="sd">                initial guess :code:`x0` iteratively solves the fixed point equation</span>
<span class="sd">                :code:`func(x) = x` initialising the iteration with :code:`x0` and</span>
<span class="sd">                returning an array corresponding to the solution if the iteration</span>
<span class="sd">                converges or raising a :py:class:`mici.errors.ConvergenceError`</span>
<span class="sd">                otherwise. Defaults to :py:exc:`mici.solvers.solve_fixed_point_direct`.</span>
<span class="sd">            fixed_point_solver_kwargs: Dictionary of any keyword arguments to</span>
<span class="sd">                :code:`fixed_point_solver`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span> <span class="o">=</span> <span class="n">reverse_check_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span> <span class="o">=</span> <span class="n">reverse_check_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver</span> <span class="o">=</span> <span class="n">fixed_point_solver</span>
        <span class="k">if</span> <span class="n">fixed_point_solver_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fixed_point_solver_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver_kwargs</span> <span class="o">=</span> <span class="n">fixed_point_solver_kwargs</span>

    <span class="k">def</span> <span class="nf">_solve_fixed_point</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fixed_point_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">ArrayLike</span><span class="p">],</span>
        <span class="n">x_init</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver</span><span class="p">(</span>
            <span class="n">fixed_point_func</span><span class="p">,</span>
            <span class="n">x_init</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_b_fwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">fixed_point_func</span><span class="p">(</span><span class="n">mom</span><span class="p">):</span>
            <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="n">mom</span>
            <span class="k">return</span> <span class="n">mom_init</span> <span class="o">-</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh2_dpos</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">mom_init</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mom</span>
        <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_fixed_point</span><span class="p">(</span><span class="n">fixed_point_func</span><span class="p">,</span> <span class="n">mom_init</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_b_adj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">mom_init</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mom</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">-=</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh2_dpos</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">state_back</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_b_fwd</span><span class="p">(</span><span class="n">state_back</span><span class="p">,</span> <span class="o">-</span><span class="n">time_step</span><span class="p">)</span>
        <span class="n">rev_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span><span class="p">(</span><span class="n">state_back</span><span class="o">.</span><span class="n">mom</span> <span class="o">-</span> <span class="n">mom_init</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rev_diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Non-reversible step. Distance between initial and forward-backward &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;integrated momentums = </span><span class="si">{</span><span class="n">rev_diff</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">NonReversibleStepError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_c_fwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">pos_init</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh2_dmom</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">state_back</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_c_adj</span><span class="p">(</span><span class="n">state_back</span><span class="p">,</span> <span class="o">-</span><span class="n">time_step</span><span class="p">)</span>
        <span class="n">rev_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span><span class="p">(</span><span class="n">state_back</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">pos_init</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rev_diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Non-reversible step. Distance between initial and forward-backward &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;integrated positions = </span><span class="si">{</span><span class="n">rev_diff</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">NonReversibleStepError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_c_adj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">fixed_point_func</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="n">state</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="k">return</span> <span class="n">pos_init</span> <span class="o">+</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh2_dmom</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">pos_init</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">state</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_fixed_point</span><span class="p">(</span><span class="n">fixed_point_func</span><span class="p">,</span> <span class="n">pos_init</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_b_fwd</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_c_fwd</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_c_adj</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_b_adj</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span></div>


<div class="viewcode-block" id="ImplicitMidpointIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.ImplicitMidpointIntegrator">[docs]</a><span class="k">class</span> <span class="nc">ImplicitMidpointIntegrator</span><span class="p">(</span><span class="n">Integrator</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Implicit midpoint integrator for general Hamiltonians.</span>

<span class="sd">    The Hamiltonian function :math:`h` may be a general (non-separable) function of both</span>
<span class="sd">    the position variables :math:`q` and momentum variables :math:`p`.</span>

<span class="sd">    The Hamiltonian flow :math:`\Phi` is approximated with the symmetric composition</span>
<span class="sd">    :math:`\Psi(t) = A(t/2) \circ A^*(t/2)` of an implicit Euler half-step</span>
<span class="sd">    :math:`A(t/2)` with an explicit Euler half-step :math:`A^*(t/2)` (which is adjoint</span>
<span class="sd">    to the implicit Euler step, that is :math:`A^*(t) = A(-t)^{-1}`), with the</span>
<span class="sd">    components maps defined by</span>

<span class="sd">    .. math::</span>

<span class="sd">        A(t)(q, p) = \lbrace</span>
<span class="sd">        (q&#39;, p&#39;) :</span>
<span class="sd">        q&#39; = q +  t \nabla_2 h(q&#39;, p&#39;),</span>
<span class="sd">        p&#39; = p - t \nabla_1 h(q&#39;, p&#39;))</span>
<span class="sd">        \rbrace, \\</span>
<span class="sd">        A^*(t)(q, p) = (q +  t \nabla_2 h(q, p), p - t \nabla_1 h(q, p)).</span>

<span class="sd">    The resulting implicit integrator is a second-order method corresponding to a</span>
<span class="sd">    symplectic one-stage Runge-Kutta method. See Sections 4.1 and 6.3.1 in Leimkuhler</span>
<span class="sd">    and Reich (2004) for more details.</span>

<span class="sd">    A fixed-point iteration is used to solve the non-linear system of equations in the</span>
<span class="sd">    implicit Euler step :math:`A`. As the iterative solve may fail to converge, or may</span>
<span class="sd">    converge to one of multiple solutions, following the approach proposed by</span>
<span class="sd">    Zappa, Holmes-Cerfon and Goodman (2018), an explicit *reversibility check* is</span>
<span class="sd">    performed to ensure the overall integrator step is time-reversible. If the</span>
<span class="sd">    reversibility check fails or the iterative solver fails to converge an appropriate</span>
<span class="sd">    error is raised (:py:exc:`mici.errors.NonReversibleStepError` and</span>
<span class="sd">    :py:exc:`mici.errors.ConvergenceError` respectively).</span>

<span class="sd">    References:</span>
<span class="sd">      1. Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).</span>
<span class="sd">         Cambridge University Press.</span>
<span class="sd">      2. Zappa, E., Holmes-Cerfon, M., &amp; Goodman, J. (2018). Monte Carlo on manifolds:</span>
<span class="sd">         sampling densities and integrating functions. Communications on Pure and</span>
<span class="sd">         Applied Mathematics, 71(12), 2609-2647.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reverse_check_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2e-8</span><span class="p">,</span>
        <span class="n">reverse_check_norm</span><span class="p">:</span> <span class="n">NormFunction</span> <span class="o">=</span> <span class="n">maximum_norm</span><span class="p">,</span>
        <span class="n">fixed_point_solver</span><span class="p">:</span> <span class="n">FixedPointSolver</span> <span class="o">=</span> <span class="n">solve_fixed_point_direct</span><span class="p">,</span>
        <span class="n">fixed_point_solver_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                `step` method.</span>
<span class="sd">            reverse_check_tol: Tolerance for check of reversibility of implicit Euler</span>
<span class="sd">                steps which involve iterative solving of a non-linear system of</span>
<span class="sd">                equations. The step is assumed to be reversible if sequentially applying</span>
<span class="sd">                the forward and adjoint updates to a state returns to a state with a</span>
<span class="sd">                position component within a distance (defined by the</span>
<span class="sd">                :code:`reverse_check_norm` argument) of :code:`reverse_check_tol` of the</span>
<span class="sd">                original state position component. If this condition is not met a</span>
<span class="sd">                :py:exc:`mici.errors.NonReversibleStepError` exception is raised.</span>
<span class="sd">            reverse_check_norm: Norm function accepting a single one-dimensional array</span>
<span class="sd">                input and returning a non-negative floating point value defining the</span>
<span class="sd">                distance to use in the reversibility check. Defaults to</span>
<span class="sd">                :py:func:`mici.solvers.maximum_norm`.</span>
<span class="sd">            fixed_point_solver: Function which given a function :code:`func` and initial</span>
<span class="sd">                guess :code:`x0` iteratively solves the fixed point equation</span>
<span class="sd">                :code:`func(x) = x` initialising the iteration with :code:`x0` and</span>
<span class="sd">                returning an array corresponding to the solution if the iteration</span>
<span class="sd">                converges or raising a :py:exc:`mici.errors.ConvergenceError`</span>
<span class="sd">                otherwise. Defaults to :py:func:`mici.solvers.solve_fixed_point_direct`.</span>
<span class="sd">            fixed_point_solver_kwargs: Dictionary of any keyword arguments to</span>
<span class="sd">                :code:`fixed_point_solver`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span> <span class="o">=</span> <span class="n">reverse_check_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span> <span class="o">=</span> <span class="n">reverse_check_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver</span> <span class="o">=</span> <span class="n">fixed_point_solver</span>
        <span class="k">if</span> <span class="n">fixed_point_solver_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fixed_point_solver_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver_kwargs</span> <span class="o">=</span> <span class="n">fixed_point_solver_kwargs</span>

    <span class="k">def</span> <span class="nf">_solve_fixed_point</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fixed_point_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">ArrayLike</span><span class="p">],</span>
        <span class="n">x_init</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver</span><span class="p">(</span>
            <span class="n">fixed_point_func</span><span class="p">,</span>
            <span class="n">x_init</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_a_fwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">pos_mom_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">mom</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">fixed_point_func</span><span class="p">(</span><span class="n">pos_mom</span><span class="p">):</span>
            <span class="n">state</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">pos_mom</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pos_mom_init</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh_dmom</span><span class="p">(</span><span class="n">state</span><span class="p">),</span>
                    <span class="o">-</span><span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh_dpos</span><span class="p">(</span><span class="n">state</span><span class="p">),</span>
                <span class="p">],</span>
            <span class="p">)</span>

        <span class="n">state</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solve_fixed_point</span><span class="p">(</span><span class="n">fixed_point_func</span><span class="p">,</span> <span class="n">pos_mom_init</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_a_adj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">state_prev</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh_dmom</span><span class="p">(</span><span class="n">state_prev</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">-=</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh_dpos</span><span class="p">(</span><span class="n">state_prev</span><span class="p">)</span>
        <span class="n">state_back</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a_fwd</span><span class="p">(</span><span class="n">state_back</span><span class="p">,</span> <span class="o">-</span><span class="n">time_step</span><span class="p">)</span>
        <span class="n">rev_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">state_back</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">state_prev</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">state_back</span><span class="o">.</span><span class="n">mom</span> <span class="o">-</span> <span class="n">state_prev</span><span class="o">.</span><span class="n">mom</span><span class="p">],</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">rev_diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Non-reversible step. Distance between initial and forward-backward &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;integrated (pos, mom) pairs = </span><span class="si">{</span><span class="n">rev_diff</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">NonReversibleStepError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a_fwd</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a_adj</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConstrainedLeapfrogIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.ConstrainedLeapfrogIntegrator">[docs]</a><span class="k">class</span> <span class="nc">ConstrainedLeapfrogIntegrator</span><span class="p">(</span><span class="n">TractableFlowIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Leapfrog integrator for constrained Hamiltonian systems.</span>

<span class="sd">    The Hamiltonian function is assumed to be expressible as the sum of two components</span>
<span class="sd">    for which the corresponding (unconstrained) Hamiltonian flows can be exactly</span>
<span class="sd">    simulated. Specifically it is assumed that the Hamiltonian function `h` takes the</span>
<span class="sd">    form</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(q, p),</span>

<span class="sd">    where :math:`q` and :math:`p` are the position and momentum variables respectively,</span>
<span class="sd">    and :math:`h_1` and :math:`h_2` Hamiltonian component functions for which the exact</span>
<span class="sd">    flows, respectively :math:`\Phi_1` and :math:`\Phi_2`, can be computed.</span>

<span class="sd">    The system is assumed to be additionally subject to a set of holonomic constraints</span>
<span class="sd">    on the position component of the state i.e. that all valid states must satisfy</span>

<span class="sd">    .. math::</span>

<span class="sd">        c(q) = 0,</span>

<span class="sd">    for some differentiable and surjective vector constraint function :math:`c` and the</span>
<span class="sd">    set of positions satisfying the constraints implicitly defining a manifold the</span>
<span class="sd">    dynamics remain confined to.</span>

<span class="sd">    The constraints are enforced by introducing a set of Lagrange multipliers</span>
<span class="sd">    :math:`\lambda` of dimension equal to number of constraints, and defining a</span>
<span class="sd">    &#39;constrained&#39; Hamiltonian</span>

<span class="sd">    .. math::</span>

<span class="sd">        \bar{h}(q, p) = h_1(q) + h_2(q, p) + c(q)^T\lambda  ~\text{s.t.}~ c(q) = 0,</span>

<span class="sd">    with corresponding dynamics described by the system of differential algebraic</span>
<span class="sd">    equations</span>

<span class="sd">    .. math::</span>

<span class="sd">        \dot{q} = \nabla_2 h(q, p), \quad</span>
<span class="sd">        \dot{p} = -\nabla_1 h(q, p) - \partial c(q)^T\lambda, \quad</span>
<span class="sd">        c(q) = 0.</span>

<span class="sd">    The dynamics implicitly define a set of constraints on the momentum variables,</span>
<span class="sd">    differentiating the constraint equation with respect to time giving that</span>

<span class="sd">    .. math::</span>

<span class="sd">        \partial c(q) \nabla_2 h(q, p) = \partial c(q) \nabla_2 h_2(q, p) = 0.</span>

<span class="sd">    The set of momentum variables satisfying the above for given position variables is</span>
<span class="sd">    termed the cotangent space of the manifold (at a position), and the set of</span>
<span class="sd">    position-momentum pairs for which the position is on the constraint manifold and the</span>
<span class="sd">    momentum in the corresponding cotangent space is termed the cotangent bundle.</span>

<span class="sd">    To define a second-order symmetric integrator which exactly (up to floating point</span>
<span class="sd">    error) preserves these constraints, forming a symplectic map on the cotangent</span>
<span class="sd">    bundle, we follow the approach of Reich (1996).</span>

<span class="sd">    We first define a map :math:`\Pi` parametrised by a vector of Lagrange multipliers</span>
<span class="sd">    :math:`\lambda`</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Pi(\lambda)(q, p) = (q, p + \partial c(q)^T \lambda),</span>

<span class="sd">    with :math:`\lambda` allowed to be an implicitly defined function of :math:`q` and</span>
<span class="sd">    :math:`p`.</span>

<span class="sd">    We then define a map :math:`A` in terms of the :math:`h_1` flow map :math:`\Phi_1`</span>
<span class="sd">    as</span>

<span class="sd">    .. math::</span>

<span class="sd">        A(t) = \Pi(\lambda) \circ \Phi_1(t),</span>

<span class="sd">    with :math:`\lambda` implicitly defined such that for :math:`(q&#39;, p&#39;) = A(t)(q, p)`</span>
<span class="sd">    we have that :math:`\partial c(q&#39;) \nabla_2 h_2(q&#39;, p&#39;) = 0` for any initial state</span>
<span class="sd">    :math:`(q, p)` in the co-tangent bundle, with :math:`c(q&#39;) = 0` trivially satisfied</span>
<span class="sd">    as :math:`\Phi_1` is an identity map in the position:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Phi_1(t)(q, p) = (q, p - t \nabla h_1(q)).</span>

<span class="sd">    The map :math:`A(t)` therefore corresponds to taking an unconstrained step according</span>
<span class="sd">    to the :math:`h_1` component flow map :math:`\Phi_1(t)` and then projecting the</span>
<span class="sd">    resulting updated momentum back in to the co-tangent space. For the usual case in</span>
<span class="sd">    which :math:`h` includes only quadratic terms in the momentum :math:`p` such that</span>
<span class="sd">    :math:`\nabla_2 h(q, p)` is a linear function of :math:`p`, then :math:`\lambda`</span>
<span class="sd">    can be analytically solved for to give a closed-form expression for the projection</span>
<span class="sd">    into the co-tangent space.</span>

<span class="sd">    We also define a map :math:`B` in terms of the :math:`h_2` flow map :math:`\Phi_2`</span>
<span class="sd">    as</span>

<span class="sd">    .. math::</span>

<span class="sd">        B(t) = \Pi(\lambda&#39;) \circ \Phi_2(t) \circ \Pi(\lambda),</span>

<span class="sd">    such that for :math:`(q&#39;, p&#39;) = B(t)(q, p)`, :math:`\lambda` is implicitly defined</span>
<span class="sd">    such that :math:`c(q&#39;) = 0` and :math:`\lambda&#39;` is implicitly defined such that</span>
<span class="sd">    :math:`\partial c(q&#39;) \nabla_2 h(q&#39;, p&#39;) = 0`.</span>

<span class="sd">    This can be decomposed as first solving for :math:`\lambda` such that</span>

<span class="sd">    .. math::</span>

<span class="sd">        c((\Phi_2(t) \circ \Pi(\lambda)(q, p))_1)</span>
<span class="sd">        = c((\Phi_2(t)(q, p + \partial c(q)^T \lambda))_1) = 0,</span>

<span class="sd">    i.e. solving for the values of the Lagrange multipliers such that the position</span>
<span class="sd">    component of the output of :math:`\Phi_2(t) \circ \Pi(\lambda)` is on the manifold,</span>
<span class="sd">    with this typically a non-linear system of equations that will need to be solved</span>
<span class="sd">    iteratively e.g. using Newton&#39;s method. The momentum output of :math:`\Phi_2(t)</span>
<span class="sd">    \circ \Pi(\lambda)` is then projected in to the cotangent space to compute the final</span>
<span class="sd">    state pair, with this projection step as noted above typically having an analytic</span>
<span class="sd">    solution.</span>

<span class="sd">    For more details see Reich (1996) and section 7.5.1 in Leimkuhler and Reich (2004).</span>

<span class="sd">    The overall second-order integrator is then defined as the symmetric composition</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Psi(t) = A(t / 2) \circ B(t / N)^N \circ A(t / 2),</span>

<span class="sd">    where :math:`N` is a positive integer corresponding to the number of &#39;inner&#39;</span>
<span class="sd">    :math:`h_2` flow steps, following the &#39;geodesic integrator&#39; formulation proposed by</span>
<span class="sd">    Leimkuhler and Matthews (2016). The additional flexibility introduced by having</span>
<span class="sd">    the possibility of :math:`N &gt; 1` is particularly of use when evaluation of</span>
<span class="sd">    :math:`\Phi_1` is significantly more expensive than evaluation of :math:`\Phi_2`; in</span>
<span class="sd">    this case using :math:`N &gt; 1` can allow a larger time step :math:`t` to be used than</span>
<span class="sd">    may be otherwise possible due to the need to ensure the iterative solver used in</span>
<span class="sd">    :math:`B` does not diverge, with a smaller step size :math:`t / N` used for the</span>
<span class="sd">    steps involving the iterative solves with the (cheaper) :math:`\Phi_2` flow map</span>
<span class="sd">    and a larger step size :math:`t` used for the steps involving the (more expensive)</span>
<span class="sd">    :math:`\Phi_1` flow map.</span>

<span class="sd">    This integrator exactly preserves the constraints at all steps, such that if an</span>
<span class="sd">    initial position momentum pair :math:`(q, p)` are in the cotangent bundle, the</span>
<span class="sd">    corresponding pair after calling the :py:meth:`step` method of the integrator will</span>
<span class="sd">    also be in the cotangent bundle, *providing the iterative solver converges*.</span>

<span class="sd">    As the iterative solves may fail to converge, or may converge to one of multiple</span>
<span class="sd">    solutions, following the approach proposed by Zappa, Holmes-Cerfon and Goodman</span>
<span class="sd">    (2018), an explicit *reversibility check* is performed to ensure the overall</span>
<span class="sd">    integrator step is time-reversible; see also Lelievre, Rousset and Stoltz (2019) for</span>
<span class="sd">    an analysis of this approach specifically in the context of Hamiltonian Monte Carlo.</span>
<span class="sd">    If the reversibility check fails or the iterative solver fails to converge an</span>
<span class="sd">    appropriate error is raised (:py:exc:`mici.errors.NonReversibleStepError` and</span>
<span class="sd">    :py:exc:`mici.errors.ConvergenceError` respectively).</span>

<span class="sd">    References:</span>
<span class="sd">      1. Reich, S. (1996). Symplectic integration of constrained Hamiltonian systems by</span>
<span class="sd">         composition methods. SIAM journal on numerical analysis, 33(2), 475-491.</span>
<span class="sd">      2. Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).</span>
<span class="sd">         Cambridge University Press.</span>
<span class="sd">      3. Leimkuhler, B., &amp; Matthews, C. (2016). Efficient molecular dynamics using</span>
<span class="sd">         geodesic integration and solvent-solute splitting. Proceedings of the Royal</span>
<span class="sd">         Society A: Mathematical, Physical and Engineering Sciences, 472(2189),</span>
<span class="sd">         20160138.</span>
<span class="sd">      4. Zappa, E., Holmes-Cerfon, M., &amp; Goodman, J. (2018). Monte Carlo on manifolds:</span>
<span class="sd">         sampling densities and integrating functions. Communications on Pure and</span>
<span class="sd">         Applied Mathematics, 71(12), 2609-2647.</span>
<span class="sd">      5. Lelievre, T., Rousset, M., &amp; Stoltz, G. (2019). Hybrid Monte Carlo methods for</span>
<span class="sd">         sampling probability measures on submanifolds. Numerische Mathematik, 143,</span>
<span class="sd">         379-421.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">ConstrainedTractableFlowSystem</span><span class="p">,</span>
        <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_inner_step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">reverse_check_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2e-8</span><span class="p">,</span>
        <span class="n">reverse_check_norm</span><span class="p">:</span> <span class="n">NormFunction</span> <span class="o">=</span> <span class="n">maximum_norm</span><span class="p">,</span>
        <span class="n">projection_solver</span><span class="p">:</span> <span class="n">ProjectionSolver</span> <span class="o">=</span> <span class="n">solve_projection_onto_manifold_newton</span><span class="p">,</span>
        <span class="n">projection_solver_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the constrained dynamics of.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">            n_inner_step: Positive integer specifying number of &#39;inner&#39; constrained</span>
<span class="sd">                :code:`system.h2_flow` steps to take within each overall step. As the</span>
<span class="sd">                derivative :code:`system.dh1_dpos` is not evaluated during the</span>
<span class="sd">                :code:`system.h2_flow` steps, if this derivative is relatively expensive</span>
<span class="sd">                to compute compared to evaluating :code:`system.h2_flow` then compared</span>
<span class="sd">                to using :code:`n_inner_step = 1` (the default) for a given</span>
<span class="sd">                :code:`step_size` it can be more computationally efficient to use</span>
<span class="sd">                :code:`n_inner_step &gt; 1` in combination within a larger</span>
<span class="sd">                :code:`step_size`, thus reducing the number of :code:`system.dh1_dpos`</span>
<span class="sd">                evaluations to simulate forward a given time while still controlling the</span>
<span class="sd">                effective time step used for the constrained :code:`system.h2_flow`</span>
<span class="sd">                steps which involve solving a non-linear system of equations to retract</span>
<span class="sd">                the position component of the updated state back on to the manifold,</span>
<span class="sd">                with the iterative solver typically diverging if the</span>
<span class="sd">                time step used is too large.</span>
<span class="sd">            reverse_check_tol: Tolerance for check of reversibility of implicit</span>
<span class="sd">                sub-steps which involve iterative solving of a non-linear system of</span>
<span class="sd">                equations. The step is assumed to be reversible if sequentially applying</span>
<span class="sd">                the forward and adjoint updates to a state returns to a state with a</span>
<span class="sd">                position component within a distance (defined by the</span>
<span class="sd">                `reverse_check_norm` argument) of :code:`reverse_check_tol` of the</span>
<span class="sd">                original state position component. If this condition is not met a</span>
<span class="sd">                :py:exc:`mici.errors.NonReversibleStepError` exception is raised.</span>
<span class="sd">            reverse_check_norm: Norm function accepting a single one-dimensional array</span>
<span class="sd">                input and returning a non-negative floating point value defining the</span>
<span class="sd">                distance to use in the reversibility check. Defaults to</span>
<span class="sd">                :py:func:`mici.solvers.maximum_norm`.</span>
<span class="sd">            projection_solver: Function which given two states :code:`state` and</span>
<span class="sd">                :code:`state_prev`, floating point time step :code:`time_step` and a</span>
<span class="sd">                Hamiltonian system object :code:`system` solves the non-linear system of</span>
<span class="sd">                equations in :code:`λ`.</span>

<span class="sd">                .. code::</span>

<span class="sd">                    system.constr(</span>
<span class="sd">                        state.pos</span>
<span class="sd">                        + dh2_flow_pos_dmom @ system.jacob_constr(state_prev).T @ λ</span>
<span class="sd">                    ) == 0</span>

<span class="sd">                where :code:`dh2_flow_pos_dmom = system.dh2_flow_dmom(time_step)[0]` is</span>
<span class="sd">                the derivative of the action of the (linear) :code:`system.h2_flow` map</span>
<span class="sd">                on the state momentum component with respect to the position component.</span>
<span class="sd">                This is used to project the state position component back on to the</span>
<span class="sd">                manifold after an unconstrained :code:`system.h2_flow` update. If the</span>
<span class="sd">                solver fails to convege a :py:exc:`mici.errors.ConvergenceError`</span>
<span class="sd">                exception is raised.</span>
<span class="sd">            projection_solver_kwargs: Dictionary of any keyword arguments to</span>
<span class="sd">                :code:`projection_solver`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_inner_step</span> <span class="o">=</span> <span class="n">n_inner_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span> <span class="o">=</span> <span class="n">reverse_check_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span> <span class="o">=</span> <span class="n">reverse_check_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projection_solver</span> <span class="o">=</span> <span class="n">projection_solver</span>
        <span class="k">if</span> <span class="n">projection_solver_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">projection_solver_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projection_solver_kwargs</span> <span class="o">=</span> <span class="n">projection_solver_kwargs</span>

    <span class="k">def</span> <span class="nf">_h2_flow_retraction_onto_manifold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span>
        <span class="n">state_prev</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span>
        <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h2_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projection_solver</span><span class="p">(</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="n">state_prev</span><span class="p">,</span>
            <span class="n">time_step</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">projection_solver_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_project_onto_cotangent_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">):</span>
        <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">project_onto_cotangent_space</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">mom</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_project_onto_cotangent_space</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_b</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">time_step_inner</span> <span class="o">=</span> <span class="n">time_step</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inner_step</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inner_step</span><span class="p">):</span>
            <span class="n">state_prev</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h2_flow_retraction_onto_manifold</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state_prev</span><span class="p">,</span> <span class="n">time_step_inner</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inner_step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># If at last inner step pre-evaluate dh1_dpos before projecting</span>
                <span class="c1"># state on to cotangent space, with computed value being</span>
                <span class="c1"># cached. During projection the constraint Jacobian at new</span>
                <span class="c1"># position will be calculated however if we are going to make a</span>
                <span class="c1"># h1_flow step immediately after we will evaluate dh1_dpos</span>
                <span class="c1"># which may involve evaluating the gradient of the log</span>
                <span class="c1"># determinant of the Gram matrix, during which we will evaluate</span>
                <span class="c1"># the constraint Jacobian in the forward pass anyway.</span>
                <span class="c1"># Pre-evaluating here therefore saves one extra Jacobian</span>
                <span class="c1"># evaluation when the target density includes a Gram matrix log</span>
                <span class="c1"># determinant term (and will not add any cost if this is not</span>
                <span class="c1"># the case as dh1_dpos will still be cached and reused).</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh1_dpos</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_project_onto_cotangent_space</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">state_back</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h2_flow_retraction_onto_manifold</span><span class="p">(</span><span class="n">state_back</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">-</span><span class="n">time_step_inner</span><span class="p">)</span>
            <span class="n">rev_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span><span class="p">(</span><span class="n">state_back</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">state_prev</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rev_diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Non-reversible step. Distance between initial and &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;forward-backward integrated positions = </span><span class="si">{</span><span class="n">rev_diff</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">NonReversibleStepError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_b</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Matt Graham.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>