<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mici.integrators &mdash; Mici 0.2.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/mici-logo-rectangular.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mici.html">mici package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Mici</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mici.integrators</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mici.integrators</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Symplectic integrators for simulation of Hamiltonian dynamics.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span>
<span class="kn">from</span> <span class="nn">mici.errors</span> <span class="kn">import</span> <span class="n">NonReversibleStepError</span><span class="p">,</span> <span class="n">AdaptationError</span>
<span class="kn">from</span> <span class="nn">mici.solvers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">maximum_norm</span><span class="p">,</span>
    <span class="n">solve_fixed_point_direct</span><span class="p">,</span>
    <span class="n">solve_projection_onto_manifold_quasi_newton</span><span class="p">,</span>
    <span class="n">FixedPointSolver</span><span class="p">,</span>
    <span class="n">ProjectionSolver</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span>
    <span class="kn">from</span> <span class="nn">mici.states</span> <span class="kn">import</span> <span class="n">ChainState</span>
    <span class="kn">from</span> <span class="nn">mici.systems</span> <span class="kn">import</span> <span class="n">System</span><span class="p">,</span> <span class="n">TractableFlowSystem</span>
    <span class="kn">from</span> <span class="nn">mici.types</span> <span class="kn">import</span> <span class="n">NormFunction</span>


<div class="viewcode-block" id="Integrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.Integrator">[docs]</a><span class="k">class</span> <span class="nc">Integrator</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Base class for integrators for simulating Hamiltonian dynamics.</span>

<span class="sd">    For a Hamiltonian function :math:`h` with position variables :math:`q` and momentum</span>
<span class="sd">    variables :math:`p`, the canonical Hamiltonian dynamic is defined by the ordinary</span>
<span class="sd">    differential equation system</span>

<span class="sd">    .. math::</span>

<span class="sd">        \dot{q} = \nabla_2 h(q, p),  \qquad \dot{p} = -\nabla_1 h(q, p)</span>

<span class="sd">    with the flow map corresponding to the solution of the corresponding initial value</span>
<span class="sd">    problem a time-reversible and symplectic (and by consequence volume-preserving) map.</span>

<span class="sd">    Derived classes implement a :py:meth:`step` method which approximates the flow-map</span>
<span class="sd">    over some small time interval, while conserving the properties of being</span>
<span class="sd">    time-reversible and symplectic, with composition of this integrator step method</span>
<span class="sd">    allowing simulation of time-discretised trajectories of the Hamiltonian dynamics.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of.</span>
<span class="sd">            step_size: Integrator time step. If set to `None` it is assumed that a step</span>
<span class="sd">                size adapter will be used to set the step size before calling the `step`</span>
<span class="sd">                method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span> <span class="o">=</span> <span class="n">system</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span>

<div class="viewcode-block" id="Integrator.step"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.Integrator.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ChainState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a single integrator step from a supplied state.</span>

<span class="sd">        Args:</span>
<span class="sd">            state: System state to perform integrator step from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            New object corresponding to stepped state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AdaptationError</span><span class="p">(</span>
                <span class="s2">&quot;Integrator `step_size` is `None`. This value should only be used if a &quot;</span>
                <span class="s2">&quot;step size adapter is being used to set the step size.&quot;</span>
            <span class="p">)</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dir</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Implementation of single integrator step.</span>

<span class="sd">        Args:</span>
<span class="sd">            state: System state to perform integrator step from. Updated in place.</span>
<span class="sd">            time_step: Integrator time step. May be positive or negative.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="TractableFlowIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.TractableFlowIntegrator">[docs]</a><span class="k">class</span> <span class="nc">TractableFlowIntegrator</span><span class="p">(</span><span class="n">Integrator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for integrators for Hamiltonian systems with tractable component flows</span>

<span class="sd">    The Hamiltonian function is assumed to be expressible as the sum of two analytically</span>
<span class="sd">    tractable components for which the corresponding Hamiltonian flows can be exactly</span>
<span class="sd">    simulated. Specifically it is assumed that the Hamiltonian function :math:`h` takes</span>
<span class="sd">    the form</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(q, p)</span>

<span class="sd">    where :math:`q` and :math:`p` are the position and momentum variables respectively,</span>
<span class="sd">    and :math:`h_1` and :math:`h_2` are Hamiltonian component functions for which the</span>
<span class="sd">    exact flows can be computed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">TractableFlowSystem</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of with tractable</span>
<span class="sd">                Hamiltonian component flows.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="s2">&quot;h1_flow&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="s2">&quot;h2_flow&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> can only be used for systems with explicit `h1_flow` and&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; `h2_flow` Hamiltonian component flow maps. For systems in which only&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; `h1_flow` is available the `ImplicitLeapfrogIntegrator` class may be&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; used instead and for systems in which neither `h1_flow` or `h2_flow`&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; is available the `ImplicitMidpointIntegrator` class may be used.&quot;</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="LeapfrogIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.LeapfrogIntegrator">[docs]</a><span class="k">class</span> <span class="nc">LeapfrogIntegrator</span><span class="p">(</span><span class="n">TractableFlowIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Leapfrog integrator for Hamiltonian systems with tractable component flows.</span>

<span class="sd">    For separable Hamiltonians of the</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(p)</span>

<span class="sd">    where :math:`h_1` is the potential energy and :math:`h_2` is the kinetic energy,</span>
<span class="sd">    this integrator corresponds to the classic (position) Störmer-Verlet method.</span>

<span class="sd">    The integrator can also be applied to the more general Hamiltonian splitting</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(q, p)</span>

<span class="sd">    providing the flows for :math:`h_1` and :math:`h_2` are both tractable.</span>

<span class="sd">    For more details see Sections 2.6 and 4.2.2 in Leimkuhler and Reich (2004).</span>

<span class="sd">    References:</span>

<span class="sd">      1. Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).</span>
<span class="sd">         Cambridge University Press.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h2_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span></div>


<div class="viewcode-block" id="SymmetricCompositionIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.SymmetricCompositionIntegrator">[docs]</a><span class="k">class</span> <span class="nc">SymmetricCompositionIntegrator</span><span class="p">(</span><span class="n">TractableFlowIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Symmetric composition integrator for Hamiltonians with tractable component flows</span>

<span class="sd">    The Hamiltonian function is assumed to be expressible as the sum of two analytically</span>
<span class="sd">    tractable components for which the corresponding Hamiltonian flows can be exactly</span>
<span class="sd">    simulated. Specifically it is assumed that the Hamiltonian function :math:`h` takes</span>
<span class="sd">    the form</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(q, p)</span>

<span class="sd">    where :math:`q` and :math:`p` are the position and momentum variables respectively,</span>
<span class="sd">    and :math:`h_1` and :math:`h_2` are Hamiltonian component functions for which the</span>
<span class="sd">    exact flows, respectively :math:`\Phi_1` and :math:`\Phi_2`, can be computed. An</span>
<span class="sd">    alternating composition can then be formed as</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Psi(t) =</span>
<span class="sd">        A(a_S t) \circ B(b_S t) \circ \dots \circ A(a_1 t) \circ B(b_1 t) \circ A(a_0 t)</span>

<span class="sd">    where :math:`A = \Phi_1` and :math:`B = \Phi_2` or :math:`A = \Phi_2` and :math:`B =</span>
<span class="sd">    \Phi_1`, and :math:`(a_0,\dots, a_S)` and :math:`(b_1, \dots, b_S)` are a set of</span>
<span class="sd">    coefficients to be determined and :math:`S` is the number of stages in the</span>
<span class="sd">    composition.</span>

<span class="sd">    To ensure a consistency (i.e. the integrator is at least order one) we require that</span>

<span class="sd">    .. math::</span>

<span class="sd">        \sum_{s=0}^S a_s = \sum_{s=1}^S b_s = 1.</span>

<span class="sd">    For symmetric compositions we restrict that</span>

<span class="sd">    .. math::</span>

<span class="sd">        a_{S-m} = a_m, \quad b_{S+1-m} = b_s</span>

<span class="sd">    with symmetric consistent methods of at least order two.</span>

<span class="sd">    The combination of the symmetry and consistency requirements mean that a</span>
<span class="sd">    :math:`S`-stage symmetric composition method can be described by :math:`S - 1`</span>
<span class="sd">    &#39;free&#39; coefficients</span>

<span class="sd">    .. math::</span>

<span class="sd">        (a_0, b_1, a_1, \dots, a_K, b_K)</span>

<span class="sd">    with :math:`K = (S - 1) / 2` if :math:`S` is odd or</span>

<span class="sd">    .. math::</span>

<span class="sd">        (a_0, b_1, a_1, \dots, a_K)</span>

<span class="sd">    with :math:`K = (S - 2) / 2` if :math:`S` is even.</span>

<span class="sd">    The Störmer-Verlet &#39;leapfrog&#39; integrator is a special case corresponding to the</span>
<span class="sd">    unique (symmetric and consistent) 1-stage integrator.</span>

<span class="sd">    For more details see Section 6.2 in Leimkuhler and Reich (2004).</span>

<span class="sd">    References:</span>

<span class="sd">      1. Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).</span>
<span class="sd">         Cambridge University Press.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">TractableFlowSystem</span><span class="p">,</span>
        <span class="n">free_coefficients</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">initial_h1_flow_step</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of with tractable</span>
<span class="sd">                Hamiltonian component flows.</span>
<span class="sd">            free_coefficients: Sequence of :math:`S - 1` scalar values, where :math:`S`</span>
<span class="sd">                is the number of stages in the symmetric composition, specifying the</span>
<span class="sd">                free coefficients :math:`(a_0, b_1, a_1, \dots, a_K, b_K)` with :math:`K</span>
<span class="sd">                = (S - 1) / 2` if :math:`S` is odd or :math:`(a_0, b_1, a_1, \dots,</span>
<span class="sd">                a_K)` with :math:`k = (S - 2) / 2` if `S` is even.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">            initial_h1_flow_step: Whether the initial :math:`A` flow in the composition</span>
<span class="sd">                should correspond to the flow of the `h_1` Hamiltonian component</span>
<span class="sd">                (:code:`True`) or to the flow of the :math:`h_2` component</span>
<span class="sd">                (:code:`False`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_h1_flow_step</span> <span class="o">=</span> <span class="n">initial_h1_flow_step</span>
        <span class="n">n_free_coefficients</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_coefficients</span><span class="p">)</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">free_coefficients</span><span class="p">)</span>
        <span class="n">coefficients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="mf">0.5</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">free_coefficients</span><span class="p">[(</span><span class="n">n_free_coefficients</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">::</span> <span class="mi">2</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">coefficients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">free_coefficients</span><span class="p">[(</span><span class="n">n_free_coefficients</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">::</span> <span class="mi">2</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">=</span> <span class="n">coefficients</span> <span class="o">+</span> <span class="n">coefficients</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">flow_a</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span> <span class="k">if</span> <span class="n">initial_h1_flow_step</span> <span class="k">else</span> <span class="n">system</span><span class="o">.</span><span class="n">h2_flow</span>
        <span class="n">flow_b</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">h2_flow</span> <span class="k">if</span> <span class="n">initial_h1_flow_step</span> <span class="k">else</span> <span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flows</span> <span class="o">=</span> <span class="p">[</span><span class="n">flow_a</span><span class="p">,</span> <span class="n">flow_b</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_free_coefficients</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">flow_a</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">flow</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">):</span>
            <span class="n">flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">coefficient</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span></div>


<div class="viewcode-block" id="BCSSTwoStageIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.BCSSTwoStageIntegrator">[docs]</a><span class="k">class</span> <span class="nc">BCSSTwoStageIntegrator</span><span class="p">(</span><span class="n">SymmetricCompositionIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Two-stage symmetric composition integrator due to Blanes, Casas &amp; Sanz-Serna.</span>

<span class="sd">    Described in equation (6.4) in Blanes, Casas, Sanz-Serna (2014).</span>

<span class="sd">    References:</span>

<span class="sd">      1. Blanes, S., Casas, F., &amp; Sanz-Serna, J. M. (2014).</span>
<span class="sd">         Numerical integrators for the Hybrid Monte Carlo method.</span>
<span class="sd">         SIAM Journal on Scientific Computing, 36(4), A1556-A1580.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">TractableFlowSystem</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of with tractable</span>
<span class="sd">                Hamiltonian component flows.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a_0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="p">(</span><span class="n">a_0</span><span class="p">,),</span> <span class="n">step_size</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="BCSSThreeStageIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.BCSSThreeStageIntegrator">[docs]</a><span class="k">class</span> <span class="nc">BCSSThreeStageIntegrator</span><span class="p">(</span><span class="n">SymmetricCompositionIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Three-stage symmetric composition integrator due to Blanes, Casas &amp; Sanz-Serna.</span>

<span class="sd">    Described in equation (6.7) in Blanes, Casas, Sanz-Serna (2014).</span>

<span class="sd">    References:</span>

<span class="sd">      1. Blanes, S., Casas, F., &amp; Sanz-Serna, J. M. (2014).</span>
<span class="sd">         Numerical integrators for the Hybrid Monte Carlo method.</span>
<span class="sd">         SIAM Journal on Scientific Computing, 36(4), A1556-A1580.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">TractableFlowSystem</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of with tractable</span>
<span class="sd">                Hamiltonian component flows.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that a</span>
<span class="sd">                step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a_0</span> <span class="o">=</span> <span class="mf">0.11888010966548</span>
        <span class="n">b_1</span> <span class="o">=</span> <span class="mf">0.29619504261126</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="p">(</span><span class="n">a_0</span><span class="p">,</span> <span class="n">b_1</span><span class="p">),</span> <span class="n">step_size</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="BCSSFourStageIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.BCSSFourStageIntegrator">[docs]</a><span class="k">class</span> <span class="nc">BCSSFourStageIntegrator</span><span class="p">(</span><span class="n">SymmetricCompositionIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Four-stage symmetric composition integrator due to Blanes, Casas &amp; Sanz-Serna.</span>

<span class="sd">    Described in equation (6.8) in Blanes, Casas, Sanz-Serna (2014).</span>

<span class="sd">    References:</span>

<span class="sd">      1. Blanes, S., Casas, F., &amp; Sanz-Serna, J. M. (2014).</span>
<span class="sd">         Numerical integrators for the Hybrid Monte Carlo method.</span>
<span class="sd">         SIAM Journal on Scientific Computing, 36(4), A1556-A1580.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">TractableFlowSystem</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of with tractable</span>
<span class="sd">                Hamiltonian component flows.</span>
<span class="sd">            step_size: Integrator time step. If set to :code:`None` it is assumed that</span>
<span class="sd">                a step size adapter will be used to set the step size before calling the</span>
<span class="sd">                :py:meth:`step` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a_0</span> <span class="o">=</span> <span class="mf">0.071353913450279725904</span>
        <span class="n">b_1</span> <span class="o">=</span> <span class="mf">0.191667800000000000000</span>
        <span class="n">a_1</span> <span class="o">=</span> <span class="mf">0.268548791161230105820</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="p">(</span><span class="n">a_0</span><span class="p">,</span> <span class="n">b_1</span><span class="p">,</span> <span class="n">a_1</span><span class="p">),</span> <span class="n">step_size</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="ImplicitLeapfrogIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.ImplicitLeapfrogIntegrator">[docs]</a><span class="k">class</span> <span class="nc">ImplicitLeapfrogIntegrator</span><span class="p">(</span><span class="n">Integrator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implicit leapfrog integrator for Hamiltonians with a non-separable component.</span>

<span class="sd">    Also known as the generalised leapfrog method.</span>

<span class="sd">    The Hamiltonian function :math:`h` is assumed to take the form</span>

<span class="sd">    .. math::</span>

<span class="sd">        h(q, p) = h_1(q) + h_2(q, p)</span>

<span class="sd">    where :math:`q` and :math:`p` are the position and momentum variables respectively,</span>
<span class="sd">    :math:`h_1` is a Hamiltonian component function for which the exact flow can be</span>
<span class="sd">    computed and :math:`h_2` is a Hamiltonian component function of the position and</span>
<span class="sd">    momentum variables, which may be non-separable and for which exact simulation of the</span>
<span class="sd">    correspond Hamiltonian flow may not be possible.</span>

<span class="sd">    A pair of implicit component updates are used to approximate the flow due to the</span>
<span class="sd">    :math:`h_2` Hamiltonian component, with a fixed-point iteration used to solve the</span>
<span class="sd">    non-linear system of equations.</span>

<span class="sd">    The resulting implicit integrator is a symmetric second-order method corresponding</span>
<span class="sd">    to a symplectic partitioned Runge-Kutta method. See Section 6.3.2 in Leimkuhler and</span>
<span class="sd">    Reich (2004) for more details.</span>

<span class="sd">    References:</span>

<span class="sd">      1. Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).</span>
<span class="sd">         Cambridge University Press.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reverse_check_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2e-8</span><span class="p">,</span>
        <span class="n">reverse_check_norm</span><span class="p">:</span> <span class="n">NormFunction</span> <span class="o">=</span> <span class="n">maximum_norm</span><span class="p">,</span>
        <span class="n">fixed_point_solver</span><span class="p">:</span> <span class="n">FixedPointSolver</span> <span class="o">=</span> <span class="n">solve_fixed_point_direct</span><span class="p">,</span>
        <span class="n">fixed_point_solver_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of.</span>
<span class="sd">            step_size: Integrator time step. If set to `None` it is assumed that a step</span>
<span class="sd">                size adapter will be used to set the step size before calling the `step`</span>
<span class="sd">                method.</span>
<span class="sd">            reverse_check_tol: Tolerance for check of reversibility of implicit</span>
<span class="sd">                sub-steps which involve iterative solving of a non-linear system of</span>
<span class="sd">                equations. The step is assumed to be reversible if sequentially applying</span>
<span class="sd">                the forward and adjoint updates to a state returns to a state with a</span>
<span class="sd">                position component within a distance (defined by the</span>
<span class="sd">                `reverse_check_norm` argument) of `reverse_check_tol` of the original</span>
<span class="sd">                state position component. If this condition is not met a</span>
<span class="sd">                `mici.errors.NonReversibleStepError` exception is raised.</span>
<span class="sd">            reverse_check_norm: Norm function accepting a single one-dimensional array</span>
<span class="sd">                input and returning a non-negative floating point value defining the</span>
<span class="sd">                distance to use in the reversibility check. Defaults to</span>
<span class="sd">                `mici.solvers.maximum_norm`.</span>
<span class="sd">            fixed_point_solver:  Function which given a function `func` and initial</span>
<span class="sd">                guess `x0` iteratively solves the fixed point equation `func(x) = x`</span>
<span class="sd">                initialising the iteration with `x0` and returning an array</span>
<span class="sd">                corresponding to the solution if the iteration converges or raising a</span>
<span class="sd">                `mici.errors.ConvergenceError` otherwise. Defaults to</span>
<span class="sd">                `mici.solvers.solve_fixed_point_direct`.</span>
<span class="sd">            fixed_point_solver_kwargs: Dictionary of any keyword arguments to</span>
<span class="sd">                `fixed_point_solver`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span> <span class="o">=</span> <span class="n">reverse_check_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span> <span class="o">=</span> <span class="n">reverse_check_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver</span> <span class="o">=</span> <span class="n">fixed_point_solver</span>
        <span class="k">if</span> <span class="n">fixed_point_solver_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fixed_point_solver_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver_kwargs</span> <span class="o">=</span> <span class="n">fixed_point_solver_kwargs</span>

    <span class="k">def</span> <span class="nf">_solve_fixed_point</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fixed_point_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">ArrayLike</span><span class="p">],</span> <span class="n">x_init</span><span class="p">:</span> <span class="n">ArrayLike</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver</span><span class="p">(</span>
            <span class="n">fixed_point_func</span><span class="p">,</span> <span class="n">x_init</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver_kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_b_fwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">fixed_point_func</span><span class="p">(</span><span class="n">mom</span><span class="p">):</span>
            <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="n">mom</span>
            <span class="k">return</span> <span class="n">mom_init</span> <span class="o">-</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh2_dpos</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">mom_init</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mom</span>
        <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_fixed_point</span><span class="p">(</span><span class="n">fixed_point_func</span><span class="p">,</span> <span class="n">mom_init</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_b_adj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">mom_init</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mom</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">-=</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh2_dpos</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">state_back</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_b_fwd</span><span class="p">(</span><span class="n">state_back</span><span class="p">,</span> <span class="o">-</span><span class="n">time_step</span><span class="p">)</span>
        <span class="n">rev_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span><span class="p">(</span><span class="n">state_back</span><span class="o">.</span><span class="n">mom</span> <span class="o">-</span> <span class="n">mom_init</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rev_diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonReversibleStepError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Non-reversible step. Distance between initial and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;forward-backward integrated momentums = </span><span class="si">{</span><span class="n">rev_diff</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_c_fwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">pos_init</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh2_dmom</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">state_back</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_c_adj</span><span class="p">(</span><span class="n">state_back</span><span class="p">,</span> <span class="o">-</span><span class="n">time_step</span><span class="p">)</span>
        <span class="n">rev_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span><span class="p">(</span><span class="n">state_back</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">pos_init</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rev_diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonReversibleStepError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Non-reversible step. Distance between initial and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;forward-backward integrated positions = </span><span class="si">{</span><span class="n">rev_diff</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_c_adj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">fixed_point_func</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="n">state</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="k">return</span> <span class="n">pos_init</span> <span class="o">+</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh2_dmom</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">pos_init</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">state</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_fixed_point</span><span class="p">(</span><span class="n">fixed_point_func</span><span class="p">,</span> <span class="n">pos_init</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_b_fwd</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_c_fwd</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_c_adj</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_b_adj</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span></div>


<div class="viewcode-block" id="ImplicitMidpointIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.ImplicitMidpointIntegrator">[docs]</a><span class="k">class</span> <span class="nc">ImplicitMidpointIntegrator</span><span class="p">(</span><span class="n">Integrator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implicit midpoint integrator for general Hamiltonians.</span>

<span class="sd">    The Hamiltonian function may be a general (non-separable) function of both the</span>
<span class="sd">    position variables `q` and momentum variables `p`.</span>

<span class="sd">    The flow is approximated with the composition of an implicit Euler half-step with</span>
<span class="sd">    ane explicit Euler half-step.</span>

<span class="sd">    The resulting implicit integrator is a second-order method corresponding to a</span>
<span class="sd">    symplectic one-stage  Runge-Kutta method. See Sections 4.1 and 6.3.1 in Leimkuhler</span>
<span class="sd">    and Reich (2004) for more details.</span>

<span class="sd">    References:</span>

<span class="sd">    Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).</span>
<span class="sd">    Cambridge University Press.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reverse_check_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2e-8</span><span class="p">,</span>
        <span class="n">reverse_check_norm</span><span class="p">:</span> <span class="n">NormFunction</span> <span class="o">=</span> <span class="n">maximum_norm</span><span class="p">,</span>
        <span class="n">fixed_point_solver</span><span class="p">:</span> <span class="n">FixedPointSolver</span> <span class="o">=</span> <span class="n">solve_fixed_point_direct</span><span class="p">,</span>
        <span class="n">fixed_point_solver_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of.</span>
<span class="sd">            step_size: Integrator time step. If set to `None` it is assumed that a step</span>
<span class="sd">                size adapter will be used to set the step size before calling the `step`</span>
<span class="sd">                method.</span>
<span class="sd">            reverse_check_tol: Tolerance for check of reversibility of implicit</span>
<span class="sd">                sub-steps which involve iterative solving of a non-linear system of</span>
<span class="sd">                equations. The step is assumed to be reversible if sequentially applying</span>
<span class="sd">                the forward and adjoint updates to a state returns to a state with a</span>
<span class="sd">                position component within a distance (defined by the</span>
<span class="sd">                `reverse_check_norm` argument) of `reverse_check_tol` of the original</span>
<span class="sd">                state position component. If this condition is not met a</span>
<span class="sd">                `mici.errors.NonReversibleStepError` exception is raised.</span>
<span class="sd">            reverse_check_norm: Norm function accepting a single one-dimensional array</span>
<span class="sd">                input and returning a non-negative floating point value defining the</span>
<span class="sd">                distance to use in the reversibility check. Defaults to</span>
<span class="sd">                `mici.solvers.maximum_norm`.</span>
<span class="sd">            fixed_point_solver:  Function which given a function `func` and initial</span>
<span class="sd">                guess `x0` iteratively solves the fixed point equation `func(x) = x`</span>
<span class="sd">                initialising the iteration with `x0` and returning an array</span>
<span class="sd">                corresponding to the solution if the iteration converges or raising a</span>
<span class="sd">                `mici.errors.ConvergenceError` otherwise. Defaults to</span>
<span class="sd">                `mici.solvers.solve_fixed_point_direct`.</span>
<span class="sd">            fixed_point_solver_kwargs: Dictionary of any keyword arguments to</span>
<span class="sd">                `fixed_point_solver`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span> <span class="o">=</span> <span class="n">reverse_check_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span> <span class="o">=</span> <span class="n">maximum_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver</span> <span class="o">=</span> <span class="n">fixed_point_solver</span>
        <span class="k">if</span> <span class="n">fixed_point_solver_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fixed_point_solver_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver_kwargs</span> <span class="o">=</span> <span class="n">fixed_point_solver_kwargs</span>

    <span class="k">def</span> <span class="nf">_solve_fixed_point</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fixed_point_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">ArrayLike</span><span class="p">],</span> <span class="n">x_init</span><span class="p">:</span> <span class="n">ArrayLike</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver</span><span class="p">(</span>
            <span class="n">fixed_point_func</span><span class="p">,</span> <span class="n">x_init</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_point_solver_kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_a_fwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">pos_mom_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">mom</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">fixed_point_func</span><span class="p">(</span><span class="n">pos_mom</span><span class="p">):</span>
            <span class="n">state</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">pos_mom</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pos_mom_init</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh_dmom</span><span class="p">(</span><span class="n">state</span><span class="p">),</span>
                    <span class="o">-</span><span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh_dpos</span><span class="p">(</span><span class="n">state</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="n">state</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solve_fixed_point</span><span class="p">(</span><span class="n">fixed_point_func</span><span class="p">,</span> <span class="n">pos_mom_init</span><span class="p">),</span> <span class="mi">2</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_a_adj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">state_prev</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh_dmom</span><span class="p">(</span><span class="n">state_prev</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">-=</span> <span class="n">time_step</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh_dpos</span><span class="p">(</span><span class="n">state_prev</span><span class="p">)</span>
        <span class="n">state_back</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a_fwd</span><span class="p">(</span><span class="n">state_back</span><span class="p">,</span> <span class="o">-</span><span class="n">time_step</span><span class="p">)</span>
        <span class="n">rev_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">state_back</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">state_prev</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">state_back</span><span class="o">.</span><span class="n">mom</span> <span class="o">-</span> <span class="n">state_prev</span><span class="o">.</span><span class="n">mom</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">rev_diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonReversibleStepError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Non-reversible step. Distance between initial and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;forward-backward integrated (pos, mom) pairs = </span><span class="si">{</span><span class="n">rev_diff</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a_fwd</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a_adj</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConstrainedLeapfrogIntegrator"><a class="viewcode-back" href="../../mici.integrators.html#mici.integrators.ConstrainedLeapfrogIntegrator">[docs]</a><span class="k">class</span> <span class="nc">ConstrainedLeapfrogIntegrator</span><span class="p">(</span><span class="n">TractableFlowIntegrator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Leapfrog integrator for constrained Hamiltonian systems.</span>

<span class="sd">    The Hamiltonian function is assumed to be expressible as the sum of two components</span>
<span class="sd">    for which the corresponding (unconstrained) Hamiltonian flows can be exactly</span>
<span class="sd">    simulated. Specifically it is assumed that the Hamiltonian function `h` takes the</span>
<span class="sd">    form</span>

<span class="sd">        h(q, p) = h₁(q) + h₂(q, p)</span>

<span class="sd">    where `q` and `p` are the position and momentum variables respectively, and `h₁` and</span>
<span class="sd">    `h₂` Hamiltonian component functions for which the exact flows, respectively `Φ₁`</span>
<span class="sd">    and `Φ₂`, can be computed.</span>

<span class="sd">    The system is assumed to be additionally subject to a set of holonomic constraints</span>
<span class="sd">    on the position component of the state i.e. that all valid states must satisfy</span>

<span class="sd">        c(q) = 0</span>

<span class="sd">    for some differentiable and surjective vector constraint function `c` and the set of</span>
<span class="sd">    positions satisfying the constraints implicitly defining a manifold the dynamics</span>
<span class="sd">    remain confined to.</span>

<span class="sd">    The constraints are enforced by introducing a set of Lagrange multipliers `λ` of</span>
<span class="sd">    dimension equal to number of constraints, and defining a &#39;constrained&#39; Hamiltonian</span>

<span class="sd">        h̅(q, p) = h₁(q) + h₂(q, p) + c(q)ᵀλ  subject to c(q) = 0</span>

<span class="sd">    with corresponding dynamics described by the system of differential algebraic</span>
<span class="sd">    equations</span>

<span class="sd">        q̇ = ∇₂h(q, p),</span>
<span class="sd">        ṗ = -∇₁h(q, p) - ∂c(q)ᵀλ,</span>
<span class="sd">        c(q) = 0.</span>

<span class="sd">    The dynamics implicitly define a set of constraints on the momentum variables,</span>
<span class="sd">    differentiating the constraint equation with respect to time giving that</span>

<span class="sd">        ∂c(q) ∇₂h(q, p) = 0</span>

<span class="sd">    The set of momentum variables satisfying the above for given position variables is</span>
<span class="sd">    termed the cotangent space of the manifold (at a position), and the set of</span>
<span class="sd">    position-momentum pairs for which the position is on the constraint manifold and the</span>
<span class="sd">    momentum in the corresponding cotangent space is termed the cotangent bundle.</span>

<span class="sd">    To define a second-order symmetric integrator which exactly (up to floating point</span>
<span class="sd">    error) preserves these constraints, forming a symplectic map on the cotangent</span>
<span class="sd">    bundle, we follow the approach of Reich (1996).</span>

<span class="sd">    We first define a map `Π` parametrised by a vector of Lagrange multipliers `λ`</span>

<span class="sd">        Π(λ)(q, p) = (q, p + ∂c(q)ᵀλ)</span>

<span class="sd">    with `λ` allowed to be an implicitly defined function of `q` and `p`.</span>

<span class="sd">    We then define a map `Ψ₁` in terms of the `h₁` flow map `Φ₁` as</span>

<span class="sd">        Ψ₁(t) = Π(λ) ∘ Φ₁(t)</span>

<span class="sd">    with `λ` implicitly defined such that `(q&#39;, p&#39;) = Ψ₁(t)(q, p) ⟹ ∂c(q&#39;) p&#39; = 0` for</span>
<span class="sd">    any initial state `(q, p)` in the co-tangent bundle, with `c(q&#39;) = 0` trivially</span>
<span class="sd">    satisfied as `Φ₁` is an identity map in the position:</span>

<span class="sd">        Φ₁(t)(q, p) = (q, p - t ∇h₁(q))</span>

<span class="sd">    The map `Ψ₁(t)` therefore corresponds to taking an unconstrained step `Φ₁(t)` and</span>
<span class="sd">    then projecting the resulting momentum back in to the co-tangent space. For the</span>
<span class="sd">    usual case in which `h` includes only quadratic terms in the momentum `p` such that</span>
<span class="sd">    `∇₂h(q, p)` is a linear function of `p`, then `λ` can be analytically solved for</span>
<span class="sd">    to give a closed-form expression for the projection into the co-tangent space.</span>

<span class="sd">    We also define a map `Ψ₂` in terms of the `h₂` flow map `Φ₂` as</span>

<span class="sd">        Ψ₂(t) = Π(λ&#39;) ∘ Φ₂(t) ∘ Π(λ)</span>

<span class="sd">    such that for `(q&#39;, p&#39;) = Ψ₂(t)(q, p)`, `λ` is implicitly defined such that</span>
<span class="sd">    `c(q&#39;) = 0` and `λ&#39;` is implicitly defined such that `∂c(q&#39;) ∇₂h(q&#39;, p&#39;) = 0`.</span>

<span class="sd">    This can be decomposed as first solving for `λ` such that</span>

<span class="sd">        c((Φ₂(t) ∘ Π(λ)(q, p))₁) = 0</span>

<span class="sd">    i.e. solving for the values of the Lagrange multipliers such that the position</span>
<span class="sd">    component of the output of `Φ₂(t) ∘ Π(λ)` is on the manifold, with this typically</span>
<span class="sd">    a non-linear system of equations that will need to be solved iteratively e.g. using</span>
<span class="sd">    Newton&#39;s method. The momentum output of `Φ₂(t) ∘ Π(λ)` is then projected in to the</span>
<span class="sd">    cotangent space to compute the final state pair, with this projection step as noted</span>
<span class="sd">    above typically having an analytic solution.</span>

<span class="sd">    The overall second-order integrator is then defined as the symmetric composition</span>

<span class="sd">        Ψ(t) = Ψ₁(t / 2) ∘ Ψ₂(t / N)ᴺ ∘ Ψ₁(t / 2)</span>

<span class="sd">    where `N` is a positive integer corresponding to the number of &#39;inner&#39; `h₂` flow</span>
<span class="sd">    steps. This integrator exactly preserves the constraints at all steps, such that if</span>
<span class="sd">    an initial position momentum pair `(q, p)` are in the cotangent bundle, the</span>
<span class="sd">    corresponding pair after calling the `step` method of the integrator will also be in</span>
<span class="sd">    the cotangent bundle.</span>

<span class="sd">    For more details see Reich (1996) and section 7.5.1 in Leimkuhler and Reich (2004).</span>

<span class="sd">    References:</span>

<span class="sd">    Reich, S. (1996). Symplectic integration of constrained Hamiltonian systems by</span>
<span class="sd">    composition methods. SIAM journal on numerical analysis, 33(2), 475-491.</span>

<span class="sd">    Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).</span>
<span class="sd">    Cambridge University Press.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_inner_step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">reverse_check_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2e-8</span><span class="p">,</span>
        <span class="n">reverse_check_norm</span><span class="p">:</span> <span class="n">NormFunction</span> <span class="o">=</span> <span class="n">maximum_norm</span><span class="p">,</span>
        <span class="n">projection_solver</span><span class="p">:</span> <span class="n">ProjectionSolver</span> <span class="o">=</span> <span class="n">solve_projection_onto_manifold_quasi_newton</span><span class="p">,</span>
        <span class="n">projection_solver_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            system: Hamiltonian system to integrate the dynamics of.</span>
<span class="sd">            step_size: Integrator time step. If set to `None` it is assumed that a step</span>
<span class="sd">                size adapter will be used to set the step size before calling the `step`</span>
<span class="sd">                method.</span>
<span class="sd">            n_inner_step: Positive integer specifying number of &#39;inner&#39; constrained</span>
<span class="sd">                `system.h2_flow` steps to take within each overall step. As the</span>
<span class="sd">                derivative `system.dh1_dpos` is not evaluated during the</span>
<span class="sd">                `system.h2_flow` steps, if this derivative is relatively expensive to</span>
<span class="sd">                compute compared to evaluating `system.h2_flow` then compared to using</span>
<span class="sd">                `n_inner_step = 1` (the default) for a given `step_size` it can be more</span>
<span class="sd">                computationally efficient to use `n_inner_step &gt; 1` in combination</span>
<span class="sd">                within a larger `step_size`, thus reducing the number of</span>
<span class="sd">                `system.dh1_dpos` evaluations to simulate forward a given time while</span>
<span class="sd">                still controlling the effective time step used for the constrained</span>
<span class="sd">                `system.h2_flow` steps which involve solving a non-linear system of</span>
<span class="sd">                equations to retract the position component of the updated state back on</span>
<span class="sd">                to the manifold, with the iterative solver typically diverging if the</span>
<span class="sd">                time step used is too large.</span>
<span class="sd">            reverse_check_tol: Tolerance for check of reversibility of implicit</span>
<span class="sd">                sub-steps which involve iterative solving of a non-linear system of</span>
<span class="sd">                equations. The step is assumed to be reversible if sequentially applying</span>
<span class="sd">                the forward and adjoint updates to a state returns to a state with a</span>
<span class="sd">                position component within a distance (defined by the</span>
<span class="sd">                `reverse_check_norm` argument) of `reverse_check_tol` of the original</span>
<span class="sd">                state position component. If this condition is not met a</span>
<span class="sd">                `mici.errors.NonReversibleStepError` exception is raised.</span>
<span class="sd">            reverse_check_norm: Norm function accepting a single one-dimensional array</span>
<span class="sd">                input and returning a non-negative floating point value defining the</span>
<span class="sd">                distance to use in the reversibility check. Defaults to</span>
<span class="sd">                `mici.solvers.maximum_norm`.</span>
<span class="sd">            projection_solver: Function which given two states `state` and `state_prev`,</span>
<span class="sd">                floating point time step `time_step` and a Hamiltonian system object</span>
<span class="sd">                `system` solves the non-linear system of equations in `λ`</span>

<span class="sd">                    system.constr(</span>
<span class="sd">                        state.pos + dh2_flow_pos_dmom @</span>
<span class="sd">                            system.jacob_constr(state_prev).T @ λ) == 0</span>

<span class="sd">                where `dh2_flow_pos_dmom = system.dh2_flow_dmom(time_step)[0]` is the</span>
<span class="sd">                derivative of the action of the (linear) `system.h2_flow` map on the</span>
<span class="sd">                state momentum component with respect to the position component. This is</span>
<span class="sd">                used to project the state position component back on to the manifold</span>
<span class="sd">                after an unconstrained `system.h2_flow` update.</span>
<span class="sd">            projection_solver_kwargs: Dictionary of any keyword arguments to</span>
<span class="sd">                `projection_solver`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_inner_step</span> <span class="o">=</span> <span class="n">n_inner_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span> <span class="o">=</span> <span class="n">reverse_check_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span> <span class="o">=</span> <span class="n">reverse_check_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projection_solver</span> <span class="o">=</span> <span class="n">projection_solver</span>
        <span class="k">if</span> <span class="n">projection_solver_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">projection_solver_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projection_solver_kwargs</span> <span class="o">=</span> <span class="n">projection_solver_kwargs</span>

    <span class="k">def</span> <span class="nf">_h2_flow_retraction_onto_manifold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">state_prev</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h2_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projection_solver</span><span class="p">(</span>
            <span class="n">state</span><span class="p">,</span> <span class="n">state_prev</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">projection_solver_kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_project_onto_cotangent_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">):</span>
        <span class="n">state</span><span class="o">.</span><span class="n">mom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">project_onto_cotangent_space</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">mom</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">h1_flow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_project_onto_cotangent_space</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_b</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">time_step_inner</span> <span class="o">=</span> <span class="n">time_step</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inner_step</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inner_step</span><span class="p">):</span>
            <span class="n">state_prev</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h2_flow_retraction_onto_manifold</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state_prev</span><span class="p">,</span> <span class="n">time_step_inner</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inner_step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># If at last inner step pre-evaluate dh1_dpos before projecting</span>
                <span class="c1"># state on to cotangent space, with computed value being</span>
                <span class="c1"># cached. During projection the constraint Jacobian at new</span>
                <span class="c1"># position will be calculated however if we are going to make a</span>
                <span class="c1"># h1_flow step immediately after we will evaluate dh1_dpos</span>
                <span class="c1"># which may involve evaluating the gradient of the log</span>
                <span class="c1"># determinant of the Gram matrix, during which we will evaluate</span>
                <span class="c1"># the constraint Jacobian in the forward pass anyway.</span>
                <span class="c1"># Pre-evaluating here therefore saves one extra Jacobian</span>
                <span class="c1"># evaluation when the target density includes a Gram matrix log</span>
                <span class="c1"># determinant term (and will not add any cost if this is not</span>
                <span class="c1"># the case as dh1_dpos will still be cached and reused).</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">dh1_dpos</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_project_onto_cotangent_space</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">state_back</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h2_flow_retraction_onto_manifold</span><span class="p">(</span><span class="n">state_back</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">-</span><span class="n">time_step_inner</span><span class="p">)</span>
            <span class="n">rev_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_norm</span><span class="p">(</span><span class="n">state_back</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">state_prev</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rev_diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_check_tol</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NonReversibleStepError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Non-reversible step. Distance between initial and &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;forward-backward integrated positions = </span><span class="si">{</span><span class="n">rev_diff</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ChainState</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_b</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_a</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Matt Graham.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>