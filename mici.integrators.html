<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mici.integrators module &mdash; Mici 0.2.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="mici.interop module" href="mici.interop.html" />
    <link rel="prev" title="mici.errors module" href="mici.errors.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
              <img src="_static/mici-logo-rectangular.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="mici.html">mici package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="mici.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="mici.adapters.html">mici.adapters module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.autodiff.html">mici.autodiff module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.autograd_wrapper.html">mici.autograd_wrapper module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.errors.html">mici.errors module</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">mici.integrators module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mici.integrators.BCSSFourStageIntegrator"><code class="docutils literal notranslate"><span class="pre">BCSSFourStageIntegrator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mici.integrators.BCSSThreeStageIntegrator"><code class="docutils literal notranslate"><span class="pre">BCSSThreeStageIntegrator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mici.integrators.BCSSTwoStageIntegrator"><code class="docutils literal notranslate"><span class="pre">BCSSTwoStageIntegrator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mici.integrators.ConstrainedLeapfrogIntegrator"><code class="docutils literal notranslate"><span class="pre">ConstrainedLeapfrogIntegrator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mici.integrators.ImplicitLeapfrogIntegrator"><code class="docutils literal notranslate"><span class="pre">ImplicitLeapfrogIntegrator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mici.integrators.ImplicitMidpointIntegrator"><code class="docutils literal notranslate"><span class="pre">ImplicitMidpointIntegrator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mici.integrators.Integrator"><code class="docutils literal notranslate"><span class="pre">Integrator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mici.integrators.LeapfrogIntegrator"><code class="docutils literal notranslate"><span class="pre">LeapfrogIntegrator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mici.integrators.SymmetricCompositionIntegrator"><code class="docutils literal notranslate"><span class="pre">SymmetricCompositionIntegrator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mici.integrators.TractableFlowIntegrator"><code class="docutils literal notranslate"><span class="pre">TractableFlowIntegrator</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mici.interop.html">mici.interop module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.matrices.html">mici.matrices module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.progressbars.html">mici.progressbars module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.samplers.html">mici.samplers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.solvers.html">mici.solvers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.stagers.html">mici.stagers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.states.html">mici.states module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.systems.html">mici.systems module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.transitions.html">mici.transitions module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.types.html">mici.types module</a></li>
<li class="toctree-l3"><a class="reference internal" href="mici.utils.html">mici.utils module</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Mici</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="mici.html">mici package</a></li>
      <li class="breadcrumb-item active">mici.integrators module</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/mici.integrators.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-mici.integrators">
<span id="mici-integrators-module"></span><h1>mici.integrators module<a class="headerlink" href="#module-mici.integrators" title="Permalink to this heading"></a></h1>
<p>Symplectic integrators for simulation of Hamiltonian dynamics.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mici.integrators.BCSSFourStageIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mici.integrators.</span></span><span class="sig-name descname"><span class="pre">BCSSFourStageIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#BCSSFourStageIntegrator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.BCSSFourStageIntegrator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mici.integrators.SymmetricCompositionIntegrator" title="mici.integrators.SymmetricCompositionIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricCompositionIntegrator</span></code></a></p>
<p>Four-stage symmetric composition integrator due to Blanes, Casas &amp; Sanz-Serna.</p>
<p>Described in equation (6.8) in Blanes, Casas, Sanz-Serna (2014).</p>
<p>Corresponds to specific instance of <a class="reference internal" href="#mici.integrators.SymmetricCompositionIntegrator" title="mici.integrators.SymmetricCompositionIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricCompositionIntegrator</span></code></a> with
<span class="math notranslate nohighlight">\(S = 4\)</span> and free coefficients <span class="math notranslate nohighlight">\(a_0 = 0.071353913450279725904\)</span>,
<span class="math notranslate nohighlight">\(b_1 = 0.191667800000000000000\)</span> and <span class="math notranslate nohighlight">\(a_1 = 268548791161230105820\)</span>.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>Blanes, S., Casas, F., &amp; Sanz-Serna, J. M. (2014).
Numerical integrators for the Hybrid Monte Carlo method.
SIAM Journal on Scientific Computing, 36(4), A1556-A1580.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="mici.systems.html#mici.systems.TractableFlowSystem" title="mici.systems.TractableFlowSystem"><em>TractableFlowSystem</em></a>) – Hamiltonian system to integrate the dynamics of with tractable
Hamiltonian component flows.</p></li>
<li><p><strong>step_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Integrator time step. If set to <code class="code docutils literal notranslate"><span class="pre">None</span></code> it is assumed that
a step size adapter will be used to set the step size before calling the
<a class="reference internal" href="#mici.integrators.BCSSFourStageIntegrator.step" title="mici.integrators.BCSSFourStageIntegrator.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step()</span></code></a> method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mici.integrators.BCSSFourStageIntegrator.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mici.integrators.BCSSFourStageIntegrator.step" title="Permalink to this definition"></a></dt>
<dd><p>Perform a single integrator step from a supplied state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a>) – System state to perform integrator step from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New object corresponding to stepped state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mici.integrators.BCSSThreeStageIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mici.integrators.</span></span><span class="sig-name descname"><span class="pre">BCSSThreeStageIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#BCSSThreeStageIntegrator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.BCSSThreeStageIntegrator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mici.integrators.SymmetricCompositionIntegrator" title="mici.integrators.SymmetricCompositionIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricCompositionIntegrator</span></code></a></p>
<p>Three-stage symmetric composition integrator due to Blanes, Casas &amp; Sanz-Serna.</p>
<p>Described in equation (6.7) in Blanes, Casas, Sanz-Serna (2014).</p>
<p>Corresponds to specific instance of <a class="reference internal" href="#mici.integrators.SymmetricCompositionIntegrator" title="mici.integrators.SymmetricCompositionIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricCompositionIntegrator</span></code></a> with
<span class="math notranslate nohighlight">\(S = 3\)</span> and free coefficients <span class="math notranslate nohighlight">\(a_0 = 0.11888010966548\)</span> and
<span class="math notranslate nohighlight">\(b_1 = 0.29619504261126\)</span>.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>Blanes, S., Casas, F., &amp; Sanz-Serna, J. M. (2014).
Numerical integrators for the Hybrid Monte Carlo method.
SIAM Journal on Scientific Computing, 36(4), A1556-A1580.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="mici.systems.html#mici.systems.TractableFlowSystem" title="mici.systems.TractableFlowSystem"><em>TractableFlowSystem</em></a>) – Hamiltonian system to integrate the dynamics of with tractable
Hamiltonian component flows.</p></li>
<li><p><strong>step_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Integrator time step. If set to <code class="code docutils literal notranslate"><span class="pre">None</span></code> it is assumed that a
step size adapter will be used to set the step size before calling the
<a class="reference internal" href="#mici.integrators.BCSSThreeStageIntegrator.step" title="mici.integrators.BCSSThreeStageIntegrator.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step()</span></code></a> method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mici.integrators.BCSSThreeStageIntegrator.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mici.integrators.BCSSThreeStageIntegrator.step" title="Permalink to this definition"></a></dt>
<dd><p>Perform a single integrator step from a supplied state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a>) – System state to perform integrator step from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New object corresponding to stepped state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mici.integrators.BCSSTwoStageIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mici.integrators.</span></span><span class="sig-name descname"><span class="pre">BCSSTwoStageIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#BCSSTwoStageIntegrator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.BCSSTwoStageIntegrator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mici.integrators.SymmetricCompositionIntegrator" title="mici.integrators.SymmetricCompositionIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricCompositionIntegrator</span></code></a></p>
<p>Two-stage symmetric composition integrator due to Blanes, Casas &amp; Sanz-Serna.</p>
<p>Described in equation (6.4) in Blanes, Casas, Sanz-Serna (2014).</p>
<p>Corresponds to specific instance of <a class="reference internal" href="#mici.integrators.SymmetricCompositionIntegrator" title="mici.integrators.SymmetricCompositionIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricCompositionIntegrator</span></code></a> with
<span class="math notranslate nohighlight">\(S = 2\)</span> and free coefficient <span class="math notranslate nohighlight">\(a_0 = (3 - \sqrt{3}) / 6\)</span>.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>Blanes, S., Casas, F., &amp; Sanz-Serna, J. M. (2014).
Numerical integrators for the Hybrid Monte Carlo method.
SIAM Journal on Scientific Computing, 36(4), A1556-A1580.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="mici.systems.html#mici.systems.TractableFlowSystem" title="mici.systems.TractableFlowSystem"><em>TractableFlowSystem</em></a>) – Hamiltonian system to integrate the dynamics of with tractable
Hamiltonian component flows.</p></li>
<li><p><strong>step_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Integrator time step. If set to <code class="code docutils literal notranslate"><span class="pre">None</span></code> it is assumed that a
step size adapter will be used to set the step size before calling the
<a class="reference internal" href="#mici.integrators.BCSSTwoStageIntegrator.step" title="mici.integrators.BCSSTwoStageIntegrator.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step()</span></code></a> method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mici.integrators.BCSSTwoStageIntegrator.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mici.integrators.BCSSTwoStageIntegrator.step" title="Permalink to this definition"></a></dt>
<dd><p>Perform a single integrator step from a supplied state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a>) – System state to perform integrator step from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New object corresponding to stepped state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mici.integrators.ConstrainedLeapfrogIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mici.integrators.</span></span><span class="sig-name descname"><span class="pre">ConstrainedLeapfrogIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_inner_step=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_check_tol=2e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_check_norm=&lt;function</span> <span class="pre">maximum_norm&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection_solver=&lt;function</span> <span class="pre">solve_projection_onto_manifold_quasi_newton&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection_solver_kwargs=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#ConstrainedLeapfrogIntegrator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.ConstrainedLeapfrogIntegrator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mici.integrators.TractableFlowIntegrator" title="mici.integrators.TractableFlowIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractableFlowIntegrator</span></code></a></p>
<p>Leapfrog integrator for constrained Hamiltonian systems.</p>
<p>The Hamiltonian function is assumed to be expressible as the sum of two components
for which the corresponding (unconstrained) Hamiltonian flows can be exactly
simulated. Specifically it is assumed that the Hamiltonian function <cite>h</cite> takes the
form</p>
<div class="math notranslate nohighlight">
\[h(q, p) = h_1(q) + h_2(q, p)\]</div>
<p>where <span class="math notranslate nohighlight">\(q\)</span> and <span class="math notranslate nohighlight">\(p\)</span> are the position and momentum variables respectively,
and <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span> Hamiltonian component functions for which the exact
flows, respectively <span class="math notranslate nohighlight">\(\Phi_1\)</span> and <span class="math notranslate nohighlight">\(\Phi_2\)</span>, can be computed.</p>
<p>The system is assumed to be additionally subject to a set of holonomic constraints
on the position component of the state i.e. that all valid states must satisfy</p>
<div class="math notranslate nohighlight">
\[c(q) = 0,\]</div>
<p>for some differentiable and surjective vector constraint function <span class="math notranslate nohighlight">\(c\)</span> and the
set of positions satisfying the constraints implicitly defining a manifold the
dynamics remain confined to.</p>
<p>The constraints are enforced by introducing a set of Lagrange multipliers
<span class="math notranslate nohighlight">\(\lambda\)</span> of dimension equal to number of constraints, and defining a
‘constrained’ Hamiltonian</p>
<div class="math notranslate nohighlight">
\[\bar{h}(q, p) = h_1(q) + h_2(q, p) + c(q)^T\lambda  ~\text{s.t.}~ c(q) = 0,\]</div>
<p>with corresponding dynamics described by the system of differential algebraic
equations</p>
<div class="math notranslate nohighlight">
\[\dot{q} = \nabla_2 h(q, p), \quad
\dot{p} = -\nabla_1 h(q, p) - \partial c(q)^T\lambda, \quad
c(q) = 0.\]</div>
<p>The dynamics implicitly define a set of constraints on the momentum variables,
differentiating the constraint equation with respect to time giving that</p>
<div class="math notranslate nohighlight">
\[\partial c(q) \nabla_2 h(q, p) = \nabla_2 h_2(q, p) = 0.\]</div>
<p>The set of momentum variables satisfying the above for given position variables is
termed the cotangent space of the manifold (at a position), and the set of
position-momentum pairs for which the position is on the constraint manifold and the
momentum in the corresponding cotangent space is termed the cotangent bundle.</p>
<p>To define a second-order symmetric integrator which exactly (up to floating point
error) preserves these constraints, forming a symplectic map on the cotangent
bundle, we follow the approach of Reich (1996).</p>
<p>We first define a map <span class="math notranslate nohighlight">\(\Pi\)</span> parametrised by a vector of Lagrange multipliers
<span class="math notranslate nohighlight">\(\lambda\)</span></p>
<div class="math notranslate nohighlight">
\[\Pi(\lambda)(q, p) = (q, p + \partial c(q)^T \lambda),\]</div>
<p>with <span class="math notranslate nohighlight">\(\lambda\)</span> allowed to be an implicitly defined function of <span class="math notranslate nohighlight">\(q\)</span> and
<span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>We then define a map <span class="math notranslate nohighlight">\(A\)</span> in terms of the <span class="math notranslate nohighlight">\(h_1\)</span> flow map <span class="math notranslate nohighlight">\(\Phi_1\)</span>
as</p>
<div class="math notranslate nohighlight">
\[A(t) = \Pi(\lambda) \circ \Phi_1(t),\]</div>
<p>with <span class="math notranslate nohighlight">\(\lambda\)</span> implicitly defined such that for <span class="math notranslate nohighlight">\((q', p') = A(t)(q, p)\)</span>
we have that <span class="math notranslate nohighlight">\(\partial c(q') \nabla_2 h_2(q', p') = 0\)</span> for any initial state
<span class="math notranslate nohighlight">\((q, p)\)</span> in the co-tangent bundle, with <span class="math notranslate nohighlight">\(c(q') = 0\)</span> trivially satisfied
as <span class="math notranslate nohighlight">\(\Phi_1\)</span> is an identity map in the position:</p>
<div class="math notranslate nohighlight">
\[\Phi_1(t)(q, p) = (q, p - t \nabla h_1(q)).\]</div>
<p>The map <span class="math notranslate nohighlight">\(A(t)\)</span> therefore corresponds to taking an unconstrained step according
to the <span class="math notranslate nohighlight">\(h_1\)</span> component flow map <span class="math notranslate nohighlight">\(\Phi_1(t)\)</span> and then projecting the
resulting updated momentum back in to the co-tangent space. For the usual case in
which <span class="math notranslate nohighlight">\(h\)</span> includes only quadratic terms in the momentum <span class="math notranslate nohighlight">\(p\)</span> such that
<span class="math notranslate nohighlight">\(\nabla_2 h(q, p)\)</span> is a linear function of <span class="math notranslate nohighlight">\(p\)</span>, then <span class="math notranslate nohighlight">\(\lambda\)</span>
can be analytically solved for to give a closed-form expression for the projection
into the co-tangent space.</p>
<p>We also define a map <span class="math notranslate nohighlight">\(B\)</span> in terms of the <span class="math notranslate nohighlight">\(h_2\)</span> flow map <span class="math notranslate nohighlight">\(\Phi_2\)</span>
as</p>
<div class="math notranslate nohighlight">
\[B(t) = \Pi(\lambda') \circ \Phi_2(t) \circ \Pi(\lambda),\]</div>
<p>such that for <span class="math notranslate nohighlight">\((q', p') = B(t)(q, p)\)</span>, <span class="math notranslate nohighlight">\(\lambda\)</span> is implicitly defined
such that <span class="math notranslate nohighlight">\(c(q') = 0\)</span> and <span class="math notranslate nohighlight">\(\lambda'\)</span> is implicitly defined such that
<span class="math notranslate nohighlight">\(\partial c(q') \nabla_2 h(q', p') = 0\)</span>.</p>
<p>This can be decomposed as first solving for <span class="math notranslate nohighlight">\(\lambda\)</span> such that</p>
<div class="math notranslate nohighlight">
\[c((\Phi_2(t) \circ \Pi(\lambda)(q, p))_1) = 0\]</div>
<p>i.e. solving for the values of the Lagrange multipliers such that the position
component of the output of <span class="math notranslate nohighlight">\(\Phi_2(t) \circ \Pi(\lambda)\)</span> is on the manifold,
with this typically a non-linear system of equations that will need to be solved
iteratively e.g. using Newton’s method. The momentum output of <span class="math notranslate nohighlight">\(\Phi_2(t)
\circ \Pi(\lambda)\)</span> is then projected in to the cotangent space to compute the final
state pair, with this projection step as noted above typically having an analytic
solution.</p>
<p>The overall second-order integrator is then defined as the symmetric composition</p>
<div class="math notranslate nohighlight">
\[\Psi(t) = A(t / 2) \circ B(t / N)^N \circ A(t / 2),\]</div>
<p>where <span class="math notranslate nohighlight">\(N\)</span> is a positive integer corresponding to the number of ‘inner’
<span class="math notranslate nohighlight">\(h_2\)</span> flow steps. This integrator exactly preserves the constraints at all
steps, such that if an initial position momentum pair <span class="math notranslate nohighlight">\((q, p)\)</span> are in the
cotangent bundle, the corresponding pair after calling the <a class="reference internal" href="#mici.integrators.ConstrainedLeapfrogIntegrator.step" title="mici.integrators.ConstrainedLeapfrogIntegrator.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step()</span></code></a> method of
the integrator will also be in the cotangent bundle.</p>
<p>For more details see Reich (1996) and section 7.5.1 in Leimkuhler and Reich (2004).</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>Reich, S. (1996). Symplectic integration of constrained Hamiltonian systems by
composition methods. SIAM journal on numerical analysis, 33(2), 475-491.</p></li>
<li><p>Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).
Cambridge University Press.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="mici.systems.html#mici.systems.System" title="mici.systems.System"><em>System</em></a>) – Hamiltonian system to integrate the dynamics of.</p></li>
<li><p><strong>step_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Integrator time step. If set to <code class="code docutils literal notranslate"><span class="pre">None</span></code> it is assumed that a
step size adapter will be used to set the step size before calling the
<a class="reference internal" href="#mici.integrators.ConstrainedLeapfrogIntegrator.step" title="mici.integrators.ConstrainedLeapfrogIntegrator.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step()</span></code></a> method.</p></li>
<li><p><strong>n_inner_step</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Positive integer specifying number of ‘inner’ constrained
<code class="code docutils literal notranslate"><span class="pre">system.h2_flow</span></code> steps to take within each overall step. As the
derivative <code class="code docutils literal notranslate"><span class="pre">system.dh1_dpos</span></code> is not evaluated during the
<code class="code docutils literal notranslate"><span class="pre">system.h2_flow</span></code> steps, if this derivative is relatively expensive
to compute compared to evaluating <code class="code docutils literal notranslate"><span class="pre">system.h2_flow</span></code> then compared
to using <code class="code docutils literal notranslate"><span class="pre">n_inner_step</span> <span class="pre">=</span> <span class="pre">1</span></code> (the default) for a given
<code class="code docutils literal notranslate"><span class="pre">step_size</span></code> it can be more computationally efficient to use
<code class="code docutils literal notranslate"><span class="pre">n_inner_step</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> in combination within a larger
<code class="code docutils literal notranslate"><span class="pre">step_size</span></code>, thus reducing the number of <code class="code docutils literal notranslate"><span class="pre">system.dh1_dpos</span></code>
evaluations to simulate forward a given time while still controlling the
effective time step used for the constrained <code class="code docutils literal notranslate"><span class="pre">system.h2_flow</span></code>
steps which involve solving a non-linear system of equations to retract
the position component of the updated state back on to the manifold,
with the iterative solver typically diverging if the
time step used is too large.</p></li>
<li><p><strong>reverse_check_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Tolerance for check of reversibility of implicit
sub-steps which involve iterative solving of a non-linear system of
equations. The step is assumed to be reversible if sequentially applying
the forward and adjoint updates to a state returns to a state with a
position component within a distance (defined by the
<cite>reverse_check_norm</cite> argument) of <code class="code docutils literal notranslate"><span class="pre">reverse_check_tol</span></code> of the
original state position component. If this condition is not met a
<a class="reference internal" href="mici.errors.html#mici.errors.NonReversibleStepError" title="mici.errors.NonReversibleStepError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">mici.errors.NonReversibleStepError</span></code></a> exception is raised.</p></li>
<li><p><strong>reverse_check_norm</strong> (<em>NormFunction</em>) – Norm function accepting a single one-dimensional array
input and returning a non-negative floating point value defining the
distance to use in the reversibility check. Defaults to
<a class="reference internal" href="mici.solvers.html#mici.solvers.maximum_norm" title="mici.solvers.maximum_norm"><code class="xref py py-func docutils literal notranslate"><span class="pre">mici.solvers.maximum_norm()</span></code></a>.</p></li>
<li><p><strong>projection_solver</strong> (<a class="reference internal" href="mici.solvers.html#mici.solvers.ProjectionSolver" title="mici.solvers.ProjectionSolver"><em>ProjectionSolver</em></a>) – <p>Function which given two states <code class="code docutils literal notranslate"><span class="pre">state</span></code> and
<code class="code docutils literal notranslate"><span class="pre">state_prev</span></code>, floating point time step <code class="code docutils literal notranslate"><span class="pre">time_step</span></code> and a
Hamiltonian system object <code class="code docutils literal notranslate"><span class="pre">system</span></code> solves the non-linear system of
equations in <code class="code docutils literal notranslate"><span class="pre">λ</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">constr</span><span class="p">(</span>
    <span class="n">state</span><span class="o">.</span><span class="n">pos</span>
    <span class="o">+</span> <span class="n">dh2_flow_pos_dmom</span> <span class="o">@</span> <span class="n">system</span><span class="o">.</span><span class="n">jacob_constr</span><span class="p">(</span><span class="n">state_prev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">λ</span>
<span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">dh2_flow_pos_dmom</span> <span class="pre">=</span> <span class="pre">system.dh2_flow_dmom(time_step)[0]</span></code> is
the derivative of the action of the (linear) <code class="code docutils literal notranslate"><span class="pre">system.h2_flow</span></code> map
on the state momentum component with respect to the position component.
This is used to project the state position component back on to the
manifold after an unconstrained <code class="code docutils literal notranslate"><span class="pre">system.h2_flow</span></code> update.</p>
</p></li>
<li><p><strong>projection_solver_kwargs</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>Any</em><em>]</em><em>]</em>) – Dictionary of any keyword arguments to
<code class="code docutils literal notranslate"><span class="pre">projection_solver</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mici.integrators.ConstrainedLeapfrogIntegrator.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mici.integrators.ConstrainedLeapfrogIntegrator.step" title="Permalink to this definition"></a></dt>
<dd><p>Perform a single integrator step from a supplied state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a>) – System state to perform integrator step from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New object corresponding to stepped state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mici.integrators.ImplicitLeapfrogIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mici.integrators.</span></span><span class="sig-name descname"><span class="pre">ImplicitLeapfrogIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_check_tol=2e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_check_norm=&lt;function</span> <span class="pre">maximum_norm&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_point_solver=&lt;function</span> <span class="pre">solve_fixed_point_direct&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_point_solver_kwargs=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#ImplicitLeapfrogIntegrator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.ImplicitLeapfrogIntegrator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mici.integrators.Integrator" title="mici.integrators.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator</span></code></a></p>
<p>Implicit leapfrog integrator for Hamiltonians with a non-separable component.</p>
<p>Also known as the generalised leapfrog method.</p>
<p>The Hamiltonian function <span class="math notranslate nohighlight">\(h\)</span> is assumed to take the form</p>
<div class="math notranslate nohighlight">
\[h(q, p) = h_1(q) + h_2(q, p),\]</div>
<p>where <span class="math notranslate nohighlight">\(q\)</span> and <span class="math notranslate nohighlight">\(p\)</span> are the position and momentum variables respectively,
<span class="math notranslate nohighlight">\(h_1\)</span> is a Hamiltonian component function for which the exact flow can be
computed and <span class="math notranslate nohighlight">\(h_2\)</span> is a Hamiltonian component function of the position and
momentum variables, which may be non-separable and for which exact simulation of the
correspond Hamiltonian flow may not be possible.</p>
<p>The overall integrator step <span class="math notranslate nohighlight">\(\Psi\)</span> is defined by the symmetric composition</p>
<div class="math notranslate nohighlight">
\[\Psi(t) =
A(t/2) \circ B(t/2) \circ C(t/2) \circ C^*(t/2) \circ B^*(t/2) \circ A^*(t/2),\]</div>
<p>where the <em>adjoint</em> of a flow map <span class="math notranslate nohighlight">\(X\)</span> is defined such that <span class="math notranslate nohighlight">\(X^*(t) =
X(-t)^{-1}\)</span> and the component maps are defined by</p>
<div class="math notranslate nohighlight">
\[\begin{split}A(t)(q, p) = A^*(t)(q, p) = (q, p - t\nabla h_1(q)), \\
B(t)(q, p) = \lbrace (q, p') : p' = p - t \nabla_1 h_2(q, p') \rbrace, \\
B^*(t)(q, p) = (q, p - t \nabla_1 h_2(q, p)), \\
C(t)(q, p) = (q + t \nabla_2 h_2(q, p), p), \\
C^*(t)(q, p) = \lbrace (q', p) : q' = q + t \nabla_2 h_2(q', p) \rbrace.\end{split}\]</div>
<p>Fixed-point iterations are used to solve the non-linear systems of equations in the
implicit component updates (<span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C^*\)</span>).</p>
<p>The resulting implicit integrator is a symmetric second-order method corresponding
to a symplectic partitioned Runge-Kutta method. See Section 6.3.2 in Leimkuhler and
Reich (2004) for more details.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).
Cambridge University Press.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="mici.systems.html#mici.systems.System" title="mici.systems.System"><em>System</em></a>) – Hamiltonian system to integrate the dynamics of.</p></li>
<li><p><strong>step_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Integrator time step. If set to <code class="code docutils literal notranslate"><span class="pre">None</span></code> it is assumed that a
step size adapter will be used to set the step size before calling the
<a class="reference internal" href="#mici.integrators.ImplicitLeapfrogIntegrator.step" title="mici.integrators.ImplicitLeapfrogIntegrator.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step()</span></code></a> method.</p></li>
<li><p><strong>reverse_check_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Tolerance for check of reversibility of implicit
sub-steps which involve iterative solving of a non-linear system of
equations. The step is assumed to be reversible if sequentially applying
the forward and adjoint updates to a state returns to a state with a
position component within a distance (defined by the
<code class="code docutils literal notranslate"><span class="pre">reverse_check_norm</span></code> argument) of <code class="code docutils literal notranslate"><span class="pre">reverse_check_tol</span></code> of the
original state position component. If this condition is not met a
<a class="reference internal" href="mici.errors.html#mici.errors.NonReversibleStepError" title="mici.errors.NonReversibleStepError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">mici.errors.NonReversibleStepError</span></code></a> exception is raised.</p></li>
<li><p><strong>reverse_check_norm</strong> (<em>NormFunction</em>) – Norm function accepting a single one-dimensional array
input and returning a non-negative floating point value defining the
distance to use in the reversibility check. Defaults to
<a class="reference internal" href="mici.solvers.html#mici.solvers.maximum_norm" title="mici.solvers.maximum_norm"><code class="xref py py-func docutils literal notranslate"><span class="pre">mici.solvers.maximum_norm()</span></code></a>.</p></li>
<li><p><strong>fixed_point_solver</strong> (<a class="reference internal" href="mici.solvers.html#mici.solvers.FixedPointSolver" title="mici.solvers.FixedPointSolver"><em>FixedPointSolver</em></a>) – Function which given a function <code class="code docutils literal notranslate"><span class="pre">func</span></code> and
initial guess <code class="code docutils literal notranslate"><span class="pre">x0</span></code> iteratively solves the fixed point equation
<code class="code docutils literal notranslate"><span class="pre">func(x)</span> <span class="pre">=</span> <span class="pre">x</span></code> initialising the iteration with <code class="code docutils literal notranslate"><span class="pre">x0</span></code> and
returning an array corresponding to the solution if the iteration
converges or raising a <a class="reference internal" href="mici.errors.html#mici.errors.ConvergenceError" title="mici.errors.ConvergenceError"><code class="xref py py-class docutils literal notranslate"><span class="pre">mici.errors.ConvergenceError</span></code></a>
otherwise. Defaults to <a class="reference internal" href="mici.solvers.html#mici.solvers.solve_fixed_point_direct" title="mici.solvers.solve_fixed_point_direct"><code class="xref py py-exc docutils literal notranslate"><span class="pre">mici.solvers.solve_fixed_point_direct</span></code></a>.</p></li>
<li><p><strong>fixed_point_solver_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>Any</em><em>]</em>) – Dictionary of any keyword arguments to
<code class="code docutils literal notranslate"><span class="pre">fixed_point_solver</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mici.integrators.ImplicitLeapfrogIntegrator.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mici.integrators.ImplicitLeapfrogIntegrator.step" title="Permalink to this definition"></a></dt>
<dd><p>Perform a single integrator step from a supplied state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a>) – System state to perform integrator step from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New object corresponding to stepped state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mici.integrators.ImplicitMidpointIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mici.integrators.</span></span><span class="sig-name descname"><span class="pre">ImplicitMidpointIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_check_tol=2e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_check_norm=&lt;function</span> <span class="pre">maximum_norm&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_point_solver=&lt;function</span> <span class="pre">solve_fixed_point_direct&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_point_solver_kwargs=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#ImplicitMidpointIntegrator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.ImplicitMidpointIntegrator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mici.integrators.Integrator" title="mici.integrators.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator</span></code></a></p>
<p>Implicit midpoint integrator for general Hamiltonians.</p>
<p>The Hamiltonian function <span class="math notranslate nohighlight">\(h\)</span> may be a general (non-separable) function of both
the position variables <span class="math notranslate nohighlight">\(q\)</span> and momentum variables <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>The Hamiltonian flow <span class="math notranslate nohighlight">\(\Phi\)</span> is approximated with the symmetric composition
<span class="math notranslate nohighlight">\(\Psi(t) = A(t/2) \circ A^*(t/2)\)</span> of an implicit Euler half-step
<span class="math notranslate nohighlight">\(A(t/2)\)</span> with an explicit Euler half-step <span class="math notranslate nohighlight">\(A^*(t/2)\)</span> (which is adjoint
to the implicit Euler step, that is <span class="math notranslate nohighlight">\(A^*(t) = A(-t)^{-1}\)</span>), with the
components maps defined by</p>
<div class="math notranslate nohighlight">
\[\begin{split}A(t)(q, p) = \lbrace
(q', p') :
q' = q +  t \nabla_2 h(q', p'),
p' = p - t \nabla_1 h(q', p'))
\rbrace, \\
A^*(t)(q, p) = (q +  t \nabla_2 h(q, p), p - t \nabla_1 h(q, p)).\end{split}\]</div>
<p>A fixed-point iteration is used to solve the non-linear system of equations in the
implicit Euler step <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>The resulting implicit integrator is a second-order method corresponding to a
symplectic one-stage Runge-Kutta method. See Sections 4.1 and 6.3.1 in Leimkuhler
and Reich (2004) for more details.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).
Cambridge University Press.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="mici.systems.html#mici.systems.System" title="mici.systems.System"><em>System</em></a>) – Hamiltonian system to integrate the dynamics of.</p></li>
<li><p><strong>step_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Integrator time step. If set to <code class="code docutils literal notranslate"><span class="pre">None</span></code> it is assumed that a
step size adapter will be used to set the step size before calling the
<cite>step</cite> method.</p></li>
<li><p><strong>reverse_check_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Tolerance for check of reversibility of implicit Euler
steps which involve iterative solving of a non-linear system of
equations. The step is assumed to be reversible if sequentially applying
the forward and adjoint updates to a state returns to a state with a
position component within a distance (defined by the
<code class="code docutils literal notranslate"><span class="pre">reverse_check_norm</span></code> argument) of <code class="code docutils literal notranslate"><span class="pre">reverse_check_tol</span></code> of the
original state position component. If this condition is not met a
<a class="reference internal" href="mici.errors.html#mici.errors.NonReversibleStepError" title="mici.errors.NonReversibleStepError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">mici.errors.NonReversibleStepError</span></code></a> exception is raised.</p></li>
<li><p><strong>reverse_check_norm</strong> (<em>NormFunction</em>) – Norm function accepting a single one-dimensional array
input and returning a non-negative floating point value defining the
distance to use in the reversibility check. Defaults to
<a class="reference internal" href="mici.solvers.html#mici.solvers.maximum_norm" title="mici.solvers.maximum_norm"><code class="xref py py-func docutils literal notranslate"><span class="pre">mici.solvers.maximum_norm()</span></code></a>.</p></li>
<li><p><strong>fixed_point_solver</strong> (<a class="reference internal" href="mici.solvers.html#mici.solvers.FixedPointSolver" title="mici.solvers.FixedPointSolver"><em>FixedPointSolver</em></a>) – Function which given a function <code class="code docutils literal notranslate"><span class="pre">func</span></code> and initial
guess <code class="code docutils literal notranslate"><span class="pre">x0</span></code> iteratively solves the fixed point equation
<code class="code docutils literal notranslate"><span class="pre">func(x)</span> <span class="pre">=</span> <span class="pre">x</span></code> initialising the iteration with <code class="code docutils literal notranslate"><span class="pre">x0</span></code> and
returning an array corresponding to the solution if the iteration
converges or raising a <a class="reference internal" href="mici.errors.html#mici.errors.ConvergenceError" title="mici.errors.ConvergenceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">mici.errors.ConvergenceError</span></code></a>
otherwise. Defaults to <a class="reference internal" href="mici.solvers.html#mici.solvers.solve_fixed_point_direct" title="mici.solvers.solve_fixed_point_direct"><code class="xref py py-func docutils literal notranslate"><span class="pre">mici.solvers.solve_fixed_point_direct()</span></code></a>.</p></li>
<li><p><strong>fixed_point_solver_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>Any</em><em>]</em>) – Dictionary of any keyword arguments to
<code class="code docutils literal notranslate"><span class="pre">fixed_point_solver</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mici.integrators.ImplicitMidpointIntegrator.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mici.integrators.ImplicitMidpointIntegrator.step" title="Permalink to this definition"></a></dt>
<dd><p>Perform a single integrator step from a supplied state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a>) – System state to perform integrator step from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New object corresponding to stepped state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mici.integrators.Integrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mici.integrators.</span></span><span class="sig-name descname"><span class="pre">Integrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#Integrator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.Integrator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/abc.html#abc.ABC" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></a></p>
<p>Base class for integrators for simulating Hamiltonian dynamics.</p>
<p>For a Hamiltonian function <span class="math notranslate nohighlight">\(h\)</span> with position variables <span class="math notranslate nohighlight">\(q\)</span> and momentum
variables <span class="math notranslate nohighlight">\(p\)</span>, the canonical Hamiltonian dynamic is defined by the ordinary
differential equation system</p>
<div class="math notranslate nohighlight">
\[\dot{q} = \nabla_2 h(q, p),  \qquad \dot{p} = -\nabla_1 h(q, p),\]</div>
<p>with the flow map <span class="math notranslate nohighlight">\(\Phi\)</span> corresponding to the solution of the corresponding
initial value problem a time-reversible and symplectic (and by consequence
volume-preserving) map.</p>
<p>Derived classes implement a <a class="reference internal" href="#mici.integrators.Integrator.step" title="mici.integrators.Integrator.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step()</span></code></a> method which approximates the flow-map
with <span class="math notranslate nohighlight">\(\Psi(t) \approx \Phi(t)\)</span> over some small time interval <span class="math notranslate nohighlight">\(t\)</span>, while
conserving the properties of being time-reversible and symplectic, with composition
of this integrator step method allowing simulation of time-discretised trajectories
of the Hamiltonian dynamics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="mici.systems.html#mici.systems.System" title="mici.systems.System"><em>System</em></a>) – Hamiltonian system to integrate the dynamics of.</p></li>
<li><p><strong>step_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Integrator time step. If set to <code class="code docutils literal notranslate"><span class="pre">None</span></code> it is assumed that a
step size adapter will be used to set the step size before calling the
<cite>step</cite> method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mici.integrators.Integrator.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#Integrator.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.Integrator.step" title="Permalink to this definition"></a></dt>
<dd><p>Perform a single integrator step from a supplied state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a>) – System state to perform integrator step from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New object corresponding to stepped state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mici.integrators.LeapfrogIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mici.integrators.</span></span><span class="sig-name descname"><span class="pre">LeapfrogIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#LeapfrogIntegrator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.LeapfrogIntegrator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mici.integrators.TractableFlowIntegrator" title="mici.integrators.TractableFlowIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractableFlowIntegrator</span></code></a></p>
<p>Leapfrog integrator for Hamiltonian systems with tractable component flows.</p>
<p>The overall integrator step <span class="math notranslate nohighlight">\(\Psi\)</span> is defined by the symmetric composition</p>
<div class="math notranslate nohighlight">
\[\Psi(t) = \Phi_1(t/2) \circ \Phi_2(t) \circ \Phi_1(t/2)\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi_1\)</span> and <span class="math notranslate nohighlight">\(\Phi_2\)</span> are the exact flow maps associated with the
Hamiltonian components <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span> respectively.</p>
<p>For separable Hamiltonians of the</p>
<div class="math notranslate nohighlight">
\[h(q, p) = h_1(q) + h_2(p),\]</div>
<p>where <span class="math notranslate nohighlight">\(h_1\)</span> is the potential energy and <span class="math notranslate nohighlight">\(h_2\)</span> is the kinetic energy,
this integrator corresponds to the classic (position) Störmer-Verlet method.</p>
<p>The integrator can also be applied to the more general Hamiltonian splitting</p>
<div class="math notranslate nohighlight">
\[h(q, p) = h_1(q) + h_2(q, p),\]</div>
<p>providing the flows for <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span> are both tractable.</p>
<p>For more details see Sections 2.6 and 4.2.2 in Leimkuhler and Reich (2004).</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).
Cambridge University Press.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="mici.systems.html#mici.systems.TractableFlowSystem" title="mici.systems.TractableFlowSystem"><em>TractableFlowSystem</em></a>) – Hamiltonian system to integrate the dynamics of with tractable
Hamiltonian component flows.</p></li>
<li><p><strong>step_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Integrator time step. If set to <code class="code docutils literal notranslate"><span class="pre">None</span></code> it is assumed that a
step size adapter will be used to set the step size before calling the
<a class="reference internal" href="#mici.integrators.LeapfrogIntegrator.step" title="mici.integrators.LeapfrogIntegrator.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step()</span></code></a> method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mici.integrators.LeapfrogIntegrator.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mici.integrators.LeapfrogIntegrator.step" title="Permalink to this definition"></a></dt>
<dd><p>Perform a single integrator step from a supplied state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a>) – System state to perform integrator step from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New object corresponding to stepped state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mici.integrators.SymmetricCompositionIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mici.integrators.</span></span><span class="sig-name descname"><span class="pre">SymmetricCompositionIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">free_coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_h1_flow_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#SymmetricCompositionIntegrator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.SymmetricCompositionIntegrator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mici.integrators.TractableFlowIntegrator" title="mici.integrators.TractableFlowIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TractableFlowIntegrator</span></code></a></p>
<p>Symmetric composition integrator for Hamiltonians with tractable flows.</p>
<p>The Hamiltonian function is assumed to be expressible as the sum of two analytically
tractable components for which the corresponding Hamiltonian flows can be exactly
simulated. Specifically it is assumed that the Hamiltonian function <span class="math notranslate nohighlight">\(h\)</span> takes
the form</p>
<div class="math notranslate nohighlight">
\[h(q, p) = h_1(q) + h_2(q, p),\]</div>
<p>where <span class="math notranslate nohighlight">\(q\)</span> and <span class="math notranslate nohighlight">\(p\)</span> are the position and momentum variables respectively,
and <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span> are Hamiltonian component functions for which the
exact flows, respectively <span class="math notranslate nohighlight">\(\Phi_1\)</span> and <span class="math notranslate nohighlight">\(\Phi_2\)</span>, can be computed. An
alternating composition can then be formed as</p>
<div class="math notranslate nohighlight">
\[\Psi(t) = A(a_S t) \circ B(b_S t) \circ \dots \circ
          A(a_1 t) \circ B(b_1 t) \circ A(a_0 t),\]</div>
<p>where <span class="math notranslate nohighlight">\(A = \Phi_1\)</span> and <span class="math notranslate nohighlight">\(B = \Phi_2\)</span> or <span class="math notranslate nohighlight">\(A = \Phi_2\)</span> and <span class="math notranslate nohighlight">\(B =
\Phi_1\)</span>, and <span class="math notranslate nohighlight">\((a_0,\dots, a_S)\)</span> and <span class="math notranslate nohighlight">\((b_1, \dots, b_S)\)</span> are a set of
coefficients to be determined with <span class="math notranslate nohighlight">\(S \geq 1\)</span>.</p>
<p>To ensure a consistency (i.e. the integrator is at least order one) we require that</p>
<div class="math notranslate nohighlight">
\[\sum_{s=0}^S a_s = \sum_{s=1}^S b_s = 1.\]</div>
<p>For symmetric compositions we restrict that</p>
<div class="math notranslate nohighlight">
\[a_{S-m} = a_m, \quad b_{S+1-m} = b_m,\]</div>
<p>with symmetric consistent methods of at least order two.</p>
<p>The combination of the symmetry and consistency requirements mean that for each
<span class="math notranslate nohighlight">\(S \geq 1\)</span> a symmetric composition method can be described by <span class="math notranslate nohighlight">\(S - 1\)</span>
‘free’ coefficients <span class="math notranslate nohighlight">\((a_0, b_1, \dots, a_{K-1}, b_K)\)</span>  with
<span class="math notranslate nohighlight">\(K = (S - 1) / 2\)</span> if <span class="math notranslate nohighlight">\(S &gt; 1\)</span> is odd (with no free coefficients for
<span class="math notranslate nohighlight">\(S = 1\)</span> case) or <span class="math notranslate nohighlight">\((a_0, b_1, \dots, a_K)\)</span> with <span class="math notranslate nohighlight">\(K = (S - 2) / 2\)</span>
if <span class="math notranslate nohighlight">\(S &gt; 2\)</span> is even (with a single free coefficient <span class="math notranslate nohighlight">\(a_0\)</span> for <span class="math notranslate nohighlight">\(S=2\)</span>
case).</p>
<p>The Störmer-Verlet ‘leapfrog’ integrator is the special case corresponding to the
unique (symmetric and consistent) ‘1-stage’ (<span class="math notranslate nohighlight">\(S = 1\)</span>) integrator.</p>
<p>For more details see Section 6.2 in Leimkuhler and Reich (2004).</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>Leimkuhler, B., &amp; Reich, S. (2004). Simulating Hamiltonian Dynamics (No. 14).
Cambridge University Press.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="mici.systems.html#mici.systems.TractableFlowSystem" title="mici.systems.TractableFlowSystem"><em>TractableFlowSystem</em></a>) – Hamiltonian system to integrate the dynamics of with tractable
Hamiltonian component flows.</p></li>
<li><p><strong>free_coefficients</strong> (<em>Sequence</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Sequence of <span class="math notranslate nohighlight">\(S - 1\)</span> scalar values, where <span class="math notranslate nohighlight">\(S\)</span>
is the number of stages in the symmetric composition, specifying the
free coefficients <span class="math notranslate nohighlight">\((a_0, b_1, a_1, \dots, a_K, b_K)\)</span> with <span class="math notranslate nohighlight">\(K
= (S - 1) / 2\)</span> if <span class="math notranslate nohighlight">\(S\)</span> is odd or <span class="math notranslate nohighlight">\((a_0, b_1, a_1, \dots,
a_K)\)</span> with <span class="math notranslate nohighlight">\(k = (S - 2) / 2\)</span> if <cite>S</cite> is even.</p></li>
<li><p><strong>step_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Integrator time step. If set to <code class="code docutils literal notranslate"><span class="pre">None</span></code> it is assumed that a
step size adapter will be used to set the step size before calling the
<a class="reference internal" href="#mici.integrators.SymmetricCompositionIntegrator.step" title="mici.integrators.SymmetricCompositionIntegrator.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step()</span></code></a> method.</p></li>
<li><p><strong>initial_h1_flow_step</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – Whether the initial <span class="math notranslate nohighlight">\(A\)</span> flow in the composition
should correspond to the flow of the <cite>h_1</cite> Hamiltonian component
(<code class="code docutils literal notranslate"><span class="pre">True</span></code>) or to the flow of the <span class="math notranslate nohighlight">\(h_2\)</span> component
(<code class="code docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mici.integrators.SymmetricCompositionIntegrator.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mici.integrators.SymmetricCompositionIntegrator.step" title="Permalink to this definition"></a></dt>
<dd><p>Perform a single integrator step from a supplied state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a>) – System state to perform integrator step from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New object corresponding to stepped state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mici.integrators.TractableFlowIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mici.integrators.</span></span><span class="sig-name descname"><span class="pre">TractableFlowIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mici/integrators.html#TractableFlowIntegrator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mici.integrators.TractableFlowIntegrator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mici.integrators.Integrator" title="mici.integrators.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator</span></code></a></p>
<p>Base class for integrators for Hamiltonian systems with tractable flows.</p>
<p>The Hamiltonian function is assumed to be expressible as the sum of two analytically
tractable components for which the corresponding Hamiltonian flows can be exactly
simulated. Specifically it is assumed that the Hamiltonian function <span class="math notranslate nohighlight">\(h\)</span> takes
the form</p>
<div class="math notranslate nohighlight">
\[h(q, p) = h_1(q) + h_2(q, p),\]</div>
<p>where <span class="math notranslate nohighlight">\(q\)</span> and <span class="math notranslate nohighlight">\(p\)</span> are the position and momentum variables respectively,
and <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span> are Hamiltonian component functions for which the
exact flow maps, <span class="math notranslate nohighlight">\(\Phi_1\)</span> and <span class="math notranslate nohighlight">\(\Phi_2\)</span> respectively, can be computed
exactly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="mici.systems.html#mici.systems.TractableFlowSystem" title="mici.systems.TractableFlowSystem"><em>TractableFlowSystem</em></a>) – Hamiltonian system to integrate the dynamics of with tractable
Hamiltonian component flows.</p></li>
<li><p><strong>step_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>]</em>) – Integrator time step. If set to <code class="code docutils literal notranslate"><span class="pre">None</span></code> it is assumed that a
step size adapter will be used to set the step size before calling the
<a class="reference internal" href="#mici.integrators.TractableFlowIntegrator.step" title="mici.integrators.TractableFlowIntegrator.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step()</span></code></a> method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mici.integrators.TractableFlowIntegrator.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mici.integrators.TractableFlowIntegrator.step" title="Permalink to this definition"></a></dt>
<dd><p>Perform a single integrator step from a supplied state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state</strong> (<a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a>) – System state to perform integrator step from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New object corresponding to stepped state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mici.states.html#mici.states.ChainState" title="mici.states.ChainState"><em>ChainState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mici.errors.html" class="btn btn-neutral float-left" title="mici.errors module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="mici.interop.html" class="btn btn-neutral float-right" title="mici.interop module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Matt Graham.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>