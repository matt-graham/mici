<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2.dev0+g1b644f6.d20200507" />
<title>mici.systems API documentation</title>
<meta name="description" content="Hamiltonian systems encapsulating energy functions and their derivatives." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding-top:5px;padding-bottom:5px;padding-right:10px;padding-left:35px;text-indent:-25px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:1000px){#sidebar{width:600px;position:fixed;z-index:1;top:0;bottom:0;overflow-x:hidden;overflow-y:auto}#content{margin-left:600px;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}#footer{margin-left:600px}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="mici docs home" href="index.html">
<img width="400" src="../images/mici-logo-rectangular.svg" alt="mici">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Package</h3>
<ul>
<li><code><a title="mici" href="index.html">mici</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mici.systems.System" href="#mici.systems.System">System</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.System.neg_log_dens" href="#mici.systems.System.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.System.grad_neg_log_dens" href="#mici.systems.System.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.System.h1" href="#mici.systems.System.h1">h1</a></code></li>
<li><code><a title="mici.systems.System.dh1_dpos" href="#mici.systems.System.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.System.h1_flow" href="#mici.systems.System.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.System.h2" href="#mici.systems.System.h2">h2</a></code></li>
<li><code><a title="mici.systems.System.dh2_dmom" href="#mici.systems.System.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.System.h" href="#mici.systems.System.h">h</a></code></li>
<li><code><a title="mici.systems.System.dh_dpos" href="#mici.systems.System.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.System.dh_dmom" href="#mici.systems.System.dh_dmom">dh_dmom</a></code></li>
<li><code><a title="mici.systems.System.sample_momentum" href="#mici.systems.System.sample_momentum">sample_momentum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.EuclideanMetricSystem.h2" href="#mici.systems.EuclideanMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.dh2_dmom" href="#mici.systems.EuclideanMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.h2_flow" href="#mici.systems.EuclideanMetricSystem.h2_flow">h2_flow</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.dh2_flow_dmom" href="#mici.systems.EuclideanMetricSystem.dh2_flow_dmom">dh2_flow_dmom</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.sample_momentum" href="#mici.systems.EuclideanMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.neg_log_dens" href="#mici.systems.EuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.EuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.h1" href="#mici.systems.EuclideanMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.dh1_dpos" href="#mici.systems.EuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.h1_flow" href="#mici.systems.EuclideanMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.h" href="#mici.systems.EuclideanMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.dh_dpos" href="#mici.systems.EuclideanMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.dh_dmom" href="#mici.systems.EuclideanMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.h2" href="#mici.systems.GaussianEuclideanMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh2_dmom" href="#mici.systems.GaussianEuclideanMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh2_dpos" href="#mici.systems.GaussianEuclideanMetricSystem.dh2_dpos">dh2_dpos</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.h2_flow" href="#mici.systems.GaussianEuclideanMetricSystem.h2_flow">h2_flow</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh2_flow_dmom" href="#mici.systems.GaussianEuclideanMetricSystem.dh2_flow_dmom">dh2_flow_dmom</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.sample_momentum" href="#mici.systems.GaussianEuclideanMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.neg_log_dens" href="#mici.systems.GaussianEuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.GaussianEuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.h1" href="#mici.systems.GaussianEuclideanMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh1_dpos" href="#mici.systems.GaussianEuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.h1_flow" href="#mici.systems.GaussianEuclideanMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.h" href="#mici.systems.GaussianEuclideanMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh_dpos" href="#mici.systems.GaussianEuclideanMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh_dmom" href="#mici.systems.GaussianEuclideanMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.ConstrainedEuclideanMetricSystem" href="#mici.systems.ConstrainedEuclideanMetricSystem">ConstrainedEuclideanMetricSystem</a></code></h4>
<ul class="">
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.constr" href="#mici.systems.ConstrainedEuclideanMetricSystem.constr">constr</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.jacob_constr" href="#mici.systems.ConstrainedEuclideanMetricSystem.jacob_constr">jacob_constr</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.jacob_constr_inner_product" href="#mici.systems.ConstrainedEuclideanMetricSystem.jacob_constr_inner_product">jacob_constr_inner_product</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.gram" href="#mici.systems.ConstrainedEuclideanMetricSystem.gram">gram</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.inv_gram" href="#mici.systems.ConstrainedEuclideanMetricSystem.inv_gram">inv_gram</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.log_det_sqrt_gram" href="#mici.systems.ConstrainedEuclideanMetricSystem.log_det_sqrt_gram">log_det_sqrt_gram</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram" href="#mici.systems.ConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram">grad_log_det_sqrt_gram</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.h1" href="#mici.systems.ConstrainedEuclideanMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.dh1_dpos" href="#mici.systems.ConstrainedEuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.project_onto_cotangent_space" href="#mici.systems.ConstrainedEuclideanMetricSystem.project_onto_cotangent_space">project_onto_cotangent_space</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.sample_momentum" href="#mici.systems.ConstrainedEuclideanMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.h2_flow" href="#mici.systems.ConstrainedEuclideanMetricSystem.h2_flow">h2_flow</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.dh2_flow_dmom" href="#mici.systems.ConstrainedEuclideanMetricSystem.dh2_flow_dmom">dh2_flow_dmom</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.neg_log_dens" href="#mici.systems.ConstrainedEuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.ConstrainedEuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.h1_flow" href="#mici.systems.ConstrainedEuclideanMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.h" href="#mici.systems.ConstrainedEuclideanMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.dh_dpos" href="#mici.systems.ConstrainedEuclideanMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.dh_dmom" href="#mici.systems.ConstrainedEuclideanMetricSystem.dh_dmom">dh_dmom</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.h2" href="#mici.systems.ConstrainedEuclideanMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.ConstrainedEuclideanMetricSystem.dh2_dmom" href="#mici.systems.ConstrainedEuclideanMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem" href="#mici.systems.DenseConstrainedEuclideanMetricSystem">DenseConstrainedEuclideanMetricSystem</a></code></h4>
<ul class="">
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.mhp_constr" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.mhp_constr">mhp_constr</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.jacob_constr_inner_product" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.jacob_constr_inner_product">jacob_constr_inner_product</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram">grad_log_det_sqrt_gram</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.constr" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.constr">constr</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.jacob_constr" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.jacob_constr">jacob_constr</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.gram" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.gram">gram</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.inv_gram" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.inv_gram">inv_gram</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.log_det_sqrt_gram" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.log_det_sqrt_gram">log_det_sqrt_gram</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.h1" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.dh1_dpos" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.project_onto_cotangent_space" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.project_onto_cotangent_space">project_onto_cotangent_space</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.sample_momentum" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.h2_flow" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.h2_flow">h2_flow</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_flow_dmom" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_flow_dmom">dh2_flow_dmom</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.neg_log_dens" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.h1_flow" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.h" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dpos" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dmom" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dmom">dh_dmom</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.h2" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_dmom" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem">GaussianDenseConstrainedEuclideanMetricSystem</a></code></h4>
<ul class="">
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.jacob_constr_inner_product" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.jacob_constr_inner_product">jacob_constr_inner_product</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h2" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h2_flow" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h2_flow">h2_flow</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh2_flow_dmom" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh2_flow_dmom">dh2_flow_dmom</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.sample_momentum" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.neg_log_dens" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh1_dpos" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1_flow" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dpos" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dmom" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dmom">dh_dmom</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.constr" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.constr">constr</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.jacob_constr" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.jacob_constr">jacob_constr</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.gram" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.gram">gram</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.inv_gram" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.inv_gram">inv_gram</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.log_det_sqrt_gram" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.log_det_sqrt_gram">log_det_sqrt_gram</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.project_onto_cotangent_space" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.project_onto_cotangent_space">project_onto_cotangent_space</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh2_dmom" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram">grad_log_det_sqrt_gram</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.RiemannianMetricSystem.metric_func" href="#mici.systems.RiemannianMetricSystem.metric_func">metric_func</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.vjp_metric_func" href="#mici.systems.RiemannianMetricSystem.vjp_metric_func">vjp_metric_func</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.metric" href="#mici.systems.RiemannianMetricSystem.metric">metric</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.h" href="#mici.systems.RiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.h1" href="#mici.systems.RiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.dh1_dpos" href="#mici.systems.RiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.h2" href="#mici.systems.RiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.dh2_dpos" href="#mici.systems.RiemannianMetricSystem.dh2_dpos">dh2_dpos</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.dh2_dmom" href="#mici.systems.RiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.sample_momentum" href="#mici.systems.RiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.neg_log_dens" href="#mici.systems.RiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.RiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.h1_flow" href="#mici.systems.RiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.dh_dpos" href="#mici.systems.RiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.dh_dmom" href="#mici.systems.RiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.ScalarRiemannianMetricSystem" href="#mici.systems.ScalarRiemannianMetricSystem">ScalarRiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.metric" href="#mici.systems.ScalarRiemannianMetricSystem.metric">metric</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.metric_func" href="#mici.systems.ScalarRiemannianMetricSystem.metric_func">metric_func</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.vjp_metric_func" href="#mici.systems.ScalarRiemannianMetricSystem.vjp_metric_func">vjp_metric_func</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.h" href="#mici.systems.ScalarRiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.h1" href="#mici.systems.ScalarRiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.dh1_dpos" href="#mici.systems.ScalarRiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.h2" href="#mici.systems.ScalarRiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.dh2_dmom" href="#mici.systems.ScalarRiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.sample_momentum" href="#mici.systems.ScalarRiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.neg_log_dens" href="#mici.systems.ScalarRiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.ScalarRiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.h1_flow" href="#mici.systems.ScalarRiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.dh_dpos" href="#mici.systems.ScalarRiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.dh_dmom" href="#mici.systems.ScalarRiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.DiagonalRiemannianMetricSystem" href="#mici.systems.DiagonalRiemannianMetricSystem">DiagonalRiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.metric_func" href="#mici.systems.DiagonalRiemannianMetricSystem.metric_func">metric_func</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.vjp_metric_func" href="#mici.systems.DiagonalRiemannianMetricSystem.vjp_metric_func">vjp_metric_func</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.metric" href="#mici.systems.DiagonalRiemannianMetricSystem.metric">metric</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.h" href="#mici.systems.DiagonalRiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.h1" href="#mici.systems.DiagonalRiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.dh1_dpos" href="#mici.systems.DiagonalRiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.h2" href="#mici.systems.DiagonalRiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.dh2_dmom" href="#mici.systems.DiagonalRiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.sample_momentum" href="#mici.systems.DiagonalRiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.neg_log_dens" href="#mici.systems.DiagonalRiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.DiagonalRiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.h1_flow" href="#mici.systems.DiagonalRiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.dh_dpos" href="#mici.systems.DiagonalRiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.dh_dmom" href="#mici.systems.DiagonalRiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem">CholeskyFactoredRiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.metric_func" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.metric_func">metric_func</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.vjp_metric_func" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.vjp_metric_func">vjp_metric_func</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.metric" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.metric">metric</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.h" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.h1" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh1_dpos" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.h2" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh2_dmom" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.sample_momentum" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.neg_log_dens" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.h1_flow" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dpos" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dmom" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.DenseRiemannianMetricSystem" href="#mici.systems.DenseRiemannianMetricSystem">DenseRiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.metric_func" href="#mici.systems.DenseRiemannianMetricSystem.metric_func">metric_func</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.vjp_metric_func" href="#mici.systems.DenseRiemannianMetricSystem.vjp_metric_func">vjp_metric_func</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.metric" href="#mici.systems.DenseRiemannianMetricSystem.metric">metric</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.h" href="#mici.systems.DenseRiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.h1" href="#mici.systems.DenseRiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.dh1_dpos" href="#mici.systems.DenseRiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.h2" href="#mici.systems.DenseRiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.dh2_dmom" href="#mici.systems.DenseRiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.sample_momentum" href="#mici.systems.DenseRiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.neg_log_dens" href="#mici.systems.DenseRiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.DenseRiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.h1_flow" href="#mici.systems.DenseRiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.dh_dpos" href="#mici.systems.DenseRiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.dh_dmom" href="#mici.systems.DenseRiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.SoftAbsRiemannianMetricSystem" href="#mici.systems.SoftAbsRiemannianMetricSystem">SoftAbsRiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.metric_func" href="#mici.systems.SoftAbsRiemannianMetricSystem.metric_func">metric_func</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.vjp_metric_func" href="#mici.systems.SoftAbsRiemannianMetricSystem.vjp_metric_func">vjp_metric_func</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.hess_neg_log_dens" href="#mici.systems.SoftAbsRiemannianMetricSystem.hess_neg_log_dens">hess_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.mtp_neg_log_dens" href="#mici.systems.SoftAbsRiemannianMetricSystem.mtp_neg_log_dens">mtp_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.metric" href="#mici.systems.SoftAbsRiemannianMetricSystem.metric">metric</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.h" href="#mici.systems.SoftAbsRiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.h1" href="#mici.systems.SoftAbsRiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.dh1_dpos" href="#mici.systems.SoftAbsRiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.h2" href="#mici.systems.SoftAbsRiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.dh2_dmom" href="#mici.systems.SoftAbsRiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.sample_momentum" href="#mici.systems.SoftAbsRiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.neg_log_dens" href="#mici.systems.SoftAbsRiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.SoftAbsRiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.h1_flow" href="#mici.systems.SoftAbsRiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.dh_dpos" href="#mici.systems.SoftAbsRiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.dh_dmom" href="#mici.systems.SoftAbsRiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<article id="content">
<header>
<h1 class="title">Package <code>mici.systems</code></h1>
</header>
<section id="section-intro">
<p>Hamiltonian systems encapsulating energy functions and their derivatives.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L0-L1613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Hamiltonian systems encapsulating energy functions and their derivatives.&#34;&#34;&#34;

from abc import ABC, abstractmethod
import logging
import numpy as np
from mici.states import cache_in_state, multi_cache_in_state
from mici.matrices import (
    IdentityMatrix, PositiveScaledIdentityMatrix, PositiveDiagonalMatrix,
    DenseSquareMatrix, TriangularFactoredPositiveDefiniteMatrix,
    DenseDefiniteMatrix, DensePositiveDefiniteMatrix, DenseSymmetricMatrix,
    EigendecomposedSymmetricMatrix, SoftAbsRegularisedPositiveDefiniteMatrix)
from mici.autodiff import autodiff_fallback


class System(ABC):
    r&#34;&#34;&#34;Base class for Hamiltonian systems.

    The Hamiltonian function \(h\) is assumed to have the general form

    \[ h(q, p) = h_1(q) + h_2(q, p) \]

    where \(q\) and \(p\) are the position and momentum variables respectively,
    and \(h_1\) and \(h_2\) Hamiltonian component functions. The exact
    Hamiltonian flow for the \(h_1\) component can be always be computed as it
    depends only on the position variable however depending on the form of
    \(h_2\) the corresponding exact Hamiltonian flow may or may not be
    simulable.

    By default \(h_1\) is assumed to correspond to the negative logarithm of an
    unnormalised density on the position variables with respect to the Lebesgue
    measure, with the corresponding distribution on the position space being
    the target distribution it is wished to draw approximate samples from.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        self._neg_log_dens = neg_log_dens
        self._grad_neg_log_dens = autodiff_fallback(
            grad_neg_log_dens, neg_log_dens,
            &#39;grad_and_value&#39;, &#39;grad_neg_log_dens&#39;)

    @cache_in_state(&#39;pos&#39;)
    def neg_log_dens(self, state):
        &#34;&#34;&#34;Negative logarithm of unnormalised density of target distribution.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of computed negative log density.
        &#34;&#34;&#34;
        return self._neg_log_dens(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def grad_neg_log_dens(self, state):
        &#34;&#34;&#34;Derivative of negative log density with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `neg_log_dens(state)` derivative with respect to
                `state.pos`.
        &#34;&#34;&#34;
        return self._grad_neg_log_dens(state.pos)

    def h1(self, state):
        &#34;&#34;&#34;Hamiltonian component depending only on position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of `h1` Hamiltonian component.
        &#34;&#34;&#34;
        return self.neg_log_dens(state)

    def dh1_dpos(self, state):
        &#34;&#34;&#34;Derivative of `h1` Hamiltonian component with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of computed `h1` derivative.
        &#34;&#34;&#34;
        return self.grad_neg_log_dens(state)

    def h1_flow(self, state, dt):
        &#34;&#34;&#34;Apply exact flow map corresponding to `h1` Hamiltonian component.

        `state` argument is modified in place.

        Args:
            state (mici.states.ChainState): State to start flow at.
            dt (float): Time interval to simulate flow for.
        &#34;&#34;&#34;
        state.mom -= dt * self.dh1_dpos(state)

    @abstractmethod
    def h2(self, state):
        &#34;&#34;&#34;Hamiltonian component depending on momentum and optionally position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of `h2` Hamiltonian component.
        &#34;&#34;&#34;

    @abstractmethod
    def dh2_dmom(self, state):
        &#34;&#34;&#34;Derivative of `h2` Hamiltonian component with respect to momentum.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h2(state)` derivative with respect to `state.pos`.
        &#34;&#34;&#34;

    def h(self, state):
        &#34;&#34;&#34;Hamiltonian function for system.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of Hamiltonian.
        &#34;&#34;&#34;
        return self.h1(state) + self.h2(state)

    def dh_dpos(self, state):
        &#34;&#34;&#34;Derivative of Hamiltonian with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h(state)` derivative with respect to `state.pos`.
        &#34;&#34;&#34;
        if hasattr(self, &#39;dh2_dpos&#39;):
            return self.dh1_dpos(state) + self.dh2_dpos(state)
        else:
            return self.dh1_dpos(state)

    def dh_dmom(self, state):
        &#34;&#34;&#34;Derivative of Hamiltonian with respect to momentum.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h(state)` derivative with respect to `state.mom`.
        &#34;&#34;&#34;
        return self.dh2_dmom(state)

    @abstractmethod
    def sample_momentum(self, state, rng):
        &#34;&#34;&#34;
        Sample a momentum from its conditional distribution given a position.

        Args:
            state (mici.states.ChainState): State defining position to
               condition on.

        Returns:
            mom (array): Sampled momentum.
        &#34;&#34;&#34;


class EuclideanMetricSystem(System):
    r&#34;&#34;&#34;Hamiltonian system with a Euclidean metric on the position space.

    Here Euclidean metric is defined to mean a metric with a fixed positive
    definite matrix representation \(M\). The momentum variables are taken to
    be independent of the position variables and with a zero-mean Gaussian
    marginal distribution with covariance specified by \(M\), so that the
    \(h_2\) Hamiltonian component is

    \[ h_2(q, p) = \frac{1}{2} p^T M^{-1} p \]

    where \(q\) and \(p\) are the position and momentum variables respectively.

    The \(h_1\) Hamiltonian component function is

    \[ h_1(q) = \ell(q) \]

    where \(\ell(q)\) is the negative log (unnormalised) density of
    the target distribution with respect to the Lebesgue measure.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric (None or array or PositiveDefiniteMatrix): Matrix object
                corresponding to matrix representation of metric on position
                space and covariance of Gaussian marginal distribution on
                momentum vector. If `None` is passed (the default), the
                identity matrix will be used. If a 1D array is passed then this
                is assumed to specify a metric with positive diagonal matrix
                representation and the array the matrix diagonal. If a 2D array
                is passed then this is assumed to specify a metric with a dense
                positive definite matrix representation specified by the array.
                Otherwise if the value is a subclass of
                `mici.matrices.PositiveDefiniteMatrix` it is assumed to
                directly specify the metric matrix representation.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens, grad_neg_log_dens)
        if metric is None:
            self.metric = IdentityMatrix()
        elif isinstance(metric, np.ndarray):
            if metric.ndim == 1:
                self.metric = PositiveDiagonalMatrix(metric)
            elif metric.ndim == 2:
                self.metric = DensePositiveDefiniteMatrix(metric)
            else:
                raise ValueError(&#39;If NumPy ndarray value is used for `metric`&#39;
                                 &#39; must be either 1D (diagonal matrix) or 2D &#39;
                                 &#39;(dense positive definite matrix)&#39;)
        else:
            self.metric = metric

    @cache_in_state(&#39;mom&#39;)
    def h2(self, state):
        return 0.5 * state.mom @ (self.metric.inv @ state.mom)

    @cache_in_state(&#39;mom&#39;)
    def dh2_dmom(self, state):
        return self.metric.inv @ state.mom

    def h2_flow(self, state, dt):
        &#34;&#34;&#34;Apply exact flow map corresponding to `h2` Hamiltonian component.

        `state` argument is modified in place.

        Args:
            state (mici.states.ChainState): State to start flow at.
            dt (float): Time interval to simulate flow for.
        &#34;&#34;&#34;
        state.pos += dt * self.dh2_dmom(state)

    def dh2_flow_dmom(self, dt):
        &#34;&#34;&#34;Derivatives of `h2_flow` flow map with respect to input momentum.

        Args:
            dt (float): Time interval flow simulated for.

        Returns:
            dpos_dmom (mici.matrices.Matrix): Matrix representing derivative
                (Jacobian) of position output of `h2_flow` with respect to the
                value of the momentum component of the initial input state.
            dmom_dmom (mici.matrices.Matrix): Matrix representing derivative
                (Jacobian) of momentum output of `h2_flow` with respect to the
                value of the momentum component of the initial input state.
        &#34;&#34;&#34;
        return dt * self.metric.inv, IdentityMatrix(self.metric.shape[0])

    def sample_momentum(self, state, rng):
        return self.metric.sqrt @ rng.standard_normal(state.pos.shape)


class GaussianEuclideanMetricSystem(EuclideanMetricSystem):
    r&#34;&#34;&#34;Euclidean Hamiltonian system with a tractable Gaussian component.

    Here Euclidean metric is defined to mean a metric with a fixed positive
    definite matrix representation \(M\). The momentum variables are taken to
    be independent of the position variables and with a zero-mean Gaussian
    marginal distribution with covariance specified by \(M\).

    Additionally the target distribution on the position variables is assumed
    to be defined by an unnormalised density with respect to the standard
    Gaussian measure on the position space (with identity covariance and zero
    mean), with the Hamiltonian component \(h_1\) corresponding to the negative
    logarithm of this density rather than the density with respect to the
    Lebesgue measure on the position space, i.e.

    \[ h_1(q) = \ell(q) - \frac{1}{2} q^T q \]

    where \(q\) is the position and \(\ell(q)\) is the negative log
    (unnormalised) density of the target distribution with respect to the
    Lebesgue measure at \(q\). The Hamiltonian  component function \(h_2\) is
    then assumed to have the form

    \[ h_2(q, p) = \frac{1}{2} q^T q + \frac{1}{2} p^T M^{-1} p \]

    where \(p\) is the momentum. In this case the Hamiltonian flow due to the
    quadratic \(h_2\) component can be solved for analytically, allowing an
    integrator to be defined using this alternative splitting of the
    Hamiltonian [1].

    References:

      1. Shahbaba, B., Lan, S., Johnson, W.O. and Neal, R.M., 2014. Split
         Hamiltonian Monte Carlo. Statistics and Computing, 24(3), pp.339-349.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the standard Gaussian measure on the position space,
                with the corresponding distribution on the position space being
                the target distribution it is wished to draw approximate
                samples from.
            metric (None or array or PositiveDefiniteMatrix): Matrix object
                corresponding to matrix representation of metric on position
                space and covariance of Gaussian marginal distribution on
                momentum vector. If `None` is passed (the default), the
                identity matrix will be used. If a 1D array is passed then this
                is assumed to specify a metric with positive diagonal matrix
                representation and the array the matrix diagonal. If a 2D array
                is passed then this is assumed to specify a metric with a dense
                positive definite matrix representation specified by the array.
                Otherwise if the value is a subclass of
                `mici.matrices.PositiveDefiniteMatrix` it is assumed to
                directly specify the metric matrix representation.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens, metric, grad_neg_log_dens)

    def h2(self, state):
        return (0.5 * state.pos @ state.pos +
                0.5 * state.mom @ self.metric.inv @ state.mom)

    @cache_in_state(&#39;mom&#39;)
    def dh2_dmom(self, state):
        return self.metric.inv @ state.mom

    @cache_in_state(&#39;mom&#39;)
    def dh2_dpos(self, state):
        return state.pos

    def h2_flow(self, state, dt):
        omega = 1. / self.metric.eigval**0.5
        sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
        eigvec_T_pos = self.metric.eigvec.T @ state.pos
        eigvec_T_mom = self.metric.eigvec.T @ state.mom
        state.pos = self.metric.eigvec @ (
            cos_omega_dt * eigvec_T_pos +
            (sin_omega_dt * omega) * eigvec_T_mom)
        state.mom = self.metric.eigvec @ (
            cos_omega_dt * eigvec_T_mom -
            (sin_omega_dt / omega) * eigvec_T_pos)

    def dh2_flow_dmom(self, dt):
        omega = 1. / self.metric.eigval**0.5
        sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
        return (
            EigendecomposedSymmetricMatrix(
                self.metric.eigvec, sin_omega_dt * omega),
            EigendecomposedSymmetricMatrix(
                self.metric.eigvec, cos_omega_dt))


class ConstrainedEuclideanMetricSystem(EuclideanMetricSystem):
    r&#34;&#34;&#34;Base class for Euclidean Hamiltonian systems subject to constraints.

    The (constrained) position space is assumed to be a differentiable manifold
    embedded with a \(Q\)-dimensional ambient Euclidean space. The \(Q-C\)
    dimensional manifold \(\mathcal{M}\) is implicitly defined by an equation
    \(\mathcal{M} = \lbrace q \in \mathbb{R}^Q : c(q) = 0 \rbrace\) with
    \(c: \mathbb{R}^Q \to \mathbb{R}^C\) the *constraint function*.

    The ambient Euclidean space is assumed to be equipped with a metric with
    constant positive-definite matrix representation \(M\) which further
    specifies the covariance of the zero-mean Gaussian distribution
    \(\mathcal{N}(0, M)\) on the *unconstrained* momentum (co-)vector \(p\)
    with corresponding \(h_2\) Hamiltonian component defined as

    \[ h_2(q, p) = \frac{1}{2} p^T M^{-1} p. \]

    The time-derivative of the constraint equation implies a further set of
    constraints on the momentum \(q\) with \( \partial c(q) M^{-1} p = 0\)
    at all time points, corresponding to the momentum (velocity) being in the
    co-tangent space (tangent space) to the manifold.

    The target distribution is either assumed to be directly specified with
    unnormalised density \(\exp(-\ell(q))\) with respect to the Hausdorff
    measure on the manifold (under the metric induced from the ambient metric)
    with in this case the \(h_1\) Hamiltonian component then simply

    \[ h_1(q) = \ell(q), \]

    or alternatively it is assumed a prior distribution on the position \(q\)
    with density \(\exp(-\ell(q))\) with respect to the Lebesgue measure on
    the ambient space is specifed and the target distribution is the posterior
    distribution on \(q\) when conditioning on the event \(c(q) = 0\). The
    negative logarithm of the posterior distribution density with respect to
    the Hausdorff measure (and so \(h_1\) Hamiltonian component) is then

    \[
      h_1(q) =
      \ell(q) + \frac{1}{2} \log\left|\partial c(q)M^{-1}\partial c(q)^T\right|
    \]

    with an additional second *Gram matrix* determinant term to give the
    correct density with respect to the Hausdorff measure on the manifold.

    Due to the requirement to enforce the constraints on the position and
    momentum, a constraint-preserving numerical integrator needs to be used
    when simulating the Hamiltonian dynamic associated with the system, e.g.
    `mici.integrators.ConstrainedLeapfrogIntegrator`.

    References:

      1. Lelivre, T., Rousset, M. and Stoltz, G., 2019. Hybrid Monte Carlo
         methods for sampling probability measures on submanifolds. Numerische
         Mathematik, 143(2), pp.379-421.
      2. Graham, M.M. and Storkey, A.J., 2017. Asymptotically exact inference
         in differentiable generative models. Electronic Journal of Statistics,
         11(2), pp.5105-5164.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, constr, metric=None,
                 dens_wrt_hausdorff=True, grad_neg_log_dens=None,
                 jacob_constr=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the constrained position
                space with respect to the Hausdorff measure on the constraint
                manifold (if `dens_wrt_hausdorff == True`) or alternatively the
                negative logarithm of an unnormalised probability density on
                the unconstrained (ambient) position space with respect to the
                Lebesgue measure. In the former case the target distribution it
                is wished to draw approximate samples from is assumed to be
                directly specified by the density function on the manifold. In
                the latter case the density function is instead taken to
                specify a prior distribution on the ambient space with the
                target distribution then corresponding to the posterior
                distribution when conditioning on the (zero Lebesgue measure)
                event `constr(pos) == 0`. This target posterior distribution
                has support on the differentiable manifold implicitly defined
                by the constraint equation, with density with respect to the
                Hausdorff measure on the manifold corresponding to the ratio of
                the prior density (specified by `neg_log_dens`) and the
                square-root of the determinant of the Gram matrix defined by

                    gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T

                where `jacob_constr` is the Jacobian of the constraint function
                `constr` and `metric` is the matrix representation of the
                metric on the ambient space.
            constr (Callable[[array], array]): Function which given a position
                array return as a 1D array the value of the (vector-valued)
                constraint function, the zero level-set of which implicitly
                defines the manifold the dynamic is simulated on.
            metric (None or array or PositiveDefiniteMatrix): Matrix object
                corresponding to matrix representation of metric on
                *unconstrained* position space and covariance of Gaussian
                marginal distribution on *unconstrained* momentum vector. If
                `None` is passed (the default), the identity matrix will be
                used. If a 1D array is passed then this is assumed to specify a
                metric with positive diagonal matrix representation and the
                array the matrix diagonal. If a 2D array is passed then this is
                assumed to specify a metric with a dense positive definite
                matrix representation specified by the array. Otherwise if the
                value is a `mici.matrices.PositiveDefiniteMatrix` subclass it
                is assumed to directly specify the metric matrix
                representation.
            dens_wrt_hausdorff (bool): Whether the `neg_log_dens` function
                specifies the (negative logarithm) of the density of the target
                distribution with respect to the Hausdorff measure on the
                manifold directly (True) or alternatively the negative
                logarithm of a density of a prior distriubtion on the
                unconstrained (ambient) position space with respect to the
                Lebesgue measure, with the target distribution then
                corresponding to the posterior distribution when conditioning
                on the event `const(pos) == 0` (False). Note that in the former
                case the base Hausdorff measure on the manifold depends on the
                metric defined on the ambient space, with the Hausdorff measure
                being defined with respect to the metric induced on the
                manifold from this ambient metric.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the derivative (and value)
                of `neg_log_dens` automatically.
            jacob_constr (
                    None or Callable[[array], array or Tuple[array, array]]):
                Function which given a position array computes the Jacobian
                (matrix / 2D array of partial derivatives) of the output of the
                constraint function `c = constr(q)` with respect to the
                position array argument `q`, returning the computed Jacobian as
                a 2D array `jacob` with

                    jacob[i, j] = c[i] / q[j]

                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the Jacobian
                and the second being the value of `constr` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the Jacobian (and value) of
                `constr` automatically.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens=neg_log_dens, metric=metric,
                         grad_neg_log_dens=grad_neg_log_dens)
        self._constr = constr
        self.dens_wrt_hausdorff = dens_wrt_hausdorff
        self._jacob_constr = autodiff_fallback(
            jacob_constr, constr, &#39;jacobian_and_value&#39;, &#39;jacob_constr&#39;)

    @cache_in_state(&#39;pos&#39;)
    def constr(self, state):
        &#34;&#34;&#34;Constraint function at the current position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `constr(state.pos)` as 1D array.
        &#34;&#34;&#34;
        return self._constr(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;jacob_constr&#39;, &#39;constr&#39;])
    def jacob_constr(self, state):
        &#34;&#34;&#34;Jacobian of constraint function at the current position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of Jacobian of `constr(state.pos)` as 2D array.
        &#34;&#34;&#34;
        return self._jacob_constr(state.pos)

    @abstractmethod
    def jacob_constr_inner_product(
            self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
        &#34;&#34;&#34;Compute inner product of rows of constraint Jacobian matrices.

        Computes `jacob_constr_1 @ inner_product_matrix @ jacob_constr_2.T`
        potentially exploiting any structure / sparsity in `jacob_constr_1`,
        `jacob_constr_2` and `inner_product_matrix`.

        Args:
            jacob_constr_1 (Matrix): First constraint Jacobian in product.
            inner_product_matrix (Matrix): Positive-definite matrix defining
                inner-product between rows of two constraint Jacobians.
            jacob_constr_2 (None or Matrix): Second constraint Jacobian in
                product. Defaults to `jacob_constr_1` if set to `None`.

        Returns
            Matrix: Object corresponding to computed inner products of
               the constraint Jacobian rows.
        &#34;&#34;&#34;

    @cache_in_state(&#39;pos&#39;)
    def gram(self, state):
        &#34;&#34;&#34;Gram matrix at current position.

        The Gram matrix as a position `q` is defined as

            gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T

        where `jacob_constr` is the Jacobian of the constraint function
        `constr` and `metric` is the matrix representation of the metric on the
        ambient space.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            mici.matrice.PositiveDefiniteMatrix: Gram matrix as matrix object.
        &#34;&#34;&#34;
        return self.jacob_constr_inner_product(
            self.jacob_constr(state), self.metric.inv)

    def inv_gram(self, state):
        &#34;&#34;&#34;Inverse of Gram matrix at current position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            mici.matrices.PositiveDefiniteMatrix: Inverse of Gram matrix as
                matrix object.
        &#34;&#34;&#34;
        return self.gram(state).inv

    def log_det_sqrt_gram(self, state):
        &#34;&#34;&#34;Value of (half of) log-determinant of Gram matrix.&#34;&#34;&#34;
        return 0.5 * self.gram(state).log_abs_det

    @abstractmethod
    def grad_log_det_sqrt_gram(self, state):
        &#34;&#34;&#34;Derivative of (half of) log-determinant of Gram matrix wrt position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `log_det_sqrt_gram(state)` derivative with respect
                to `state.pos`.
        &#34;&#34;&#34;

    def h1(self, state):
        if self.dens_wrt_hausdorff:
            return self.neg_log_dens(state)
        else:
            return self.neg_log_dens(state) + self.log_det_sqrt_gram(state)

    def dh1_dpos(self, state):
        if self.dens_wrt_hausdorff:
            return self.grad_neg_log_dens(state)
        else:
            return (self.grad_neg_log_dens(state) +
                    self.grad_log_det_sqrt_gram(state))

    def project_onto_cotangent_space(self, mom, state):
        &#34;&#34;&#34;Project a momentum on to the co-tangent space at a position.

        Args:
            mom (array): Momentum (co-)vector as 1D array to project on to
                co-tangent space.
            state (mici.states.ChainState): State definining position on the
                manifold to project in to the co-tangent space of.

        Returns:
            array: Projected momentum in the co-tangent space at `state.pos`.
        &#34;&#34;&#34;
        # Use parenthesis to force right-to-left evaluation to avoid
        # matrix-matrix products
        mom -= (self.jacob_constr(state).T @ (
                    self.inv_gram(state) @ (
                        self.jacob_constr(state) @ (self.metric.inv @ mom))))
        return mom

    def sample_momentum(self, state, rng):
        mom = super().sample_momentum(state, rng)
        mom = self.project_onto_cotangent_space(mom, state)
        return mom


class DenseConstrainedEuclideanMetricSystem(ConstrainedEuclideanMetricSystem):
    r&#34;&#34;&#34;Euclidean Hamiltonian system subject to a dense set of constraints.

    See `ConstrainedEuclideanMetricSystem` for more details about constrained
    systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, constr, metric=None,
                 dens_wrt_hausdorff=True, grad_neg_log_dens=None,
                 jacob_constr=None, mhp_constr=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the constrained position
                space with respect to the Hausdorff measure on the constraint
                manifold (if `dens_wrt_hausdorff == True`) or alternatively the
                negative logarithm of an unnormalised probability density on
                the unconstrained (ambient) position space with respect to the
                Lebesgue measure. In the former case the target distribution it
                is wished to draw approximate samples from is assumed to be
                directly specified by the density function on the manifold. In
                the latter case the density function is instead taken to
                specify a prior distribution on the ambient space with the
                target distribution then corresponding to the posterior
                distribution when conditioning on the (zero Lebesgue measure)
                event `constr(pos) == 0`. This target posterior distribution
                has support on the differentiable manifold implicitly defined
                by the constraint equation, with density with respect to the
                Hausdorff measure on the manifold corresponding to the ratio of
                the prior density (specified by `neg_log_dens`) and the
                square-root of the determinant of the Gram matrix defined by

                    gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T

                where `jacob_constr` is the Jacobian of the constraint function
                `constr` and `metric` is the matrix representation of the
                metric on the ambient space.
            constr (Callable[[array], array]): Function which given a position
                array return as a 1D array the value of the (vector-valued)
                constraint function, the zero level-set of which implicitly
                defines the manifold the dynamic is simulated on.
            metric (None or array or PositiveDefiniteMatrix): Matrix object
                corresponding to matrix representation of metric on
                *unconstrained* position space and covariance of Gaussian
                marginal distribution on *unconstrained* momentum vector. If
                `None` is passed (the default), the identity matrix will be
                used. If a 1D array is passed then this is assumed to specify a
                metric with positive diagonal matrix representation and the
                array the matrix diagonal. If a 2D array is passed then this is
                assumed to specify a metric with a dense positive definite
                matrix representation specified by the array. Otherwise if the
                value is a `mici.matrices.PositiveDefiniteMatrix` subclass it
                is assumed to directly specify the metric matrix
                representation.
            dens_wrt_hausdorff (bool): Whether the `neg_log_dens` function
                specifies the (negative logarithm) of the density of the target
                distribution with respect to the Hausdorff measure on the
                manifold directly (True) or alternatively the negative
                logarithm of a density of a prior distriubtion on the
                unconstrained (ambient) position space with respect to the
                Lebesgue measure, with the target distribution then
                corresponding to the posterior distribution when conditioning
                on the event `const(pos) == 0` (False). Note that in the former
                case the base Hausdorff measure on the manifold depends on the
                metric defined on the ambient space, with the Hausdorff measure
                being defined with respect to the metric induced on the
                manifold from this ambient metric.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the derivative (and value)
                of `neg_log_dens` automatically.
            jacob_constr (
                    None or Callable[[array], array or Tuple[array, array]]):
                Function which given a position array computes the Jacobian
                (matrix / 2D array of partial derivatives) of the output of the
                constraint function `c = constr(q)` with respect to the
                position array argument `q`, returning the computed Jacobian as
                a 2D array `jacob` with

                    jacob[i, j] = c[i] / q[j]

                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the Jacobian
                and the second being the value of `constr` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the Jacobian (and value) of
                `neg_log_dens` automatically.
            mhp_constr (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable, array, array]]):
                Function which given a position array returns another function
                which takes a 2D array as an argument and returns the
                *matrix-Hessian-product* (MHP) of the constraint function
                `constr` with respect to the position array argument. The MHP
                is here defined as a function of a `(dim_constr, dim_pos)`
                shaped 2D array `m`

                    mhp(m) = sum(m[:, :, None] * hess[:, :, :], axis=(0, 1))

                where `hess` is the `(dim_constr, dim_pos, dim_pos)` shaped
                vector-Hessian of `c = constr(q)` with respect to `q` i.e. the
                array of second-order partial derivatives of such that

                    hess[i, j, k] = c[i] / (q[j] q[k])

                Optionally the function may instead return a 3-tuple of values
                with the first a function to compute a MHP of `constr`, the
                second a 2D array corresponding to the Jacobian of `constr`,
                and the third the value of `constr`, all evaluated at the
                passed position array. If `None` is passed (the default) an
                automatic differentiation fallback will be used to attempt to
                construct a function which calculates the MHP (and Jacobian and
                value) of `constr` automatically.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens=neg_log_dens, constr=constr,
                         metric=metric, dens_wrt_hausdorff=dens_wrt_hausdorff,
                         grad_neg_log_dens=grad_neg_log_dens,
                         jacob_constr=jacob_constr)
        if not dens_wrt_hausdorff:
            self._mhp_constr = autodiff_fallback(
                mhp_constr, constr, &#39;mhp_jacobian_and_value&#39;, &#39;mhp_constr&#39;)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;mhp_constr&#39;, &#39;jacob_constr&#39;, &#39;constr&#39;])
    def mhp_constr(self, state):
        return self._mhp_constr(state.pos)

    def jacob_constr_inner_product(
            self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
        if jacob_constr_2 is None or jacob_constr_2 is jacob_constr_1:
            return DensePositiveDefiniteMatrix(
                jacob_constr_1 @ (inner_product_matrix @ jacob_constr_1.T))
        else:
            return DenseSquareMatrix(
                jacob_constr_1 @ (inner_product_matrix @ jacob_constr_2.T))

    @cache_in_state(&#39;pos&#39;)
    def grad_log_det_sqrt_gram(self, state):
        # Evaluate MHP of constraint function before Jacobian as Jacobian value
        # will potentially be computed in &#39;forward&#39; pass and cached
        mhp_constr = self.mhp_constr(state)
        return mhp_constr(
            self.inv_gram(state) @ self.jacob_constr(state) @ self.metric.inv)


class GaussianDenseConstrainedEuclideanMetricSystem(
        GaussianEuclideanMetricSystem, DenseConstrainedEuclideanMetricSystem):
    r&#34;&#34;&#34;Gaussian Euclidean Hamiltonian system st. a dense set of constraints.

    See `ConstrainedEuclideanMetricSystem` for more details about constrained
    systems and `GaussianEuclideanMetricSystem` for Gaussian Euclidean metric
    systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, constr, metric=None,
                 grad_neg_log_dens=None, jacob_constr=None, mhp_constr=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the unconstrained (ambient)
                position space with respect to the standard Gaussian measure.
                The density function is taken to specify a prior distribution
                on the ambient space with the target distribution then
                corresponding to the posterior distribution when conditioning
                on the (zero Lebesgue measure) event `constr(pos) == 0`. This
                target posterior distribution has support on the differentiable
                manifold implicitly defined by the constraint equation, with
                density with respect to the Hausdorff measure on the manifold
                corresponding to the ratio of the prior density (specified by
                `neg_log_dens`) and the square-root of the determinant of the
                Gram matrix defined by

                    gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T

                where `jacob_constr` is the Jacobian of the constraint function
                `constr` and `metric` is the matrix representation of the
                metric on the ambient space.
            constr (Callable[[array], array]): Function which given a position
                array return as a 1D array the value of the (vector-valued)
                constraint function, the zero level-set of which implicitly
                defines the manifold the dynamic is simulated on.
            metric (None or array or PositiveDefiniteMatrix): Matrix object
                corresponding to matrix representation of metric on
                *unconstrained* position space and covariance of Gaussian
                marginal distribution on *unconstrained* momentum vector. If
                `None` is passed (the default), the identity matrix will be
                used. If a 1D array is passed then this is assumed to specify a
                metric with positive diagonal matrix representation and the
                array the matrix diagonal. If a 2D array is passed then this is
                assumed to specify a metric with a dense positive definite
                matrix representation specified by the array. Otherwise if
                a subclass of `mici.matrices.PositiveDefiniteMatrix` it is
                assumed to directly specify the metric matrix representation.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the derivative (and value)
                of `neg_log_dens` automatically.
            jacob_constr (
                    None or Callable[[array], array or Tuple[array, array]]):
                Function which given a position array computes the Jacobian
                (matrix / 2D array of partial derivatives) of the output of the
                constraint function `c = constr(q)` with respect to the
                position array argument `q`, returning the computed Jacobian as
                a 2D array `jacob` with

                    jacob[i, j] = c[i] / q[j]

                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the Jacobian
                and the second being the value of `constr` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the Jacobian (and value) of
                `neg_log_dens` automatically.
            mhp_constr (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable, array, array]]):
                Function which given a position array returns another function
                which takes a 2D array as an argument and returns the
                *matrix-Hessian-product* (MHP) of the constraint function
                `constr` with respect to the position array argument. The MHP
                is here defined as a function of a `(dim_constr, dim_pos)`
                shaped 2D array `m`

                    mhp(m) = sum(m[:, :, None] * hess[:, :, :], axis=(0, 1))

                where `hess` is the `(dim_constr, dim_pos, dim_pos)` shaped
                vector-Hessian of `c = constr(q)` with respect to `q` i.e. the
                array of second-order partial derivatives of such that

                    hess[i, j, k] = c[i] / (q[j] q[k])

                Optionally the function may instead return a 3-tuple of values
                with the first a function to compute a MHP of `constr`, the
                second a 2D array corresponding to the Jacobian of `constr`,
                and the third the value of `constr`, all evaluated at the
                passed position array. If `None` is passed (the default) an
                automatic differentiation fallback will be used to attempt to
                construct a function which calculates the MHP (and Jacobian and
                value) of `constr` automatically.
        &#34;&#34;&#34;
        DenseConstrainedEuclideanMetricSystem.__init__(
            self, neg_log_dens=neg_log_dens, constr=constr, metric=metric,
            dens_wrt_hausdorff=False,
            grad_neg_log_dens=grad_neg_log_dens, jacob_constr=jacob_constr,
            mhp_constr=mhp_constr)

    def jacob_constr_inner_product(
            self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
        if jacob_constr_2 is None or jacob_constr_2 is jacob_constr_1:
            return DenseSymmetricMatrix(
                jacob_constr_1 @ (inner_product_matrix @ jacob_constr_1.T))
        else:
            return DenseSquareMatrix(
                jacob_constr_1 @ (inner_product_matrix @ jacob_constr_2.T))


class RiemannianMetricSystem(System):
    r&#34;&#34;&#34;Riemannian Hamiltonian system with a position-dependent metric.

    This class allows for metric matrix representations of any generic type.
    In most cases a specialised subclass such as `DenseRiemannianMetricSystem`,
    `CholeskyFactoredRiemannianMetricSystem`, `DiagonalRiemannianMetricSystem`,
    `ScalarRiemannianMetricSystem` or `SoftAbsRiemannianMetricSystem` will
    provide a simpler method of constructng a system with a metric matrix
    representation of a specific type.

    The position space is assumed to be a Riemannian manifold with a metric
    with position-dependent positive definite matrix-representation \(M(q)\)
    where \(q\) is a position vector. The momentum \(p\) is then taken to have
    a zero-mean Gaussian conditional distribution given the position \(q\),
    with covariance \(M(q)\), i.e. \(p \sim \mathcal{N}(0, M(q))\) [1].

    The \(h_1\) Hamiltonian component is then

    \[ h_1(q) = \ell(q) + \frac{1}{2}\log\left|M(q)\right| \]

    where \(\ell(q)\) is the negative log (unnormalised) density of the target
    distribution with respect to the Lebesgue measure at \(q\). The \(h_2\)
    Hamiltonian component is

    \[ h_2(q, p) = \frac{1}{2} p^T (M(q))^{-1} p. \]

    Due to the coupling between the position and momentum variables in \(h_2\),
    the Hamiltonian system is non-separable, requiring use of a numerical
    integrator with implicit steps when simulating the Hamiltonian dynamic
    associated with the system, e.g.
    `mici.integrators.ImplicitLeapfrogIntegrator`.

    References:

      1. Girolami, M. and Calderhead, B., 2011. Riemann manifold Langevin and
         Hamiltonian Monte Varlo methods. Journal of the Royal Statistical
         Society: Series B (Statistical Methodology), 73(2), pp.123-214.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_matrix_class, metric_func,
                 vjp_metric_func=None, grad_neg_log_dens=None,
                 metric_kwargs=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric_matrix_class (type[PositiveDefiniteMatrix]): Class (or
                factory function returning an instance of the class) which
                defines type of matrix representation of metric. The class
                initializer should take a single positional argument which will
                be passed the array outputted by `metric_func`, and which is
                assumed to be a parameter which fully defines the resulting
                matrix (e.g. the diagonal of a `mici.matrices.DiagonalMatrix`).
                The class initializer may also optionally take one or more
                keyword arguments, with the `metric_kwargs` argument used to
                specify the value of these, if any. Together this means the
                metric matrix representation at a position `pos` is constructed
                as

                    metric = metric_matrix_class(
                        metric_func(pos), **metric_kwargs)

                The `mici.matrices.PositiveDefiniteMatrix` subclass should as a
                minimum define `inv`, `log_abs_det`, `grad_log_abs_det`,
                `grad_quadratic_form_inv`, `__matmul__` and `__rmatmul__`
                methods / properties (see documentation of
                `mici.matrices.PositiveDefiniteMatrix` and
                `mici.matrices.DifferentiableMatrix` for definitions of the
                expected behaviour of these methods).
            metric_func (Callable[[array], array]): Function which given a
                position array returns an array containing the parameter value
                of the metric matrix representation passed as the single
                positional argument to the `metric_matrix_class` initializer.
            vjp_metric_func (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable[[array], array], array]]):
                Function which given a position array returns another function
                which takes an array as an argument and returns the
                *vector-Jacobian-product* (VJP) of `metric_func` with respect
                to the position array argument. The VJP is here defined as a
                function of an array `v` (of the same shape as the output of
                `metric_func`) corresponding to

                    vjp(v) = sum(v[..., None] * jacob, tuple(range(v.ndim))

                where `jacob` is the Jacobian of `m = metric_func(q)` wrt `q`
                i.e. the array of partial derivatives of the function such that

                    jacob[..., i] = m[...] / q[i]

                Optionally the function may instead return a 2-tuple of values
                with the first a function to compute a VJP of `metric_func` and
                the second an array containing the value of `metric_func`, both
                evaluated at the passed position array. If `None` is passed
                (the default) an automatic differentiation fallback will be
                used to attempt to construct a function which calculates the
                VJP (and value) of `metric_func` automatically.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
            metric_kwargs (None or Dict[str, object]): An optional dictionary
                of any additional keyword arguments to the initializer of
                `metric_matrix_class`.
        &#34;&#34;&#34;
        self._metric_matrix_class = metric_matrix_class
        self._metric_func = metric_func
        self._vjp_metric_func = autodiff_fallback(
            vjp_metric_func, metric_func, &#39;vjp_and_value&#39;, &#39;vjp_metric_func&#39;)
        self._metric_kwargs = {} if metric_kwargs is None else metric_kwargs
        super().__init__(neg_log_dens, grad_neg_log_dens)

    @cache_in_state(&#39;pos&#39;)
    def metric_func(self, state):
        &#34;&#34;&#34;
        Function computing the parameter of the metric matrix representation.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `metric_func(state.pos)`.
        &#34;&#34;&#34;
        return self._metric_func(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;vjp_metric_func&#39;, &#39;metric_func&#39;])
    def vjp_metric_func(self, state):
        &#34;&#34;&#34;
        Function constructing a vector-Jacobian-product for `metric_func`.

        The vector-Jacobian-product is here defined as a function of an array
        `v` (of the same shape as the output of `metric_func`) corresponding to

            vjp(v) = sum(v[..., None] * jacob, axis=tuple(range(v.ndim))

        where `jacob` is the Jacobian of `m = metric_func(q)` wrt `q` i.e.
        the array of partial derivatives of the function such that

            jacob[..., i] = m[...] / q[i]

        Args:
            state (mici.states.ChainState): State to compute VJP at.

        Returns:
            Callable[[array], array]: Vector-Jacobian-product function.
        &#34;&#34;&#34;
        return self._vjp_metric_func(state.pos)

    @cache_in_state(&#39;pos&#39;)
    def metric(self, state):
        &#34;&#34;&#34;
        Function computing the metric matrix representation.

        The returned type of this function is that specified by the
        `metric_matrix_class` argument to the initializer.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            mici.matrices.PositiveDefiniteMatrix: Metric matrix representation.
        &#34;&#34;&#34;
        return self._metric_matrix_class(
            self.metric_func(state), **self._metric_kwargs)

    def h(self, state):
        return self.h1(state) + self.h2(state)

    def h1(self, state):
        return self.neg_log_dens(state) + 0.5 * self.metric(state).log_abs_det

    def dh1_dpos(self, state):
        # Evaluate VJP of metric function before metric as metric value will
        # potentially be computed in forward pass and cached
        vjp_metric = self.vjp_metric_func(state)
        return (self.grad_neg_log_dens(state) +
                0.5 * vjp_metric(self.metric(state).grad_log_abs_det))

    def h2(self, state):
        return 0.5 * state.mom @ self.metric(state).inv @ state.mom

    def dh2_dpos(self, state):
        # Evaluate VJP of metric function before metric as metric value will
        # potentially be computed in forward pass and cached
        vjp_metric = self.vjp_metric_func(state)
        return 0.5 * vjp_metric(
            self.metric(state).grad_quadratic_form_inv(state.mom))

    def dh2_dmom(self, state):
        return self.metric(state).inv @ state.mom

    def sample_momentum(self, state, rng):
        return self.metric(state).sqrt @ rng.normal(size=state.pos.shape)


class ScalarRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;Riemannian-metric system with scaled identity matrix representation.

    Hamiltonian system with a position dependent scaled identity metric matrix
    representation which is specified by a scalar function
    `metric_scalar_function` of the position `q` which outputs a strictly
    positive scalar `s = metric_scalar_func(q)` with the the metric matrix
    representation then taken to be `s * identity(q.shape[0])`.

    See documentation of `RiemannianMetricSystem` for more general details
    about Riemannian-metric Hamiltonian systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_scalar_func,
                 vjp_metric_scalar_func=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric_scalar_func (Callable[[array], float]): Function which
                given a position array returns a strictly positive scalar
                corresponding to the parameter value of the scaled identity
                metric matrix representation.
            vjp_metric_scalar_func (None or
                    Callable[[array], Callable[[array], float]] or
                    Callable[[array], Tuple[Callable[[array, float]], float]]):
                Function which given a position array returns another function
                which takes a scalar as an argument and returns the
                *vector-Jacobian-product* (VJP) of `metric_scalar_func` with
                respect to the position array argument. The VJP is here defined
                as a function of a scalar `v`

                    vjp(v) = v * grad

                where `grad` is the `(dim_pos,)` shaped Jacobian (gradient) of
                `s = metric_scalar_func(q)` with respect to `q` i.e. the array
                of partial derivatives of the function such that

                    grad[i] = s / q[i]

                Optionally the function may instead return a 2-tuple of values
                with the first a function to compute a VJP of
                `metric_scalar_func` and the second a float containing the
                value of `metric_scalar_func`, both evaluated at the passed
                position array. If `None` is passed (the default) an automatic
                differentiation fallback will be used to attempt to construct a
                function which calculates the VJP (and value) of
                `metric_scalar_func` automatically.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;

        super().__init__(
            neg_log_dens, PositiveScaledIdentityMatrix, metric_scalar_func,
            vjp_metric_scalar_func, grad_neg_log_dens)

    @cache_in_state(&#39;pos&#39;)
    def metric(self, state):
        return self._metric_matrix_class(
            self.metric_func(state), size=pos.shape[0])


class DiagonalRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;Riemannian-metric system with diagonal matrix representation.

    Hamiltonian system with a position dependent diagonal metric matrix
    representation which is specified by a vector-valued function
    `metric_diagonal_func` of the position `q` which outputs a 1D array with
    strictly positive elements `d = metric_diagonal_func(q)` with the metric
    matrix representation then taken to be `diag(d)`.

    See documentation of `RiemannianMetricSystem` for more general details
    about Riemannian-metric Hamiltonian systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_diagonal_func,
                 vjp_metric_diagonal_func=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric_diagonal_func (Callable[[array], array]): Function which
                given a position array returns a 1D array with strictly
                positive values corresponding to the diagonal values
                (left-to-right) of the diagonal metric matrix representation.
            vjp_metric_diagonal_func (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable[[array], array], array]]):
                Function which given a position array returns another function
                which takes a 1D array as an argument and returns the
                *vector-Jacobian-product* (VJP) of `metric_diagonal_func` with
                respect to the position array argument. The VJP is here defined
                as a function of a 1D array `v`

                    vjp(v) = sum(v[:, None] * jacob[:, :], axis=0)

                where `jacob` is the `(dim_pos, dim_pos)` shaped Jacobian of
                `d = metric_diagonal_func(q)` with respect to `q` i.e. the
                array of partial derivatives of the function such that

                    jacob[i, j] = d[i] / q[j]

                Optionally the function may instead return a 2-tuple of values
                with the first a function to compute a VJP of
                `metric_diagonal_func` and the second a 1D array containing the
                value of `metric_diagonal_func`, both evaluated at the passed
                position array. If `None` is passed (the default) an automatic
                differentiation fallback will be used to attempt to construct a
                function which calculates the VJP (and value) of
                `metric_diagonal_func` automatically.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(
            neg_log_dens, PositiveDiagonalMatrix, metric_diagonal_func,
            vjp_metric_diagonal_func, grad_neg_log_dens)


class CholeskyFactoredRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;Riemannian-metric system with Cholesky-factored matrix representation.

    Hamiltonian system with a position dependent metric matrix representation
    which is specified by its Cholesky factor by a matrix function
    `metric_chol_func` of the position `q` which outputs a lower-triangular
    matrix `L = metric_chol_func(q)` with the metric matrix representation then
    taken to be `L @ L.T`.

    See documentation of `RiemannianMetricSystem` for more general details
    about Riemannian-metric Hamiltonian systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_chol_func,
                 vjp_metric_chol_func=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric_chol_func (Callable[[array], array]): Function which given
                a position array returns a 2D array with zeros above the
                diagonal corresponding to the lower-triangular Cholesky-factor
                of the positive definite metric matrix representation.
            vjp_metric_chol_func (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable[[array], array], array]]):
                Function which given a position array returns another function
                which takes a lower-triangular 2D array as an argument (any
                values in the array above the diagonal are ignored) and returns
                the *vector-Jacobian-product* (VJP) of `metric_chol_func` with
                respect to the position array argument. The VJP is here defined
                as a function of a 2D array `v`

                    vjp(v) = sum(v[:, :, None] * jacob[:, :, :], axis=(0, 1))

                where `jacob` is the `(dim_pos, dim_pos, dim_pos)` shaped
                Jacobian of `L = metric_chol_func(q)` with respect to `q` i.e.
                the array of partial derivatives of the function such that

                    jacob[i, j, k] = L[i, j] / q[k]

                Optionally the function may instead return a 2-tuple of values
                with the first a function to compute a VJP of
                `metric_chol_func` and the second a 2D array containing the
                value of `metric_chol_func`, both evaluated at the passed
                position array. If `None` is passed (the default) an automatic
                differentiation fallback will be used to attempt to construct a
                function which calculates the VJP (and value) of
                `metric_chol_func` automatically.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(
            neg_log_dens, TriangularFactoredPositiveDefiniteMatrix,
            metric_chol_func, vjp_metric_chol_func, grad_neg_log_dens,
            metric_kwargs={&#39;factor_is_lower&#39;: True})


class DenseRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;Riemannian-metric system with dense matrix representation.

    Hamiltonian system with a position dependent metric matrix representation
    which is specified to be a dense matrix function `metric_func` of the
    position `q` which is guaranteed to be positive definite almost-everywhere,
    with `M = metric_func(q)` then the metric matrix representation.

    See documentation of `RiemannianMetricSystem` for more general details
    about Riemannian-metric Hamiltonian systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_func,
                 vjp_metric_func=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric_func (Callable[[array], array]): Function which given a
                position array returns a 2D array corresponding to the positive
                definite metric matrix representation. The returned matrices
                (2D arrays) are assumed to be positive-definite for all input
                positions and a `LinAlgError` exception may be raised if this
                fails to be the case.
            vjp_metric_func (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable[[array], array], array]]):
                Function which given a position array returns another function
                which takes a 2D array as an argument and returns the
                *vector-Jacobian-product* (VJP) of `metric_func` with respect
                to the position array argument. The VJP is here defined as a
                function of a 2D array `v`

                    vjp(v) = sum(v[:, :, None] * jacob[:, :, :], axis=(0, 1))

                where `jacob` is the `(dim_pos, dim_pos, dim_pos)` shaped
                Jacobian of `M = metric_func(q)` with respect to `q` i.e. the
                array of partial derivatives of the function such that

                    jacob[i, j, k] = M[i, j] / q[k]

                Optionally the function may instead return a 2-tuple of values
                with the first a function to compute a VJP of `metric_func` and
                the second a 2D array containing the value of `metric_func`,
                both evaluated at the passed position array. If `None` is
                passed (the default) an automatic differentiation fallback will
                be used to attempt to construct a function which calculates the
                VJP (and value) of `metric_func` automatically.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(
            neg_log_dens, DensePositiveDefiniteMatrix, metric_func,
            vjp_metric_func, grad_neg_log_dens)


class SoftAbsRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;SoftAbs Riemmanian metric Hamiltonian system.

    Hamiltonian system with a position dependent metric matrix representation
    which is specified to be a dense matrix function `metric_func` of the
    position `q` which is guaranteed to be positive definite almost-everywhere,
    with `M = metric_func(q)` then the metric matrix representation.

    Hamiltonian system with a position dependent metric matrix representation
    which is specified to be an eigenvalue-regularised transformation of the
    Hessian of the negative log density function (the symmetric matrix of
    second derivatives the negative log density function with respect to the
    position array components. Specifically if `hess_neg_log_dens` is a
    symmetric 2D square array valued function of the position `q`, with
    `H = hess_neg_log_dens(q)` then if an eigenvalue decomposition of `H` is
    computed, i.e. `eigval, eigvec = eigh(H)`, with `eigval` a 1D array of
    real eigenvalues, and `eigvec` the corresponding 2D array (orthogonal
    matrix) with eigenvectors as columns, then the resulting positive-definite
    metric matrix representation `M` is computed as

        M = eigvec @ diag(softabs(eigval, softabs_coeff)) @ eigvec.T

    with `softabs(x, softabs_coeff) = x / tanh(x * softabs_coeff)` an
    elementwise function which acts as a smooth approximation to the absolute
    function (ensuring all the eigenvalues of `M` are strictly positive) with
    the additional scalar parameter `softabs_coeff` controlling the smoothness
    of the approximation, with `softabs` tending to the piecewise linear `abs`
    function as `softabs_coeff` tends to infinity, and becoming increasingly
    smooth as `softabs_coeff` tends to zero.

    See documentation of `RiemannianMetricSystem` for more general details
    about Riemannian-metric Hamiltonian systems.

    References:

      1. Betancourt, M., 2013. A general metric for Riemannian manifold
         Hamiltonian Monte Carlo. In Geometric science of information
         (pp. 327-334).
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, grad_neg_log_dens=None,
                 hess_neg_log_dens=None, mtp_neg_log_dens=None,
                 softabs_coeff=1.):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
            hess_neg_log_dens (None or
                    Callable[[array], array or Tuple[array, array, float]]):
                Function which given a position array returns the Hessian of
                `neg_log_dens` with respect to the position array argument as a
                2D array. Optionally the function may instead return a 3-tuple
                of values with the first a 2D array containting the Hessian of
                `neg_log_dens`, the second a 1D array containing the gradient
                of `neg_log_dens` and the third the value of `neg_log_dens`,
                all evaluated at the passed position array. If `None` is passed
                (the default) an automatic differentiation fallback will be
                used to attempt to construct a function which calculates the
                Hessian (and gradient and value) of `neg_log_dens`
                automatically.
            mtp_neg_log_dens (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable, array, array, float]]):
                Function which given a position array returns another function
                which takes a 2D array (matrix) as an argument and returns the
                *matrix-Tressian-product* (MTP) of `neg_log_dens` with respect
                to the position array argument. The MTP is here defined as a
                function of a matrix `m` corresponding to

                    mtp(m) = sum(m[:, :, None] * tress[:, :, :], axis=(0, 1))

                where `tress` is the &#39;Tressian&#39; of `f = neg_log_dens(q)` wrt
                `q` i.e. the 3D array of third-order partial derivatives of the
                scalar-valued function such that

                    tress[i, j, k] = f / (q[i] q[j] q[k])

                Optionally the function may instead return a 4-tuple of values
                with the first a function to compute a MTP of `neg_log_dens`,
                the second a 2D array containing the Hessian of `neg_log_dens`,
                the third a 1D array containing the gradient of `neg_log_dens`
                and the fourth the value of `neg_log_dens`, all evaluated at
                the passed position array. If `None` is passed (the default) an
                automatic differentiation fallback will be used to attempt to
                construct a function which calculates the MTP (and Hesisan and
                gradient and value) of `neg_log_dens` automatically.
            softabs_coeff (float): Positive regularisation coefficient for
                smooth approximation to absolute value used to regularise
                Hessian eigenvalues in metric matrix representation. As the
                value tends to infinity the approximation becomes increasingly
                close to the absolute function.
        &#34;&#34;&#34;
        self._hess_neg_log_dens = autodiff_fallback(
            hess_neg_log_dens, neg_log_dens, &#39;hessian_grad_and_value&#39;,
            &#39;neg_log_dens&#39;)
        self._mtp_neg_log_dens = autodiff_fallback(
            mtp_neg_log_dens, neg_log_dens, &#39;mtp_hessian_grad_and_value&#39;,
            &#39;mtp_neg_log_dens&#39;)
        super().__init__(neg_log_dens,
                         SoftAbsRegularisedPositiveDefiniteMatrix,
                         self._hess_neg_log_dens, self._mtp_neg_log_dens,
                         grad_neg_log_dens,
                         metric_kwargs={&#39;softabs_coeff&#39;: softabs_coeff})

    def metric_func(self, state):
        return self.hess_neg_log_dens(state)

    def vjp_metric_func(self, state):
        return self.mtp_neg_log_dens(state)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;hess_neg_log_dens&#39;, &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def hess_neg_log_dens(self, state):
        &#34;&#34;&#34;Hessian of negative log density with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            hessian (array): 2D array of `neg_log_dens(state)` second
                derivatives with respect to `state.pos`, with `hessian[i, j]`
                the second derivative of `neg_log_dens(state)` with respect to
                `state.pos[i]` and `state.pos[j]`.
        &#34;&#34;&#34;
        return self._hess_neg_log_dens(state.pos)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;mtp_neg_log_dens&#39;, &#39;hess_neg_log_dens&#39;,
                  &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def mtp_neg_log_dens(self, state):
        &#34;&#34;&#34;Generate MTP of negative log density with respect to position.

        The matrix-Tressian-product (MTP) is here defined as a function of a
        matrix `m` corresponding to

            mtp(m) = sum(m[:, :, None] * tress[:, :, :], axis=(0, 1))

        where `tress` is the &#39;Tressian&#39; of `f = neg_log_dens(q)` with respect
        to `q = state.pos` i.e. the 3D array of third-order partial derivatives
        of the scalar-valued function such that

            tress[i, j, k] = f / (q[i] q[j] q[k])

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            mtp (Callable[[array], array]): Function which accepts a 2D array
                of shape `(state.pos.shape[0], state.pos.shape[0])` as an
                argument and returns an array of shape `state.pos.shape`
                containing the computed MTP value.
        &#34;&#34;&#34;
        return self._mtp_neg_log_dens(state.pos)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mici.systems.System"><code class="flex name class">
<span>class <span class="ident">System</span></span>
<span>(</span><span>neg_log_dens, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for Hamiltonian systems.</p>
<p>The Hamiltonian function <span><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span> is assumed to have the general form</p>
<p><span><span class="MathJax_Preview"> h(q, p) = h_1(q) + h_2(q, p) </span><script type="math/tex; mode=display"> h(q, p) = h_1(q) + h_2(q, p) </script></span></p>
<p>where <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> and <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> are the position and momentum variables respectively,
and <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> and <span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> Hamiltonian component functions. The exact
Hamiltonian flow for the <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> component can be always be computed as it
depends only on the position variable however depending on the form of
<span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> the corresponding exact Hamiltonian flow may or may not be
simulable.</p>
<p>By default <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> is assumed to correspond to the negative logarithm of an
unnormalised density on the position variables with respect to the Lebesgue
measure, with the corresponding distribution on the position space being
the target distribution it is wished to draw approximate samples from.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L15-L187" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class System(ABC):
    r&#34;&#34;&#34;Base class for Hamiltonian systems.

    The Hamiltonian function \(h\) is assumed to have the general form

    \[ h(q, p) = h_1(q) + h_2(q, p) \]

    where \(q\) and \(p\) are the position and momentum variables respectively,
    and \(h_1\) and \(h_2\) Hamiltonian component functions. The exact
    Hamiltonian flow for the \(h_1\) component can be always be computed as it
    depends only on the position variable however depending on the form of
    \(h_2\) the corresponding exact Hamiltonian flow may or may not be
    simulable.

    By default \(h_1\) is assumed to correspond to the negative logarithm of an
    unnormalised density on the position variables with respect to the Lebesgue
    measure, with the corresponding distribution on the position space being
    the target distribution it is wished to draw approximate samples from.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        self._neg_log_dens = neg_log_dens
        self._grad_neg_log_dens = autodiff_fallback(
            grad_neg_log_dens, neg_log_dens,
            &#39;grad_and_value&#39;, &#39;grad_neg_log_dens&#39;)

    @cache_in_state(&#39;pos&#39;)
    def neg_log_dens(self, state):
        &#34;&#34;&#34;Negative logarithm of unnormalised density of target distribution.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of computed negative log density.
        &#34;&#34;&#34;
        return self._neg_log_dens(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def grad_neg_log_dens(self, state):
        &#34;&#34;&#34;Derivative of negative log density with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `neg_log_dens(state)` derivative with respect to
                `state.pos`.
        &#34;&#34;&#34;
        return self._grad_neg_log_dens(state.pos)

    def h1(self, state):
        &#34;&#34;&#34;Hamiltonian component depending only on position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of `h1` Hamiltonian component.
        &#34;&#34;&#34;
        return self.neg_log_dens(state)

    def dh1_dpos(self, state):
        &#34;&#34;&#34;Derivative of `h1` Hamiltonian component with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of computed `h1` derivative.
        &#34;&#34;&#34;
        return self.grad_neg_log_dens(state)

    def h1_flow(self, state, dt):
        &#34;&#34;&#34;Apply exact flow map corresponding to `h1` Hamiltonian component.

        `state` argument is modified in place.

        Args:
            state (mici.states.ChainState): State to start flow at.
            dt (float): Time interval to simulate flow for.
        &#34;&#34;&#34;
        state.mom -= dt * self.dh1_dpos(state)

    @abstractmethod
    def h2(self, state):
        &#34;&#34;&#34;Hamiltonian component depending on momentum and optionally position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of `h2` Hamiltonian component.
        &#34;&#34;&#34;

    @abstractmethod
    def dh2_dmom(self, state):
        &#34;&#34;&#34;Derivative of `h2` Hamiltonian component with respect to momentum.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h2(state)` derivative with respect to `state.pos`.
        &#34;&#34;&#34;

    def h(self, state):
        &#34;&#34;&#34;Hamiltonian function for system.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of Hamiltonian.
        &#34;&#34;&#34;
        return self.h1(state) + self.h2(state)

    def dh_dpos(self, state):
        &#34;&#34;&#34;Derivative of Hamiltonian with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h(state)` derivative with respect to `state.pos`.
        &#34;&#34;&#34;
        if hasattr(self, &#39;dh2_dpos&#39;):
            return self.dh1_dpos(state) + self.dh2_dpos(state)
        else:
            return self.dh1_dpos(state)

    def dh_dmom(self, state):
        &#34;&#34;&#34;Derivative of Hamiltonian with respect to momentum.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h(state)` derivative with respect to `state.mom`.
        &#34;&#34;&#34;
        return self.dh2_dmom(state)

    @abstractmethod
    def sample_momentum(self, state, rng):
        &#34;&#34;&#34;
        Sample a momentum from its conditional distribution given a position.

        Args:
            state (mici.states.ChainState): State defining position to
               condition on.

        Returns:
            mom (array): Sampled momentum.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></li>
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.System.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L60-L70" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def neg_log_dens(self, state):
    &#34;&#34;&#34;Negative logarithm of unnormalised density of target distribution.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        float: Value of computed negative log density.
    &#34;&#34;&#34;
    return self._neg_log_dens(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L72-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state([&#39;pos&#39;], [&#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
def grad_neg_log_dens(self, state):
    &#34;&#34;&#34;Derivative of negative log density with respect to position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `neg_log_dens(state)` derivative with respect to
            `state.pos`.
    &#34;&#34;&#34;
    return self._grad_neg_log_dens(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L85-L94" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h1(self, state):
    &#34;&#34;&#34;Hamiltonian component depending only on position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        float: Value of `h1` Hamiltonian component.
    &#34;&#34;&#34;
    return self.neg_log_dens(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L96-L105" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh1_dpos(self, state):
    &#34;&#34;&#34;Derivative of `h1` Hamiltonian component with respect to position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of computed `h1` derivative.
    &#34;&#34;&#34;
    return self.grad_neg_log_dens(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L107-L116" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h1_flow(self, state, dt):
    &#34;&#34;&#34;Apply exact flow map corresponding to `h1` Hamiltonian component.

    `state` argument is modified in place.

    Args:
        state (mici.states.ChainState): State to start flow at.
        dt (float): Time interval to simulate flow for.
    &#34;&#34;&#34;
    state.mom -= dt * self.dh1_dpos(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L118-L127" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def h2(self, state):
    &#34;&#34;&#34;Hamiltonian component depending on momentum and optionally position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        float: Value of `h2` Hamiltonian component.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.systems.System.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L129-L138" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def dh2_dmom(self, state):
    &#34;&#34;&#34;Derivative of `h2` Hamiltonian component with respect to momentum.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `h2(state)` derivative with respect to `state.pos`.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.systems.System.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L140-L149" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h(self, state):
    &#34;&#34;&#34;Hamiltonian function for system.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        float: Value of Hamiltonian.
    &#34;&#34;&#34;
    return self.h1(state) + self.h2(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L151-L163" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh_dpos(self, state):
    &#34;&#34;&#34;Derivative of Hamiltonian with respect to position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `h(state)` derivative with respect to `state.pos`.
    &#34;&#34;&#34;
    if hasattr(self, &#39;dh2_dpos&#39;):
        return self.dh1_dpos(state) + self.dh2_dpos(state)
    else:
        return self.dh1_dpos(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L165-L174" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh_dmom(self, state):
    &#34;&#34;&#34;Derivative of Hamiltonian with respect to momentum.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `h(state)` derivative with respect to `state.mom`.
    &#34;&#34;&#34;
    return self.dh2_dmom(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L176-L187" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def sample_momentum(self, state, rng):
    &#34;&#34;&#34;
    Sample a momentum from its conditional distribution given a position.

    Args:
        state (mici.states.ChainState): State defining position to
           condition on.

    Returns:
        mom (array): Sampled momentum.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.systems.EuclideanMetricSystem"><code class="flex name class">
<span>class <span class="ident">EuclideanMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian system with a Euclidean metric on the position space.</p>
<p>Here Euclidean metric is defined to mean a metric with a fixed positive
definite matrix representation <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>. The momentum variables are taken to
be independent of the position variables and with a zero-mean Gaussian
marginal distribution with covariance specified by <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>, so that the
<span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> Hamiltonian component is</p>
<p><span><span class="MathJax_Preview"> h_2(q, p) = \frac{1}{2} p^T M^{-1} p </span><script type="math/tex; mode=display"> h_2(q, p) = \frac{1}{2} p^T M^{-1} p </script></span></p>
<p>where <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> and <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> are the position and momentum variables respectively.</p>
<p>The <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> Hamiltonian component function is</p>
<p><span><span class="MathJax_Preview"> h_1(q) = \ell(q) </span><script type="math/tex; mode=display"> h_1(q) = \ell(q) </script></span></p>
<p>where <span><span class="MathJax_Preview">\ell(q)</span><script type="math/tex">\ell(q)</script></span> is the negative log (unnormalised) density of
the target distribution with respect to the Lebesgue measure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>None</code> or <code>array</code> or <code>PositiveDefiniteMatrix</code></dt>
<dd>Matrix object
corresponding to matrix representation of metric on position
space and covariance of Gaussian marginal distribution on
momentum vector. If <code>None</code> is passed (the default), the
identity matrix will be used. If a 1D array is passed then this
is assumed to specify a metric with positive diagonal matrix
representation and the array the matrix diagonal. If a 2D array
is passed then this is assumed to specify a metric with a dense
positive definite matrix representation specified by the array.
Otherwise if the value is a subclass of
<a title="mici.matrices.PositiveDefiniteMatrix" href="matrices.html#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a> it is assumed to
directly specify the metric matrix representation.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L190-L294" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EuclideanMetricSystem(System):
    r&#34;&#34;&#34;Hamiltonian system with a Euclidean metric on the position space.

    Here Euclidean metric is defined to mean a metric with a fixed positive
    definite matrix representation \(M\). The momentum variables are taken to
    be independent of the position variables and with a zero-mean Gaussian
    marginal distribution with covariance specified by \(M\), so that the
    \(h_2\) Hamiltonian component is

    \[ h_2(q, p) = \frac{1}{2} p^T M^{-1} p \]

    where \(q\) and \(p\) are the position and momentum variables respectively.

    The \(h_1\) Hamiltonian component function is

    \[ h_1(q) = \ell(q) \]

    where \(\ell(q)\) is the negative log (unnormalised) density of
    the target distribution with respect to the Lebesgue measure.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric (None or array or PositiveDefiniteMatrix): Matrix object
                corresponding to matrix representation of metric on position
                space and covariance of Gaussian marginal distribution on
                momentum vector. If `None` is passed (the default), the
                identity matrix will be used. If a 1D array is passed then this
                is assumed to specify a metric with positive diagonal matrix
                representation and the array the matrix diagonal. If a 2D array
                is passed then this is assumed to specify a metric with a dense
                positive definite matrix representation specified by the array.
                Otherwise if the value is a subclass of
                `mici.matrices.PositiveDefiniteMatrix` it is assumed to
                directly specify the metric matrix representation.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens, grad_neg_log_dens)
        if metric is None:
            self.metric = IdentityMatrix()
        elif isinstance(metric, np.ndarray):
            if metric.ndim == 1:
                self.metric = PositiveDiagonalMatrix(metric)
            elif metric.ndim == 2:
                self.metric = DensePositiveDefiniteMatrix(metric)
            else:
                raise ValueError(&#39;If NumPy ndarray value is used for `metric`&#39;
                                 &#39; must be either 1D (diagonal matrix) or 2D &#39;
                                 &#39;(dense positive definite matrix)&#39;)
        else:
            self.metric = metric

    @cache_in_state(&#39;mom&#39;)
    def h2(self, state):
        return 0.5 * state.mom @ (self.metric.inv @ state.mom)

    @cache_in_state(&#39;mom&#39;)
    def dh2_dmom(self, state):
        return self.metric.inv @ state.mom

    def h2_flow(self, state, dt):
        &#34;&#34;&#34;Apply exact flow map corresponding to `h2` Hamiltonian component.

        `state` argument is modified in place.

        Args:
            state (mici.states.ChainState): State to start flow at.
            dt (float): Time interval to simulate flow for.
        &#34;&#34;&#34;
        state.pos += dt * self.dh2_dmom(state)

    def dh2_flow_dmom(self, dt):
        &#34;&#34;&#34;Derivatives of `h2_flow` flow map with respect to input momentum.

        Args:
            dt (float): Time interval flow simulated for.

        Returns:
            dpos_dmom (mici.matrices.Matrix): Matrix representing derivative
                (Jacobian) of position output of `h2_flow` with respect to the
                value of the momentum component of the initial input state.
            dmom_dmom (mici.matrices.Matrix): Matrix representing derivative
                (Jacobian) of momentum output of `h2_flow` with respect to the
                value of the momentum component of the initial input state.
        &#34;&#34;&#34;
        return dt * self.metric.inv, IdentityMatrix(self.metric.shape[0])

    def sample_momentum(self, state, rng):
        return self.metric.sqrt @ rng.standard_normal(state.pos.shape)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></li>
<li><a title="mici.systems.ConstrainedEuclideanMetricSystem" href="#mici.systems.ConstrainedEuclideanMetricSystem">ConstrainedEuclideanMetricSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.EuclideanMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L258-L260" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;mom&#39;)
def h2(self, state):
    return 0.5 * state.mom @ (self.metric.inv @ state.mom)</code></pre>
</details>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L262-L264" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;mom&#39;)
def dh2_dmom(self, state):
    return self.metric.inv @ state.mom</code></pre>
</details>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.h2_flow"><code class="name flex">
<span>def <span class="ident">h2_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h2</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L266-L275" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h2_flow(self, state, dt):
    &#34;&#34;&#34;Apply exact flow map corresponding to `h2` Hamiltonian component.

    `state` argument is modified in place.

    Args:
        state (mici.states.ChainState): State to start flow at.
        dt (float): Time interval to simulate flow for.
    &#34;&#34;&#34;
    state.pos += dt * self.dh2_dmom(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.dh2_flow_dmom"><code class="name flex">
<span>def <span class="ident">dh2_flow_dmom</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivatives of <code>h2_flow</code> flow map with respect to input momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval flow simulated for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dpos_dmom</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="matrices.html#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Matrix representing derivative
(Jacobian) of position output of <code>h2_flow</code> with respect to the
value of the momentum component of the initial input state.</dd>
<dt><strong><code>dmom_dmom</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="matrices.html#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Matrix representing derivative
(Jacobian) of momentum output of <code>h2_flow</code> with respect to the
value of the momentum component of the initial input state.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L277-L291" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh2_flow_dmom(self, dt):
    &#34;&#34;&#34;Derivatives of `h2_flow` flow map with respect to input momentum.

    Args:
        dt (float): Time interval flow simulated for.

    Returns:
        dpos_dmom (mici.matrices.Matrix): Matrix representing derivative
            (Jacobian) of position output of `h2_flow` with respect to the
            value of the momentum component of the initial input state.
        dmom_dmom (mici.matrices.Matrix): Matrix representing derivative
            (Jacobian) of momentum output of `h2_flow` with respect to the
            value of the momentum component of the initial input state.
    &#34;&#34;&#34;
    return dt * self.metric.inv, IdentityMatrix(self.metric.shape[0])</code></pre>
</details>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L293-L294" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample_momentum(self, state, rng):
    return self.metric.sqrt @ rng.standard_normal(state.pos.shape)</code></pre>
</details>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem"><code class="flex name class">
<span>class <span class="ident">GaussianEuclideanMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Euclidean Hamiltonian system with a tractable Gaussian component.</p>
<p>Here Euclidean metric is defined to mean a metric with a fixed positive
definite matrix representation <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>. The momentum variables are taken to
be independent of the position variables and with a zero-mean Gaussian
marginal distribution with covariance specified by <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>.</p>
<p>Additionally the target distribution on the position variables is assumed
to be defined by an unnormalised density with respect to the standard
Gaussian measure on the position space (with identity covariance and zero
mean), with the Hamiltonian component <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> corresponding to the negative
logarithm of this density rather than the density with respect to the
Lebesgue measure on the position space, i.e.</p>
<p><span><span class="MathJax_Preview"> h_1(q) = \ell(q) - \frac{1}{2} q^T q </span><script type="math/tex; mode=display"> h_1(q) = \ell(q) - \frac{1}{2} q^T q </script></span></p>
<p>where <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> is the position and <span><span class="MathJax_Preview">\ell(q)</span><script type="math/tex">\ell(q)</script></span> is the negative log
(unnormalised) density of the target distribution with respect to the
Lebesgue measure at <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>. The Hamiltonian
component function <span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> is
then assumed to have the form</p>
<p><span><span class="MathJax_Preview"> h_2(q, p) = \frac{1}{2} q^T q + \frac{1}{2} p^T M^{-1} p </span><script type="math/tex; mode=display"> h_2(q, p) = \frac{1}{2} q^T q + \frac{1}{2} p^T M^{-1} p </script></span></p>
<p>where <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> is the momentum. In this case the Hamiltonian flow due to the
quadratic <span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> component can be solved for analytically, allowing an
integrator to be defined using this alternative splitting of the
Hamiltonian [1].</p>
<h2 id="references">References</h2>
<ol>
<li>Shahbaba, B., Lan, S., Johnson, W.O. and Neal, R.M., 2014. Split
Hamiltonian Monte Carlo. Statistics and Computing, 24(3), pp.339-349.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the standard Gaussian measure on the position space,
with the corresponding distribution on the position space being
the target distribution it is wished to draw approximate
samples from.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>None</code> or <code>array</code> or <code>PositiveDefiniteMatrix</code></dt>
<dd>Matrix object
corresponding to matrix representation of metric on position
space and covariance of Gaussian marginal distribution on
momentum vector. If <code>None</code> is passed (the default), the
identity matrix will be used. If a 1D array is passed then this
is assumed to specify a metric with positive diagonal matrix
representation and the array the matrix diagonal. If a 2D array
is passed then this is assumed to specify a metric with a dense
positive definite matrix representation specified by the array.
Otherwise if the value is a subclass of
<a title="mici.matrices.PositiveDefiniteMatrix" href="matrices.html#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a> it is assumed to
directly specify the metric matrix representation.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L297-L398" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GaussianEuclideanMetricSystem(EuclideanMetricSystem):
    r&#34;&#34;&#34;Euclidean Hamiltonian system with a tractable Gaussian component.

    Here Euclidean metric is defined to mean a metric with a fixed positive
    definite matrix representation \(M\). The momentum variables are taken to
    be independent of the position variables and with a zero-mean Gaussian
    marginal distribution with covariance specified by \(M\).

    Additionally the target distribution on the position variables is assumed
    to be defined by an unnormalised density with respect to the standard
    Gaussian measure on the position space (with identity covariance and zero
    mean), with the Hamiltonian component \(h_1\) corresponding to the negative
    logarithm of this density rather than the density with respect to the
    Lebesgue measure on the position space, i.e.

    \[ h_1(q) = \ell(q) - \frac{1}{2} q^T q \]

    where \(q\) is the position and \(\ell(q)\) is the negative log
    (unnormalised) density of the target distribution with respect to the
    Lebesgue measure at \(q\). The Hamiltonian  component function \(h_2\) is
    then assumed to have the form

    \[ h_2(q, p) = \frac{1}{2} q^T q + \frac{1}{2} p^T M^{-1} p \]

    where \(p\) is the momentum. In this case the Hamiltonian flow due to the
    quadratic \(h_2\) component can be solved for analytically, allowing an
    integrator to be defined using this alternative splitting of the
    Hamiltonian [1].

    References:

      1. Shahbaba, B., Lan, S., Johnson, W.O. and Neal, R.M., 2014. Split
         Hamiltonian Monte Carlo. Statistics and Computing, 24(3), pp.339-349.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the standard Gaussian measure on the position space,
                with the corresponding distribution on the position space being
                the target distribution it is wished to draw approximate
                samples from.
            metric (None or array or PositiveDefiniteMatrix): Matrix object
                corresponding to matrix representation of metric on position
                space and covariance of Gaussian marginal distribution on
                momentum vector. If `None` is passed (the default), the
                identity matrix will be used. If a 1D array is passed then this
                is assumed to specify a metric with positive diagonal matrix
                representation and the array the matrix diagonal. If a 2D array
                is passed then this is assumed to specify a metric with a dense
                positive definite matrix representation specified by the array.
                Otherwise if the value is a subclass of
                `mici.matrices.PositiveDefiniteMatrix` it is assumed to
                directly specify the metric matrix representation.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens, metric, grad_neg_log_dens)

    def h2(self, state):
        return (0.5 * state.pos @ state.pos +
                0.5 * state.mom @ self.metric.inv @ state.mom)

    @cache_in_state(&#39;mom&#39;)
    def dh2_dmom(self, state):
        return self.metric.inv @ state.mom

    @cache_in_state(&#39;mom&#39;)
    def dh2_dpos(self, state):
        return state.pos

    def h2_flow(self, state, dt):
        omega = 1. / self.metric.eigval**0.5
        sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
        eigvec_T_pos = self.metric.eigvec.T @ state.pos
        eigvec_T_mom = self.metric.eigvec.T @ state.mom
        state.pos = self.metric.eigvec @ (
            cos_omega_dt * eigvec_T_pos +
            (sin_omega_dt * omega) * eigvec_T_mom)
        state.mom = self.metric.eigvec @ (
            cos_omega_dt * eigvec_T_mom -
            (sin_omega_dt / omega) * eigvec_T_pos)

    def dh2_flow_dmom(self, dt):
        omega = 1. / self.metric.eigval**0.5
        sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
        return (
            EigendecomposedSymmetricMatrix(
                self.metric.eigvec, sin_omega_dt * omega),
            EigendecomposedSymmetricMatrix(
                self.metric.eigvec, cos_omega_dt))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem">GaussianDenseConstrainedEuclideanMetricSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.GaussianEuclideanMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L367-L369" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h2(self, state):
    return (0.5 * state.pos @ state.pos +
            0.5 * state.mom @ self.metric.inv @ state.mom)</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L371-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;mom&#39;)
def dh2_dmom(self, state):
    return self.metric.inv @ state.mom</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh2_dpos"><code class="name flex">
<span>def <span class="ident">dh2_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L375-L377" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;mom&#39;)
def dh2_dpos(self, state):
    return state.pos</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.h2_flow"><code class="name flex">
<span>def <span class="ident">h2_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h2</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L379-L389" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h2_flow(self, state, dt):
    omega = 1. / self.metric.eigval**0.5
    sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
    eigvec_T_pos = self.metric.eigvec.T @ state.pos
    eigvec_T_mom = self.metric.eigvec.T @ state.mom
    state.pos = self.metric.eigvec @ (
        cos_omega_dt * eigvec_T_pos +
        (sin_omega_dt * omega) * eigvec_T_mom)
    state.mom = self.metric.eigvec @ (
        cos_omega_dt * eigvec_T_mom -
        (sin_omega_dt / omega) * eigvec_T_pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh2_flow_dmom"><code class="name flex">
<span>def <span class="ident">dh2_flow_dmom</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivatives of <code>h2_flow</code> flow map with respect to input momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval flow simulated for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dpos_dmom</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="matrices.html#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Matrix representing derivative
(Jacobian) of position output of <code>h2_flow</code> with respect to the
value of the momentum component of the initial input state.</dd>
<dt><strong><code>dmom_dmom</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="matrices.html#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Matrix representing derivative
(Jacobian) of momentum output of <code>h2_flow</code> with respect to the
value of the momentum component of the initial input state.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L391-L398" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh2_flow_dmom(self, dt):
    omega = 1. / self.metric.eigval**0.5
    sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
    return (
        EigendecomposedSymmetricMatrix(
            self.metric.eigvec, sin_omega_dt * omega),
        EigendecomposedSymmetricMatrix(
            self.metric.eigvec, cos_omega_dt))</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem"><code class="flex name class">
<span>class <span class="ident">ConstrainedEuclideanMetricSystem</span></span>
<span>(</span><span>neg_log_dens, constr, metric=None, dens_wrt_hausdorff=True, grad_neg_log_dens=None, jacob_constr=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for Euclidean Hamiltonian systems subject to constraints.</p>
<p>The (constrained) position space is assumed to be a differentiable manifold
embedded with a <span><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>-dimensional ambient Euclidean space. The <span><span class="MathJax_Preview">Q-C</span><script type="math/tex">Q-C</script></span>
dimensional manifold <span><span class="MathJax_Preview">\mathcal{M}</span><script type="math/tex">\mathcal{M}</script></span> is implicitly defined by an equation
<span><span class="MathJax_Preview">\mathcal{M} = \lbrace q \in \mathbb{R}^Q : c(q) = 0 \rbrace</span><script type="math/tex">\mathcal{M} = \lbrace q \in \mathbb{R}^Q : c(q) = 0 \rbrace</script></span> with
<span><span class="MathJax_Preview">c: \mathbb{R}^Q \to \mathbb{R}^C</span><script type="math/tex">c: \mathbb{R}^Q \to \mathbb{R}^C</script></span> the <em>constraint function</em>.</p>
<p>The ambient Euclidean space is assumed to be equipped with a metric with
constant positive-definite matrix representation <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> which further
specifies the covariance of the zero-mean Gaussian distribution
<span><span class="MathJax_Preview">\mathcal{N}(0, M)</span><script type="math/tex">\mathcal{N}(0, M)</script></span> on the <em>unconstrained</em> momentum (co-)vector <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>
with corresponding <span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> Hamiltonian component defined as</p>
<p><span><span class="MathJax_Preview"> h_2(q, p) = \frac{1}{2} p^T M^{-1} p. </span><script type="math/tex; mode=display"> h_2(q, p) = \frac{1}{2} p^T M^{-1} p. </script></span></p>
<p>The time-derivative of the constraint equation implies a further set of
constraints on the momentum <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> with <span><span class="MathJax_Preview"> \partial c(q) M^{-1} p = 0</span><script type="math/tex"> \partial c(q) M^{-1} p = 0</script></span>
at all time points, corresponding to the momentum (velocity) being in the
co-tangent space (tangent space) to the manifold.</p>
<p>The target distribution is either assumed to be directly specified with
unnormalised density <span><span class="MathJax_Preview">\exp(-\ell(q))</span><script type="math/tex">\exp(-\ell(q))</script></span> with respect to the Hausdorff
measure on the manifold (under the metric induced from the ambient metric)
with in this case the <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> Hamiltonian component then simply</p>
<p><span><span class="MathJax_Preview"> h_1(q) = \ell(q), </span><script type="math/tex; mode=display"> h_1(q) = \ell(q), </script></span></p>
<p>or alternatively it is assumed a prior distribution on the position <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>
with density <span><span class="MathJax_Preview">\exp(-\ell(q))</span><script type="math/tex">\exp(-\ell(q))</script></span> with respect to the Lebesgue measure on
the ambient space is specifed and the target distribution is the posterior
distribution on <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> when conditioning on the event <span><span class="MathJax_Preview">c(q) = 0</span><script type="math/tex">c(q) = 0</script></span>. The
negative logarithm of the posterior distribution density with respect to
the Hausdorff measure (and so <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> Hamiltonian component) is then</p>
<p><span><span class="MathJax_Preview">
h_1(q) =
\ell(q) + \frac{1}{2} \log\left|\partial c(q)M^{-1}\partial c(q)^T\right|
</span><script type="math/tex; mode=display">
h_1(q) =
\ell(q) + \frac{1}{2} \log\left|\partial c(q)M^{-1}\partial c(q)^T\right|
</script></span></p>
<p>with an additional second <em>Gram matrix</em> determinant term to give the
correct density with respect to the Hausdorff measure on the manifold.</p>
<p>Due to the requirement to enforce the constraints on the position and
momentum, a constraint-preserving numerical integrator needs to be used
when simulating the Hamiltonian dynamic associated with the system, e.g.
<a title="mici.integrators.ConstrainedLeapfrogIntegrator" href="integrators.html#mici.integrators.ConstrainedLeapfrogIntegrator"><code>ConstrainedLeapfrogIntegrator</code></a>.</p>
<h2 id="references">References</h2>
<ol>
<li>Lelivre, T., Rousset, M. and Stoltz, G., 2019. Hybrid Monte Carlo
methods for sampling probability measures on submanifolds. Numerische
Mathematik, 143(2), pp.379-421.</li>
<li>Graham, M.M. and Storkey, A.J., 2017. Asymptotically exact inference
in differentiable generative models. Electronic Journal of Statistics,
11(2), pp.5105-5164.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>
<p>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the constrained position
space with respect to the Hausdorff measure on the constraint
manifold (if <code>dens_wrt_hausdorff == True</code>) or alternatively the
negative logarithm of an unnormalised probability density on
the unconstrained (ambient) position space with respect to the
Lebesgue measure. In the former case the target distribution it
is wished to draw approximate samples from is assumed to be
directly specified by the density function on the manifold. In
the latter case the density function is instead taken to
specify a prior distribution on the ambient space with the
target distribution then corresponding to the posterior
distribution when conditioning on the (zero Lebesgue measure)
event <code>constr(pos) == 0</code>. This target posterior distribution
has support on the differentiable manifold implicitly defined
by the constraint equation, with density with respect to the
Hausdorff measure on the manifold corresponding to the ratio of
the prior density (specified by <code>neg_log_dens</code>) and the
square-root of the determinant of the Gram matrix defined by</p>
<pre><code>gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T
</code></pre>
<p>where <code>jacob_constr</code> is the Jacobian of the constraint function
<code>constr</code> and <code>metric</code> is the matrix representation of the
metric on the ambient space.</p>
</dd>
<dt><strong><code>constr</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>array</code>]</dt>
<dd>Function which given a position
array return as a 1D array the value of the (vector-valued)
constraint function, the zero level-set of which implicitly
defines the manifold the dynamic is simulated on.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>None</code> or <code>array</code> or <code>PositiveDefiniteMatrix</code></dt>
<dd>Matrix object
corresponding to matrix representation of metric on
<em>unconstrained</em> position space and covariance of Gaussian
marginal distribution on <em>unconstrained</em> momentum vector. If
<code>None</code> is passed (the default), the identity matrix will be
used. If a 1D array is passed then this is assumed to specify a
metric with positive diagonal matrix representation and the
array the matrix diagonal. If a 2D array is passed then this is
assumed to specify a metric with a dense positive definite
matrix representation specified by the array. Otherwise if the
value is a <a title="mici.matrices.PositiveDefiniteMatrix" href="matrices.html#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a> subclass it
is assumed to directly specify the metric matrix
representation.</dd>
<dt><strong><code>dens_wrt_hausdorff</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the <code>neg_log_dens</code> function
specifies the (negative logarithm) of the density of the target
distribution with respect to the Hausdorff measure on the
manifold directly (True) or alternatively the negative
logarithm of a density of a prior distriubtion on the
unconstrained (ambient) position space with respect to the
Lebesgue measure, with the target distribution then
corresponding to the posterior distribution when conditioning
on the event <code>const(pos) == 0</code> (False). Note that in the former
case the base Hausdorff measure on the manifold depends on the
metric defined on the ambient space, with the Hausdorff measure
being defined with respect to the metric induced on the
manifold from this ambient metric.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct a function to compute the derivative (and value)
of <code>neg_log_dens</code> automatically.</p>
</dd>
<dt><strong><code>jacob_constr</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>array</code>]]</dt>
<dd>
<p>Function which given a position array computes the Jacobian
(matrix / 2D array of partial derivatives) of the output of the
constraint function <code>c = constr(q)</code> with respect to the
position array argument <code>q</code>, returning the computed Jacobian as
a 2D array <code>jacob</code> with</p>
<pre><code>jacob[i, j] = c[i] / q[j]
</code></pre>
<p>Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the Jacobian
and the second being the value of <code>constr</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct a function to compute the Jacobian (and value) of
<code>constr</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L401-L686" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ConstrainedEuclideanMetricSystem(EuclideanMetricSystem):
    r&#34;&#34;&#34;Base class for Euclidean Hamiltonian systems subject to constraints.

    The (constrained) position space is assumed to be a differentiable manifold
    embedded with a \(Q\)-dimensional ambient Euclidean space. The \(Q-C\)
    dimensional manifold \(\mathcal{M}\) is implicitly defined by an equation
    \(\mathcal{M} = \lbrace q \in \mathbb{R}^Q : c(q) = 0 \rbrace\) with
    \(c: \mathbb{R}^Q \to \mathbb{R}^C\) the *constraint function*.

    The ambient Euclidean space is assumed to be equipped with a metric with
    constant positive-definite matrix representation \(M\) which further
    specifies the covariance of the zero-mean Gaussian distribution
    \(\mathcal{N}(0, M)\) on the *unconstrained* momentum (co-)vector \(p\)
    with corresponding \(h_2\) Hamiltonian component defined as

    \[ h_2(q, p) = \frac{1}{2} p^T M^{-1} p. \]

    The time-derivative of the constraint equation implies a further set of
    constraints on the momentum \(q\) with \( \partial c(q) M^{-1} p = 0\)
    at all time points, corresponding to the momentum (velocity) being in the
    co-tangent space (tangent space) to the manifold.

    The target distribution is either assumed to be directly specified with
    unnormalised density \(\exp(-\ell(q))\) with respect to the Hausdorff
    measure on the manifold (under the metric induced from the ambient metric)
    with in this case the \(h_1\) Hamiltonian component then simply

    \[ h_1(q) = \ell(q), \]

    or alternatively it is assumed a prior distribution on the position \(q\)
    with density \(\exp(-\ell(q))\) with respect to the Lebesgue measure on
    the ambient space is specifed and the target distribution is the posterior
    distribution on \(q\) when conditioning on the event \(c(q) = 0\). The
    negative logarithm of the posterior distribution density with respect to
    the Hausdorff measure (and so \(h_1\) Hamiltonian component) is then

    \[
      h_1(q) =
      \ell(q) + \frac{1}{2} \log\left|\partial c(q)M^{-1}\partial c(q)^T\right|
    \]

    with an additional second *Gram matrix* determinant term to give the
    correct density with respect to the Hausdorff measure on the manifold.

    Due to the requirement to enforce the constraints on the position and
    momentum, a constraint-preserving numerical integrator needs to be used
    when simulating the Hamiltonian dynamic associated with the system, e.g.
    `mici.integrators.ConstrainedLeapfrogIntegrator`.

    References:

      1. Lelivre, T., Rousset, M. and Stoltz, G., 2019. Hybrid Monte Carlo
         methods for sampling probability measures on submanifolds. Numerische
         Mathematik, 143(2), pp.379-421.
      2. Graham, M.M. and Storkey, A.J., 2017. Asymptotically exact inference
         in differentiable generative models. Electronic Journal of Statistics,
         11(2), pp.5105-5164.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, constr, metric=None,
                 dens_wrt_hausdorff=True, grad_neg_log_dens=None,
                 jacob_constr=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the constrained position
                space with respect to the Hausdorff measure on the constraint
                manifold (if `dens_wrt_hausdorff == True`) or alternatively the
                negative logarithm of an unnormalised probability density on
                the unconstrained (ambient) position space with respect to the
                Lebesgue measure. In the former case the target distribution it
                is wished to draw approximate samples from is assumed to be
                directly specified by the density function on the manifold. In
                the latter case the density function is instead taken to
                specify a prior distribution on the ambient space with the
                target distribution then corresponding to the posterior
                distribution when conditioning on the (zero Lebesgue measure)
                event `constr(pos) == 0`. This target posterior distribution
                has support on the differentiable manifold implicitly defined
                by the constraint equation, with density with respect to the
                Hausdorff measure on the manifold corresponding to the ratio of
                the prior density (specified by `neg_log_dens`) and the
                square-root of the determinant of the Gram matrix defined by

                    gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T

                where `jacob_constr` is the Jacobian of the constraint function
                `constr` and `metric` is the matrix representation of the
                metric on the ambient space.
            constr (Callable[[array], array]): Function which given a position
                array return as a 1D array the value of the (vector-valued)
                constraint function, the zero level-set of which implicitly
                defines the manifold the dynamic is simulated on.
            metric (None or array or PositiveDefiniteMatrix): Matrix object
                corresponding to matrix representation of metric on
                *unconstrained* position space and covariance of Gaussian
                marginal distribution on *unconstrained* momentum vector. If
                `None` is passed (the default), the identity matrix will be
                used. If a 1D array is passed then this is assumed to specify a
                metric with positive diagonal matrix representation and the
                array the matrix diagonal. If a 2D array is passed then this is
                assumed to specify a metric with a dense positive definite
                matrix representation specified by the array. Otherwise if the
                value is a `mici.matrices.PositiveDefiniteMatrix` subclass it
                is assumed to directly specify the metric matrix
                representation.
            dens_wrt_hausdorff (bool): Whether the `neg_log_dens` function
                specifies the (negative logarithm) of the density of the target
                distribution with respect to the Hausdorff measure on the
                manifold directly (True) or alternatively the negative
                logarithm of a density of a prior distriubtion on the
                unconstrained (ambient) position space with respect to the
                Lebesgue measure, with the target distribution then
                corresponding to the posterior distribution when conditioning
                on the event `const(pos) == 0` (False). Note that in the former
                case the base Hausdorff measure on the manifold depends on the
                metric defined on the ambient space, with the Hausdorff measure
                being defined with respect to the metric induced on the
                manifold from this ambient metric.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the derivative (and value)
                of `neg_log_dens` automatically.
            jacob_constr (
                    None or Callable[[array], array or Tuple[array, array]]):
                Function which given a position array computes the Jacobian
                (matrix / 2D array of partial derivatives) of the output of the
                constraint function `c = constr(q)` with respect to the
                position array argument `q`, returning the computed Jacobian as
                a 2D array `jacob` with

                    jacob[i, j] = c[i] / q[j]

                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the Jacobian
                and the second being the value of `constr` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the Jacobian (and value) of
                `constr` automatically.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens=neg_log_dens, metric=metric,
                         grad_neg_log_dens=grad_neg_log_dens)
        self._constr = constr
        self.dens_wrt_hausdorff = dens_wrt_hausdorff
        self._jacob_constr = autodiff_fallback(
            jacob_constr, constr, &#39;jacobian_and_value&#39;, &#39;jacob_constr&#39;)

    @cache_in_state(&#39;pos&#39;)
    def constr(self, state):
        &#34;&#34;&#34;Constraint function at the current position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `constr(state.pos)` as 1D array.
        &#34;&#34;&#34;
        return self._constr(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;jacob_constr&#39;, &#39;constr&#39;])
    def jacob_constr(self, state):
        &#34;&#34;&#34;Jacobian of constraint function at the current position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of Jacobian of `constr(state.pos)` as 2D array.
        &#34;&#34;&#34;
        return self._jacob_constr(state.pos)

    @abstractmethod
    def jacob_constr_inner_product(
            self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
        &#34;&#34;&#34;Compute inner product of rows of constraint Jacobian matrices.

        Computes `jacob_constr_1 @ inner_product_matrix @ jacob_constr_2.T`
        potentially exploiting any structure / sparsity in `jacob_constr_1`,
        `jacob_constr_2` and `inner_product_matrix`.

        Args:
            jacob_constr_1 (Matrix): First constraint Jacobian in product.
            inner_product_matrix (Matrix): Positive-definite matrix defining
                inner-product between rows of two constraint Jacobians.
            jacob_constr_2 (None or Matrix): Second constraint Jacobian in
                product. Defaults to `jacob_constr_1` if set to `None`.

        Returns
            Matrix: Object corresponding to computed inner products of
               the constraint Jacobian rows.
        &#34;&#34;&#34;

    @cache_in_state(&#39;pos&#39;)
    def gram(self, state):
        &#34;&#34;&#34;Gram matrix at current position.

        The Gram matrix as a position `q` is defined as

            gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T

        where `jacob_constr` is the Jacobian of the constraint function
        `constr` and `metric` is the matrix representation of the metric on the
        ambient space.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            mici.matrice.PositiveDefiniteMatrix: Gram matrix as matrix object.
        &#34;&#34;&#34;
        return self.jacob_constr_inner_product(
            self.jacob_constr(state), self.metric.inv)

    def inv_gram(self, state):
        &#34;&#34;&#34;Inverse of Gram matrix at current position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            mici.matrices.PositiveDefiniteMatrix: Inverse of Gram matrix as
                matrix object.
        &#34;&#34;&#34;
        return self.gram(state).inv

    def log_det_sqrt_gram(self, state):
        &#34;&#34;&#34;Value of (half of) log-determinant of Gram matrix.&#34;&#34;&#34;
        return 0.5 * self.gram(state).log_abs_det

    @abstractmethod
    def grad_log_det_sqrt_gram(self, state):
        &#34;&#34;&#34;Derivative of (half of) log-determinant of Gram matrix wrt position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `log_det_sqrt_gram(state)` derivative with respect
                to `state.pos`.
        &#34;&#34;&#34;

    def h1(self, state):
        if self.dens_wrt_hausdorff:
            return self.neg_log_dens(state)
        else:
            return self.neg_log_dens(state) + self.log_det_sqrt_gram(state)

    def dh1_dpos(self, state):
        if self.dens_wrt_hausdorff:
            return self.grad_neg_log_dens(state)
        else:
            return (self.grad_neg_log_dens(state) +
                    self.grad_log_det_sqrt_gram(state))

    def project_onto_cotangent_space(self, mom, state):
        &#34;&#34;&#34;Project a momentum on to the co-tangent space at a position.

        Args:
            mom (array): Momentum (co-)vector as 1D array to project on to
                co-tangent space.
            state (mici.states.ChainState): State definining position on the
                manifold to project in to the co-tangent space of.

        Returns:
            array: Projected momentum in the co-tangent space at `state.pos`.
        &#34;&#34;&#34;
        # Use parenthesis to force right-to-left evaluation to avoid
        # matrix-matrix products
        mom -= (self.jacob_constr(state).T @ (
                    self.inv_gram(state) @ (
                        self.jacob_constr(state) @ (self.metric.inv @ mom))))
        return mom

    def sample_momentum(self, state, rng):
        mom = super().sample_momentum(state, rng)
        mom = self.project_onto_cotangent_space(mom, state)
        return mom</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.DenseConstrainedEuclideanMetricSystem" href="#mici.systems.DenseConstrainedEuclideanMetricSystem">DenseConstrainedEuclideanMetricSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Constraint function at the current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>constr(state.pos)</code> as 1D array.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L557-L567" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def constr(self, state):
    &#34;&#34;&#34;Constraint function at the current position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `constr(state.pos)` as 1D array.
    &#34;&#34;&#34;
    return self._constr(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.jacob_constr"><code class="name flex">
<span>def <span class="ident">jacob_constr</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Jacobian of constraint function at the current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of Jacobian of <code>constr(state.pos)</code> as 2D array.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L569-L579" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state([&#39;pos&#39;], [&#39;jacob_constr&#39;, &#39;constr&#39;])
def jacob_constr(self, state):
    &#34;&#34;&#34;Jacobian of constraint function at the current position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of Jacobian of `constr(state.pos)` as 2D array.
    &#34;&#34;&#34;
    return self._jacob_constr(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.jacob_constr_inner_product"><code class="name flex">
<span>def <span class="ident">jacob_constr_inner_product</span></span>(<span>self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute inner product of rows of constraint Jacobian matrices.</p>
<p>Computes <code>jacob_constr_1 @ inner_product_matrix @ jacob_constr_2.T</code>
potentially exploiting any structure / sparsity in <code>jacob_constr_1</code>,
<code>jacob_constr_2</code> and <code>inner_product_matrix</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>jacob_constr_1</code></strong> :&ensp;<code>Matrix</code></dt>
<dd>First constraint Jacobian in product.</dd>
<dt><strong><code>inner_product_matrix</code></strong> :&ensp;<code>Matrix</code></dt>
<dd>Positive-definite matrix defining
inner-product between rows of two constraint Jacobians.</dd>
<dt><strong><code>jacob_constr_2</code></strong> :&ensp;<code>None</code> or <code>Matrix</code></dt>
<dd>Second constraint Jacobian in
product. Defaults to <code>jacob_constr_1</code> if set to <code>None</code>.</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>Matrix: Object corresponding to computed inner products of
the constraint Jacobian rows.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L581-L600" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def jacob_constr_inner_product(
        self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
    &#34;&#34;&#34;Compute inner product of rows of constraint Jacobian matrices.

    Computes `jacob_constr_1 @ inner_product_matrix @ jacob_constr_2.T`
    potentially exploiting any structure / sparsity in `jacob_constr_1`,
    `jacob_constr_2` and `inner_product_matrix`.

    Args:
        jacob_constr_1 (Matrix): First constraint Jacobian in product.
        inner_product_matrix (Matrix): Positive-definite matrix defining
            inner-product between rows of two constraint Jacobians.
        jacob_constr_2 (None or Matrix): Second constraint Jacobian in
            product. Defaults to `jacob_constr_1` if set to `None`.

    Returns
        Matrix: Object corresponding to computed inner products of
           the constraint Jacobian rows.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.gram"><code class="name flex">
<span>def <span class="ident">gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Gram matrix at current position.</p>
<p>The Gram matrix as a position <code>q</code> is defined as</p>
<pre><code>gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T
</code></pre>
<p>where <code>jacob_constr</code> is the Jacobian of the constraint function
<code>constr</code> and <code>metric</code> is the matrix representation of the metric on the
ambient space.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>mici.matrice.PositiveDefiniteMatrix: Gram matrix as matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L602-L621" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def gram(self, state):
    &#34;&#34;&#34;Gram matrix at current position.

    The Gram matrix as a position `q` is defined as

        gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T

    where `jacob_constr` is the Jacobian of the constraint function
    `constr` and `metric` is the matrix representation of the metric on the
    ambient space.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        mici.matrice.PositiveDefiniteMatrix: Gram matrix as matrix object.
    &#34;&#34;&#34;
    return self.jacob_constr_inner_product(
        self.jacob_constr(state), self.metric.inv)</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.inv_gram"><code class="name flex">
<span>def <span class="ident">inv_gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Inverse of Gram matrix at current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="mici.matrices.PositiveDefiniteMatrix" href="matrices.html#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a>: <code>Inverse</code> of <code>Gram</code> <code>matrix</code> <code>as</code></dt>
<dd>matrix object.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L623-L633" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def inv_gram(self, state):
    &#34;&#34;&#34;Inverse of Gram matrix at current position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        mici.matrices.PositiveDefiniteMatrix: Inverse of Gram matrix as
            matrix object.
    &#34;&#34;&#34;
    return self.gram(state).inv</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.log_det_sqrt_gram"><code class="name flex">
<span>def <span class="ident">log_det_sqrt_gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Value of (half of) log-determinant of Gram matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L635-L637" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_det_sqrt_gram(self, state):
    &#34;&#34;&#34;Value of (half of) log-determinant of Gram matrix.&#34;&#34;&#34;
    return 0.5 * self.gram(state).log_abs_det</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram"><code class="name flex">
<span>def <span class="ident">grad_log_det_sqrt_gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of (half of) log-determinant of Gram matrix wrt position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>log_det_sqrt_gram(state)</code> derivative with respect
to <code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L639-L649" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def grad_log_det_sqrt_gram(self, state):
    &#34;&#34;&#34;Derivative of (half of) log-determinant of Gram matrix wrt position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `log_det_sqrt_gram(state)` derivative with respect
            to `state.pos`.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L651-L655" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h1(self, state):
    if self.dens_wrt_hausdorff:
        return self.neg_log_dens(state)
    else:
        return self.neg_log_dens(state) + self.log_det_sqrt_gram(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L657-L662" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh1_dpos(self, state):
    if self.dens_wrt_hausdorff:
        return self.grad_neg_log_dens(state)
    else:
        return (self.grad_neg_log_dens(state) +
                self.grad_log_det_sqrt_gram(state))</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.project_onto_cotangent_space"><code class="name flex">
<span>def <span class="ident">project_onto_cotangent_space</span></span>(<span>self, mom, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Project a momentum on to the co-tangent space at a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Momentum (co-)vector as 1D array to project on to
co-tangent space.</dd>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State definining position on the
manifold to project in to the co-tangent space of.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Projected momentum in the co-tangent space at <code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L664-L681" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def project_onto_cotangent_space(self, mom, state):
    &#34;&#34;&#34;Project a momentum on to the co-tangent space at a position.

    Args:
        mom (array): Momentum (co-)vector as 1D array to project on to
            co-tangent space.
        state (mici.states.ChainState): State definining position on the
            manifold to project in to the co-tangent space of.

    Returns:
        array: Projected momentum in the co-tangent space at `state.pos`.
    &#34;&#34;&#34;
    # Use parenthesis to force right-to-left evaluation to avoid
    # matrix-matrix products
    mom -= (self.jacob_constr(state).T @ (
                self.inv_gram(state) @ (
                    self.jacob_constr(state) @ (self.metric.inv @ mom))))
    return mom</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L683-L686" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample_momentum(self, state, rng):
    mom = super().sample_momentum(state, rng)
    mom = self.project_onto_cotangent_space(mom, state)
    return mom</code></pre>
</details>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.h2_flow"><code class="name flex">
<span>def <span class="ident">h2_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h2</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.dh2_flow_dmom"><code class="name flex">
<span>def <span class="ident">dh2_flow_dmom</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivatives of <code>h2_flow</code> flow map with respect to input momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval flow simulated for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dpos_dmom</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="matrices.html#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Matrix representing derivative
(Jacobian) of position output of <code>h2_flow</code> with respect to the
value of the momentum component of the initial input state.</dd>
<dt><strong><code>dmom_dmom</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="matrices.html#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Matrix representing derivative
(Jacobian) of momentum output of <code>h2_flow</code> with respect to the
value of the momentum component of the initial input state.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ConstrainedEuclideanMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem"><code class="flex name class">
<span>class <span class="ident">DenseConstrainedEuclideanMetricSystem</span></span>
<span>(</span><span>neg_log_dens, constr, metric=None, dens_wrt_hausdorff=True, grad_neg_log_dens=None, jacob_constr=None, mhp_constr=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Euclidean Hamiltonian system subject to a dense set of constraints.</p>
<p>See <a title="mici.systems.ConstrainedEuclideanMetricSystem" href="#mici.systems.ConstrainedEuclideanMetricSystem"><code>ConstrainedEuclideanMetricSystem</code></a> for more details about constrained
systems.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>
<p>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the constrained position
space with respect to the Hausdorff measure on the constraint
manifold (if <code>dens_wrt_hausdorff == True</code>) or alternatively the
negative logarithm of an unnormalised probability density on
the unconstrained (ambient) position space with respect to the
Lebesgue measure. In the former case the target distribution it
is wished to draw approximate samples from is assumed to be
directly specified by the density function on the manifold. In
the latter case the density function is instead taken to
specify a prior distribution on the ambient space with the
target distribution then corresponding to the posterior
distribution when conditioning on the (zero Lebesgue measure)
event <code>constr(pos) == 0</code>. This target posterior distribution
has support on the differentiable manifold implicitly defined
by the constraint equation, with density with respect to the
Hausdorff measure on the manifold corresponding to the ratio of
the prior density (specified by <code>neg_log_dens</code>) and the
square-root of the determinant of the Gram matrix defined by</p>
<pre><code>gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T
</code></pre>
<p>where <code>jacob_constr</code> is the Jacobian of the constraint function
<code>constr</code> and <code>metric</code> is the matrix representation of the
metric on the ambient space.</p>
</dd>
<dt><strong><code>constr</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>array</code>]</dt>
<dd>Function which given a position
array return as a 1D array the value of the (vector-valued)
constraint function, the zero level-set of which implicitly
defines the manifold the dynamic is simulated on.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>None</code> or <code>array</code> or <code>PositiveDefiniteMatrix</code></dt>
<dd>Matrix object
corresponding to matrix representation of metric on
<em>unconstrained</em> position space and covariance of Gaussian
marginal distribution on <em>unconstrained</em> momentum vector. If
<code>None</code> is passed (the default), the identity matrix will be
used. If a 1D array is passed then this is assumed to specify a
metric with positive diagonal matrix representation and the
array the matrix diagonal. If a 2D array is passed then this is
assumed to specify a metric with a dense positive definite
matrix representation specified by the array. Otherwise if the
value is a <a title="mici.matrices.PositiveDefiniteMatrix" href="matrices.html#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a> subclass it
is assumed to directly specify the metric matrix
representation.</dd>
<dt><strong><code>dens_wrt_hausdorff</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the <code>neg_log_dens</code> function
specifies the (negative logarithm) of the density of the target
distribution with respect to the Hausdorff measure on the
manifold directly (True) or alternatively the negative
logarithm of a density of a prior distriubtion on the
unconstrained (ambient) position space with respect to the
Lebesgue measure, with the target distribution then
corresponding to the posterior distribution when conditioning
on the event <code>const(pos) == 0</code> (False). Note that in the former
case the base Hausdorff measure on the manifold depends on the
metric defined on the ambient space, with the Hausdorff measure
being defined with respect to the metric induced on the
manifold from this ambient metric.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct a function to compute the derivative (and value)
of <code>neg_log_dens</code> automatically.</p>
</dd>
<dt><strong><code>jacob_constr</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>array</code>]]</dt>
<dd>
<p>Function which given a position array computes the Jacobian
(matrix / 2D array of partial derivatives) of the output of the
constraint function <code>c = constr(q)</code> with respect to the
position array argument <code>q</code>, returning the computed Jacobian as
a 2D array <code>jacob</code> with</p>
<pre><code>jacob[i, j] = c[i] / q[j]
</code></pre>
<p>Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the Jacobian
and the second being the value of <code>constr</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct a function to compute the Jacobian (and value) of
<code>neg_log_dens</code> automatically.</p>
</dd>
<dt><strong><code>mhp_constr</code></strong> :&ensp;<code>None</code> or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Callable</code>[[<code>array</code>], <code>array</code>]] or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Tuple</code>[<code>Callable</code>, <code>array</code>, <code>array</code>]]</dt>
<dd>
<p>Function which given a position array returns another function
which takes a 2D array as an argument and returns the
<em>matrix-Hessian-product</em> (MHP) of the constraint function
<code>constr</code> with respect to the position array argument. The MHP
is here defined as a function of a <code>(dim_constr, dim_pos)</code>
shaped 2D array <code>m</code></p>
<pre><code>mhp(m) = sum(m[:, :, None] * hess[:, :, :], axis=(0, 1))
</code></pre>
<p>where <code>hess</code> is the <code>(dim_constr, dim_pos, dim_pos)</code> shaped
vector-Hessian of <code>c = constr(q)</code> with respect to <code>q</code> i.e. the
array of second-order partial derivatives of such that</p>
<pre><code>hess[i, j, k] = c[i] / (q[j] q[k])
</code></pre>
<p>Optionally the function may instead return a 3-tuple of values
with the first a function to compute a MHP of <code>constr</code>, the
second a 2D array corresponding to the Jacobian of <code>constr</code>,
and the third the value of <code>constr</code>, all evaluated at the
passed position array. If <code>None</code> is passed (the default) an
automatic differentiation fallback will be used to attempt to
construct a function which calculates the MHP (and Jacobian and
value) of <code>constr</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L689-L840" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DenseConstrainedEuclideanMetricSystem(ConstrainedEuclideanMetricSystem):
    r&#34;&#34;&#34;Euclidean Hamiltonian system subject to a dense set of constraints.

    See `ConstrainedEuclideanMetricSystem` for more details about constrained
    systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, constr, metric=None,
                 dens_wrt_hausdorff=True, grad_neg_log_dens=None,
                 jacob_constr=None, mhp_constr=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the constrained position
                space with respect to the Hausdorff measure on the constraint
                manifold (if `dens_wrt_hausdorff == True`) or alternatively the
                negative logarithm of an unnormalised probability density on
                the unconstrained (ambient) position space with respect to the
                Lebesgue measure. In the former case the target distribution it
                is wished to draw approximate samples from is assumed to be
                directly specified by the density function on the manifold. In
                the latter case the density function is instead taken to
                specify a prior distribution on the ambient space with the
                target distribution then corresponding to the posterior
                distribution when conditioning on the (zero Lebesgue measure)
                event `constr(pos) == 0`. This target posterior distribution
                has support on the differentiable manifold implicitly defined
                by the constraint equation, with density with respect to the
                Hausdorff measure on the manifold corresponding to the ratio of
                the prior density (specified by `neg_log_dens`) and the
                square-root of the determinant of the Gram matrix defined by

                    gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T

                where `jacob_constr` is the Jacobian of the constraint function
                `constr` and `metric` is the matrix representation of the
                metric on the ambient space.
            constr (Callable[[array], array]): Function which given a position
                array return as a 1D array the value of the (vector-valued)
                constraint function, the zero level-set of which implicitly
                defines the manifold the dynamic is simulated on.
            metric (None or array or PositiveDefiniteMatrix): Matrix object
                corresponding to matrix representation of metric on
                *unconstrained* position space and covariance of Gaussian
                marginal distribution on *unconstrained* momentum vector. If
                `None` is passed (the default), the identity matrix will be
                used. If a 1D array is passed then this is assumed to specify a
                metric with positive diagonal matrix representation and the
                array the matrix diagonal. If a 2D array is passed then this is
                assumed to specify a metric with a dense positive definite
                matrix representation specified by the array. Otherwise if the
                value is a `mici.matrices.PositiveDefiniteMatrix` subclass it
                is assumed to directly specify the metric matrix
                representation.
            dens_wrt_hausdorff (bool): Whether the `neg_log_dens` function
                specifies the (negative logarithm) of the density of the target
                distribution with respect to the Hausdorff measure on the
                manifold directly (True) or alternatively the negative
                logarithm of a density of a prior distriubtion on the
                unconstrained (ambient) position space with respect to the
                Lebesgue measure, with the target distribution then
                corresponding to the posterior distribution when conditioning
                on the event `const(pos) == 0` (False). Note that in the former
                case the base Hausdorff measure on the manifold depends on the
                metric defined on the ambient space, with the Hausdorff measure
                being defined with respect to the metric induced on the
                manifold from this ambient metric.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the derivative (and value)
                of `neg_log_dens` automatically.
            jacob_constr (
                    None or Callable[[array], array or Tuple[array, array]]):
                Function which given a position array computes the Jacobian
                (matrix / 2D array of partial derivatives) of the output of the
                constraint function `c = constr(q)` with respect to the
                position array argument `q`, returning the computed Jacobian as
                a 2D array `jacob` with

                    jacob[i, j] = c[i] / q[j]

                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the Jacobian
                and the second being the value of `constr` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the Jacobian (and value) of
                `neg_log_dens` automatically.
            mhp_constr (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable, array, array]]):
                Function which given a position array returns another function
                which takes a 2D array as an argument and returns the
                *matrix-Hessian-product* (MHP) of the constraint function
                `constr` with respect to the position array argument. The MHP
                is here defined as a function of a `(dim_constr, dim_pos)`
                shaped 2D array `m`

                    mhp(m) = sum(m[:, :, None] * hess[:, :, :], axis=(0, 1))

                where `hess` is the `(dim_constr, dim_pos, dim_pos)` shaped
                vector-Hessian of `c = constr(q)` with respect to `q` i.e. the
                array of second-order partial derivatives of such that

                    hess[i, j, k] = c[i] / (q[j] q[k])

                Optionally the function may instead return a 3-tuple of values
                with the first a function to compute a MHP of `constr`, the
                second a 2D array corresponding to the Jacobian of `constr`,
                and the third the value of `constr`, all evaluated at the
                passed position array. If `None` is passed (the default) an
                automatic differentiation fallback will be used to attempt to
                construct a function which calculates the MHP (and Jacobian and
                value) of `constr` automatically.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens=neg_log_dens, constr=constr,
                         metric=metric, dens_wrt_hausdorff=dens_wrt_hausdorff,
                         grad_neg_log_dens=grad_neg_log_dens,
                         jacob_constr=jacob_constr)
        if not dens_wrt_hausdorff:
            self._mhp_constr = autodiff_fallback(
                mhp_constr, constr, &#39;mhp_jacobian_and_value&#39;, &#39;mhp_constr&#39;)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;mhp_constr&#39;, &#39;jacob_constr&#39;, &#39;constr&#39;])
    def mhp_constr(self, state):
        return self._mhp_constr(state.pos)

    def jacob_constr_inner_product(
            self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
        if jacob_constr_2 is None or jacob_constr_2 is jacob_constr_1:
            return DensePositiveDefiniteMatrix(
                jacob_constr_1 @ (inner_product_matrix @ jacob_constr_1.T))
        else:
            return DenseSquareMatrix(
                jacob_constr_1 @ (inner_product_matrix @ jacob_constr_2.T))

    @cache_in_state(&#39;pos&#39;)
    def grad_log_det_sqrt_gram(self, state):
        # Evaluate MHP of constraint function before Jacobian as Jacobian value
        # will potentially be computed in &#39;forward&#39; pass and cached
        mhp_constr = self.mhp_constr(state)
        return mhp_constr(
            self.inv_gram(state) @ self.jacob_constr(state) @ self.metric.inv)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.ConstrainedEuclideanMetricSystem" href="#mici.systems.ConstrainedEuclideanMetricSystem">ConstrainedEuclideanMetricSystem</a></li>
<li><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem">GaussianDenseConstrainedEuclideanMetricSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.mhp_constr"><code class="name flex">
<span>def <span class="ident">mhp_constr</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L820-L823" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state(
    [&#39;pos&#39;], [&#39;mhp_constr&#39;, &#39;jacob_constr&#39;, &#39;constr&#39;])
def mhp_constr(self, state):
    return self._mhp_constr(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.jacob_constr_inner_product"><code class="name flex">
<span>def <span class="ident">jacob_constr_inner_product</span></span>(<span>self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute inner product of rows of constraint Jacobian matrices.</p>
<p>Computes <code>jacob_constr_1 @ inner_product_matrix @ jacob_constr_2.T</code>
potentially exploiting any structure / sparsity in <code>jacob_constr_1</code>,
<code>jacob_constr_2</code> and <code>inner_product_matrix</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>jacob_constr_1</code></strong> :&ensp;<code>Matrix</code></dt>
<dd>First constraint Jacobian in product.</dd>
<dt><strong><code>inner_product_matrix</code></strong> :&ensp;<code>Matrix</code></dt>
<dd>Positive-definite matrix defining
inner-product between rows of two constraint Jacobians.</dd>
<dt><strong><code>jacob_constr_2</code></strong> :&ensp;<code>None</code> or <code>Matrix</code></dt>
<dd>Second constraint Jacobian in
product. Defaults to <code>jacob_constr_1</code> if set to <code>None</code>.</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>Matrix: Object corresponding to computed inner products of
the constraint Jacobian rows.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L825-L832" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def jacob_constr_inner_product(
        self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
    if jacob_constr_2 is None or jacob_constr_2 is jacob_constr_1:
        return DensePositiveDefiniteMatrix(
            jacob_constr_1 @ (inner_product_matrix @ jacob_constr_1.T))
    else:
        return DenseSquareMatrix(
            jacob_constr_1 @ (inner_product_matrix @ jacob_constr_2.T))</code></pre>
</details>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram"><code class="name flex">
<span>def <span class="ident">grad_log_det_sqrt_gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of (half of) log-determinant of Gram matrix wrt position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>log_det_sqrt_gram(state)</code> derivative with respect
to <code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L834-L840" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def grad_log_det_sqrt_gram(self, state):
    # Evaluate MHP of constraint function before Jacobian as Jacobian value
    # will potentially be computed in &#39;forward&#39; pass and cached
    mhp_constr = self.mhp_constr(state)
    return mhp_constr(
        self.inv_gram(state) @ self.jacob_constr(state) @ self.metric.inv)</code></pre>
</details>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Constraint function at the current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>constr(state.pos)</code> as 1D array.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.jacob_constr"><code class="name flex">
<span>def <span class="ident">jacob_constr</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Jacobian of constraint function at the current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of Jacobian of <code>constr(state.pos)</code> as 2D array.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.gram"><code class="name flex">
<span>def <span class="ident">gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Gram matrix at current position.</p>
<p>The Gram matrix as a position <code>q</code> is defined as</p>
<pre><code>gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T
</code></pre>
<p>where <code>jacob_constr</code> is the Jacobian of the constraint function
<code>constr</code> and <code>metric</code> is the matrix representation of the metric on the
ambient space.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>mici.matrice.PositiveDefiniteMatrix: Gram matrix as matrix object.</p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.inv_gram"><code class="name flex">
<span>def <span class="ident">inv_gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Inverse of Gram matrix at current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="mici.matrices.PositiveDefiniteMatrix" href="matrices.html#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a>: <code>Inverse</code> of <code>Gram</code> <code>matrix</code> <code>as</code></dt>
<dd>matrix object.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.log_det_sqrt_gram"><code class="name flex">
<span>def <span class="ident">log_det_sqrt_gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Value of (half of) log-determinant of Gram matrix.</p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.project_onto_cotangent_space"><code class="name flex">
<span>def <span class="ident">project_onto_cotangent_space</span></span>(<span>self, mom, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Project a momentum on to the co-tangent space at a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Momentum (co-)vector as 1D array to project on to
co-tangent space.</dd>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State definining position on the
manifold to project in to the co-tangent space of.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Projected momentum in the co-tangent space at <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.h2_flow"><code class="name flex">
<span>def <span class="ident">h2_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h2</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_flow_dmom"><code class="name flex">
<span>def <span class="ident">dh2_flow_dmom</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivatives of <code>h2_flow</code> flow map with respect to input momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval flow simulated for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dpos_dmom</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="matrices.html#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Matrix representing derivative
(Jacobian) of position output of <code>h2_flow</code> with respect to the
value of the momentum component of the initial input state.</dd>
<dt><strong><code>dmom_dmom</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="matrices.html#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Matrix representing derivative
(Jacobian) of momentum output of <code>h2_flow</code> with respect to the
value of the momentum component of the initial input state.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem"><code class="flex name class">
<span>class <span class="ident">GaussianDenseConstrainedEuclideanMetricSystem</span></span>
<span>(</span><span>neg_log_dens, constr, metric=None, grad_neg_log_dens=None, jacob_constr=None, mhp_constr=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Gaussian Euclidean Hamiltonian system st. a dense set of constraints.</p>
<p>See <a title="mici.systems.ConstrainedEuclideanMetricSystem" href="#mici.systems.ConstrainedEuclideanMetricSystem"><code>ConstrainedEuclideanMetricSystem</code></a> for more details about constrained
systems and <a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem"><code>GaussianEuclideanMetricSystem</code></a> for Gaussian Euclidean metric
systems.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>
<p>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the unconstrained (ambient)
position space with respect to the standard Gaussian measure.
The density function is taken to specify a prior distribution
on the ambient space with the target distribution then
corresponding to the posterior distribution when conditioning
on the (zero Lebesgue measure) event <code>constr(pos) == 0</code>. This
target posterior distribution has support on the differentiable
manifold implicitly defined by the constraint equation, with
density with respect to the Hausdorff measure on the manifold
corresponding to the ratio of the prior density (specified by
<code>neg_log_dens</code>) and the square-root of the determinant of the
Gram matrix defined by</p>
<pre><code>gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T
</code></pre>
<p>where <code>jacob_constr</code> is the Jacobian of the constraint function
<code>constr</code> and <code>metric</code> is the matrix representation of the
metric on the ambient space.</p>
</dd>
<dt><strong><code>constr</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>array</code>]</dt>
<dd>Function which given a position
array return as a 1D array the value of the (vector-valued)
constraint function, the zero level-set of which implicitly
defines the manifold the dynamic is simulated on.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>None</code> or <code>array</code> or <code>PositiveDefiniteMatrix</code></dt>
<dd>Matrix object
corresponding to matrix representation of metric on
<em>unconstrained</em> position space and covariance of Gaussian
marginal distribution on <em>unconstrained</em> momentum vector. If
<code>None</code> is passed (the default), the identity matrix will be
used. If a 1D array is passed then this is assumed to specify a
metric with positive diagonal matrix representation and the
array the matrix diagonal. If a 2D array is passed then this is
assumed to specify a metric with a dense positive definite
matrix representation specified by the array. Otherwise if
a subclass of <a title="mici.matrices.PositiveDefiniteMatrix" href="matrices.html#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a> it is
assumed to directly specify the metric matrix representation.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct a function to compute the derivative (and value)
of <code>neg_log_dens</code> automatically.</p>
</dd>
<dt><strong><code>jacob_constr</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>array</code>]]</dt>
<dd>
<p>Function which given a position array computes the Jacobian
(matrix / 2D array of partial derivatives) of the output of the
constraint function <code>c = constr(q)</code> with respect to the
position array argument <code>q</code>, returning the computed Jacobian as
a 2D array <code>jacob</code> with</p>
<pre><code>jacob[i, j] = c[i] / q[j]
</code></pre>
<p>Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the Jacobian
and the second being the value of <code>constr</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct a function to compute the Jacobian (and value) of
<code>neg_log_dens</code> automatically.</p>
</dd>
<dt><strong><code>mhp_constr</code></strong> :&ensp;<code>None</code> or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Callable</code>[[<code>array</code>], <code>array</code>]] or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Tuple</code>[<code>Callable</code>, <code>array</code>, <code>array</code>]]</dt>
<dd>
<p>Function which given a position array returns another function
which takes a 2D array as an argument and returns the
<em>matrix-Hessian-product</em> (MHP) of the constraint function
<code>constr</code> with respect to the position array argument. The MHP
is here defined as a function of a <code>(dim_constr, dim_pos)</code>
shaped 2D array <code>m</code></p>
<pre><code>mhp(m) = sum(m[:, :, None] * hess[:, :, :], axis=(0, 1))
</code></pre>
<p>where <code>hess</code> is the <code>(dim_constr, dim_pos, dim_pos)</code> shaped
vector-Hessian of <code>c = constr(q)</code> with respect to <code>q</code> i.e. the
array of second-order partial derivatives of such that</p>
<pre><code>hess[i, j, k] = c[i] / (q[j] q[k])
</code></pre>
<p>Optionally the function may instead return a 3-tuple of values
with the first a function to compute a MHP of <code>constr</code>, the
second a 2D array corresponding to the Jacobian of <code>constr</code>,
and the third the value of <code>constr</code>, all evaluated at the
passed position array. If <code>None</code> is passed (the default) an
automatic differentiation fallback will be used to attempt to
construct a function which calculates the MHP (and Jacobian and
value) of <code>constr</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L843-L960" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GaussianDenseConstrainedEuclideanMetricSystem(
        GaussianEuclideanMetricSystem, DenseConstrainedEuclideanMetricSystem):
    r&#34;&#34;&#34;Gaussian Euclidean Hamiltonian system st. a dense set of constraints.

    See `ConstrainedEuclideanMetricSystem` for more details about constrained
    systems and `GaussianEuclideanMetricSystem` for Gaussian Euclidean metric
    systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, constr, metric=None,
                 grad_neg_log_dens=None, jacob_constr=None, mhp_constr=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the unconstrained (ambient)
                position space with respect to the standard Gaussian measure.
                The density function is taken to specify a prior distribution
                on the ambient space with the target distribution then
                corresponding to the posterior distribution when conditioning
                on the (zero Lebesgue measure) event `constr(pos) == 0`. This
                target posterior distribution has support on the differentiable
                manifold implicitly defined by the constraint equation, with
                density with respect to the Hausdorff measure on the manifold
                corresponding to the ratio of the prior density (specified by
                `neg_log_dens`) and the square-root of the determinant of the
                Gram matrix defined by

                    gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T

                where `jacob_constr` is the Jacobian of the constraint function
                `constr` and `metric` is the matrix representation of the
                metric on the ambient space.
            constr (Callable[[array], array]): Function which given a position
                array return as a 1D array the value of the (vector-valued)
                constraint function, the zero level-set of which implicitly
                defines the manifold the dynamic is simulated on.
            metric (None or array or PositiveDefiniteMatrix): Matrix object
                corresponding to matrix representation of metric on
                *unconstrained* position space and covariance of Gaussian
                marginal distribution on *unconstrained* momentum vector. If
                `None` is passed (the default), the identity matrix will be
                used. If a 1D array is passed then this is assumed to specify a
                metric with positive diagonal matrix representation and the
                array the matrix diagonal. If a 2D array is passed then this is
                assumed to specify a metric with a dense positive definite
                matrix representation specified by the array. Otherwise if
                a subclass of `mici.matrices.PositiveDefiniteMatrix` it is
                assumed to directly specify the metric matrix representation.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the derivative (and value)
                of `neg_log_dens` automatically.
            jacob_constr (
                    None or Callable[[array], array or Tuple[array, array]]):
                Function which given a position array computes the Jacobian
                (matrix / 2D array of partial derivatives) of the output of the
                constraint function `c = constr(q)` with respect to the
                position array argument `q`, returning the computed Jacobian as
                a 2D array `jacob` with

                    jacob[i, j] = c[i] / q[j]

                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the Jacobian
                and the second being the value of `constr` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct a function to compute the Jacobian (and value) of
                `neg_log_dens` automatically.
            mhp_constr (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable, array, array]]):
                Function which given a position array returns another function
                which takes a 2D array as an argument and returns the
                *matrix-Hessian-product* (MHP) of the constraint function
                `constr` with respect to the position array argument. The MHP
                is here defined as a function of a `(dim_constr, dim_pos)`
                shaped 2D array `m`

                    mhp(m) = sum(m[:, :, None] * hess[:, :, :], axis=(0, 1))

                where `hess` is the `(dim_constr, dim_pos, dim_pos)` shaped
                vector-Hessian of `c = constr(q)` with respect to `q` i.e. the
                array of second-order partial derivatives of such that

                    hess[i, j, k] = c[i] / (q[j] q[k])

                Optionally the function may instead return a 3-tuple of values
                with the first a function to compute a MHP of `constr`, the
                second a 2D array corresponding to the Jacobian of `constr`,
                and the third the value of `constr`, all evaluated at the
                passed position array. If `None` is passed (the default) an
                automatic differentiation fallback will be used to attempt to
                construct a function which calculates the MHP (and Jacobian and
                value) of `constr` automatically.
        &#34;&#34;&#34;
        DenseConstrainedEuclideanMetricSystem.__init__(
            self, neg_log_dens=neg_log_dens, constr=constr, metric=metric,
            dens_wrt_hausdorff=False,
            grad_neg_log_dens=grad_neg_log_dens, jacob_constr=jacob_constr,
            mhp_constr=mhp_constr)

    def jacob_constr_inner_product(
            self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
        if jacob_constr_2 is None or jacob_constr_2 is jacob_constr_1:
            return DenseSymmetricMatrix(
                jacob_constr_1 @ (inner_product_matrix @ jacob_constr_1.T))
        else:
            return DenseSquareMatrix(
                jacob_constr_1 @ (inner_product_matrix @ jacob_constr_2.T))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></li>
<li><a title="mici.systems.DenseConstrainedEuclideanMetricSystem" href="#mici.systems.DenseConstrainedEuclideanMetricSystem">DenseConstrainedEuclideanMetricSystem</a></li>
<li><a title="mici.systems.ConstrainedEuclideanMetricSystem" href="#mici.systems.ConstrainedEuclideanMetricSystem">ConstrainedEuclideanMetricSystem</a></li>
<li><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.jacob_constr_inner_product"><code class="name flex">
<span>def <span class="ident">jacob_constr_inner_product</span></span>(<span>self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute inner product of rows of constraint Jacobian matrices.</p>
<p>Computes <code>jacob_constr_1 @ inner_product_matrix @ jacob_constr_2.T</code>
potentially exploiting any structure / sparsity in <code>jacob_constr_1</code>,
<code>jacob_constr_2</code> and <code>inner_product_matrix</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>jacob_constr_1</code></strong> :&ensp;<code>Matrix</code></dt>
<dd>First constraint Jacobian in product.</dd>
<dt><strong><code>inner_product_matrix</code></strong> :&ensp;<code>Matrix</code></dt>
<dd>Positive-definite matrix defining
inner-product between rows of two constraint Jacobians.</dd>
<dt><strong><code>jacob_constr_2</code></strong> :&ensp;<code>None</code> or <code>Matrix</code></dt>
<dd>Second constraint Jacobian in
product. Defaults to <code>jacob_constr_1</code> if set to <code>None</code>.</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>Matrix: Object corresponding to computed inner products of
the constraint Jacobian rows.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L953-L960" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def jacob_constr_inner_product(
        self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
    if jacob_constr_2 is None or jacob_constr_2 is jacob_constr_1:
        return DenseSymmetricMatrix(
            jacob_constr_1 @ (inner_product_matrix @ jacob_constr_1.T))
    else:
        return DenseSquareMatrix(
            jacob_constr_1 @ (inner_product_matrix @ jacob_constr_2.T))</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h2_flow"><code class="name flex">
<span>def <span class="ident">h2_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h2</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh2_flow_dmom"><code class="name flex">
<span>def <span class="ident">dh2_flow_dmom</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivatives of <code>h2_flow</code> flow map with respect to input momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval flow simulated for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dpos_dmom</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="matrices.html#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Matrix representing derivative
(Jacobian) of position output of <code>h2_flow</code> with respect to the
value of the momentum component of the initial input state.</dd>
<dt><strong><code>dmom_dmom</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="matrices.html#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Matrix representing derivative
(Jacobian) of momentum output of <code>h2_flow</code> with respect to the
value of the momentum component of the initial input state.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Constraint function at the current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>constr(state.pos)</code> as 1D array.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.jacob_constr"><code class="name flex">
<span>def <span class="ident">jacob_constr</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Jacobian of constraint function at the current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of Jacobian of <code>constr(state.pos)</code> as 2D array.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.gram"><code class="name flex">
<span>def <span class="ident">gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Gram matrix at current position.</p>
<p>The Gram matrix as a position <code>q</code> is defined as</p>
<pre><code>gram(q) = jacob_constr(q) @ inv(metric) @ jacob_constr(q).T
</code></pre>
<p>where <code>jacob_constr</code> is the Jacobian of the constraint function
<code>constr</code> and <code>metric</code> is the matrix representation of the metric on the
ambient space.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>mici.matrice.PositiveDefiniteMatrix: Gram matrix as matrix object.</p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.inv_gram"><code class="name flex">
<span>def <span class="ident">inv_gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Inverse of Gram matrix at current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="mici.matrices.PositiveDefiniteMatrix" href="matrices.html#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a>: <code>Inverse</code> of <code>Gram</code> <code>matrix</code> <code>as</code></dt>
<dd>matrix object.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.log_det_sqrt_gram"><code class="name flex">
<span>def <span class="ident">log_det_sqrt_gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Value of (half of) log-determinant of Gram matrix.</p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.project_onto_cotangent_space"><code class="name flex">
<span>def <span class="ident">project_onto_cotangent_space</span></span>(<span>self, mom, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Project a momentum on to the co-tangent space at a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Momentum (co-)vector as 1D array to project on to
co-tangent space.</dd>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State definining position on the
manifold to project in to the co-tangent space of.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Projected momentum in the co-tangent space at <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram"><code class="name flex">
<span>def <span class="ident">grad_log_det_sqrt_gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of (half of) log-determinant of Gram matrix wrt position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>log_det_sqrt_gram(state)</code> derivative with respect
to <code>state.pos</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.RiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">RiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric_matrix_class, metric_func, vjp_metric_func=None, grad_neg_log_dens=None, metric_kwargs=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Riemannian Hamiltonian system with a position-dependent metric.</p>
<p>This class allows for metric matrix representations of any generic type.
In most cases a specialised subclass such as <a title="mici.systems.DenseRiemannianMetricSystem" href="#mici.systems.DenseRiemannianMetricSystem"><code>DenseRiemannianMetricSystem</code></a>,
<a title="mici.systems.CholeskyFactoredRiemannianMetricSystem" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem"><code>CholeskyFactoredRiemannianMetricSystem</code></a>, <a title="mici.systems.DiagonalRiemannianMetricSystem" href="#mici.systems.DiagonalRiemannianMetricSystem"><code>DiagonalRiemannianMetricSystem</code></a>,
<a title="mici.systems.ScalarRiemannianMetricSystem" href="#mici.systems.ScalarRiemannianMetricSystem"><code>ScalarRiemannianMetricSystem</code></a> or <a title="mici.systems.SoftAbsRiemannianMetricSystem" href="#mici.systems.SoftAbsRiemannianMetricSystem"><code>SoftAbsRiemannianMetricSystem</code></a> will
provide a simpler method of constructng a system with a metric matrix
representation of a specific type.</p>
<p>The position space is assumed to be a Riemannian manifold with a metric
with position-dependent positive definite matrix-representation <span><span class="MathJax_Preview">M(q)</span><script type="math/tex">M(q)</script></span>
where <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> is a position vector. The momentum <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> is then taken to have
a zero-mean Gaussian conditional distribution given the position <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>,
with covariance <span><span class="MathJax_Preview">M(q)</span><script type="math/tex">M(q)</script></span>, i.e. <span><span class="MathJax_Preview">p \sim \mathcal{N}(0, M(q))</span><script type="math/tex">p \sim \mathcal{N}(0, M(q))</script></span> [1].</p>
<p>The <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> Hamiltonian component is then</p>
<p><span><span class="MathJax_Preview"> h_1(q) = \ell(q) + \frac{1}{2}\log\left|M(q)\right| </span><script type="math/tex; mode=display"> h_1(q) = \ell(q) + \frac{1}{2}\log\left|M(q)\right| </script></span></p>
<p>where <span><span class="MathJax_Preview">\ell(q)</span><script type="math/tex">\ell(q)</script></span> is the negative log (unnormalised) density of the target
distribution with respect to the Lebesgue measure at <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>. The <span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span>
Hamiltonian component is</p>
<p><span><span class="MathJax_Preview"> h_2(q, p) = \frac{1}{2} p^T (M(q))^{-1} p. </span><script type="math/tex; mode=display"> h_2(q, p) = \frac{1}{2} p^T (M(q))^{-1} p. </script></span></p>
<p>Due to the coupling between the position and momentum variables in <span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span>,
the Hamiltonian system is non-separable, requiring use of a numerical
integrator with implicit steps when simulating the Hamiltonian dynamic
associated with the system, e.g.
<a title="mici.integrators.ImplicitLeapfrogIntegrator" href="integrators.html#mici.integrators.ImplicitLeapfrogIntegrator"><code>ImplicitLeapfrogIntegrator</code></a>.</p>
<h2 id="references">References</h2>
<ol>
<li>Girolami, M. and Calderhead, B., 2011. Riemann manifold Langevin and
Hamiltonian Monte Varlo methods. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 73(2), pp.123-214.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>metric_matrix_class</code></strong> :&ensp;<code>type</code>[<code>PositiveDefiniteMatrix</code>]</dt>
<dd>
<p>Class (or
factory function returning an instance of the class) which
defines type of matrix representation of metric. The class
initializer should take a single positional argument which will
be passed the array outputted by <code>metric_func</code>, and which is
assumed to be a parameter which fully defines the resulting
matrix (e.g. the diagonal of a <a title="mici.matrices.DiagonalMatrix" href="matrices.html#mici.matrices.DiagonalMatrix"><code>DiagonalMatrix</code></a>).
The class initializer may also optionally take one or more
keyword arguments, with the <code>metric_kwargs</code> argument used to
specify the value of these, if any. Together this means the
metric matrix representation at a position <code>pos</code> is constructed
as</p>
<pre><code>metric = metric_matrix_class(
    metric_func(pos), **metric_kwargs)
</code></pre>
<p>The <a title="mici.matrices.PositiveDefiniteMatrix" href="matrices.html#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a> subclass should as a
minimum define <code>inv</code>, <code>log_abs_det</code>, <code>grad_log_abs_det</code>,
<code>grad_quadratic_form_inv</code>, <code>__matmul__</code> and <code>__rmatmul__</code>
methods / properties (see documentation of
<a title="mici.matrices.PositiveDefiniteMatrix" href="matrices.html#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a> and
<a title="mici.matrices.DifferentiableMatrix" href="matrices.html#mici.matrices.DifferentiableMatrix"><code>DifferentiableMatrix</code></a> for definitions of the
expected behaviour of these methods).</p>
</dd>
<dt><strong><code>metric_func</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>array</code>]</dt>
<dd>Function which given a
position array returns an array containing the parameter value
of the metric matrix representation passed as the single
positional argument to the <code>metric_matrix_class</code> initializer.</dd>
<dt><strong><code>vjp_metric_func</code></strong> :&ensp;<code>None</code> or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Callable</code>[[<code>array</code>], <code>array</code>]] or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Tuple</code>[<code>Callable</code>[[<code>array</code>], <code>array</code>], <code>array</code>]]</dt>
<dd>
<p>Function which given a position array returns another function
which takes an array as an argument and returns the
<em>vector-Jacobian-product</em> (VJP) of <code>metric_func</code> with respect
to the position array argument. The VJP is here defined as a
function of an array <code>v</code> (of the same shape as the output of
<code>metric_func</code>) corresponding to</p>
<pre><code>vjp(v) = sum(v[..., None] * jacob, tuple(range(v.ndim))
</code></pre>
<p>where <code>jacob</code> is the Jacobian of <code>m = metric_func(q)</code> wrt <code>q</code>
i.e. the array of partial derivatives of the function such that</p>
<pre><code>jacob[..., i] = m[...] / q[i]
</code></pre>
<p>Optionally the function may instead return a 2-tuple of values
with the first a function to compute a VJP of <code>metric_func</code> and
the second an array containing the value of <code>metric_func</code>, both
evaluated at the passed position array. If <code>None</code> is passed
(the default) an automatic differentiation fallback will be
used to attempt to construct a function which calculates the
VJP (and value) of <code>metric_func</code> automatically.</p>
</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
<dt><strong><code>metric_kwargs</code></strong> :&ensp;<code>None</code> or <code>Dict</code>[<code>str</code>, <code>object</code>]</dt>
<dd>An optional dictionary
of any additional keyword arguments to the initializer of
<code>metric_matrix_class</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L963-L1165" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RiemannianMetricSystem(System):
    r&#34;&#34;&#34;Riemannian Hamiltonian system with a position-dependent metric.

    This class allows for metric matrix representations of any generic type.
    In most cases a specialised subclass such as `DenseRiemannianMetricSystem`,
    `CholeskyFactoredRiemannianMetricSystem`, `DiagonalRiemannianMetricSystem`,
    `ScalarRiemannianMetricSystem` or `SoftAbsRiemannianMetricSystem` will
    provide a simpler method of constructng a system with a metric matrix
    representation of a specific type.

    The position space is assumed to be a Riemannian manifold with a metric
    with position-dependent positive definite matrix-representation \(M(q)\)
    where \(q\) is a position vector. The momentum \(p\) is then taken to have
    a zero-mean Gaussian conditional distribution given the position \(q\),
    with covariance \(M(q)\), i.e. \(p \sim \mathcal{N}(0, M(q))\) [1].

    The \(h_1\) Hamiltonian component is then

    \[ h_1(q) = \ell(q) + \frac{1}{2}\log\left|M(q)\right| \]

    where \(\ell(q)\) is the negative log (unnormalised) density of the target
    distribution with respect to the Lebesgue measure at \(q\). The \(h_2\)
    Hamiltonian component is

    \[ h_2(q, p) = \frac{1}{2} p^T (M(q))^{-1} p. \]

    Due to the coupling between the position and momentum variables in \(h_2\),
    the Hamiltonian system is non-separable, requiring use of a numerical
    integrator with implicit steps when simulating the Hamiltonian dynamic
    associated with the system, e.g.
    `mici.integrators.ImplicitLeapfrogIntegrator`.

    References:

      1. Girolami, M. and Calderhead, B., 2011. Riemann manifold Langevin and
         Hamiltonian Monte Varlo methods. Journal of the Royal Statistical
         Society: Series B (Statistical Methodology), 73(2), pp.123-214.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_matrix_class, metric_func,
                 vjp_metric_func=None, grad_neg_log_dens=None,
                 metric_kwargs=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric_matrix_class (type[PositiveDefiniteMatrix]): Class (or
                factory function returning an instance of the class) which
                defines type of matrix representation of metric. The class
                initializer should take a single positional argument which will
                be passed the array outputted by `metric_func`, and which is
                assumed to be a parameter which fully defines the resulting
                matrix (e.g. the diagonal of a `mici.matrices.DiagonalMatrix`).
                The class initializer may also optionally take one or more
                keyword arguments, with the `metric_kwargs` argument used to
                specify the value of these, if any. Together this means the
                metric matrix representation at a position `pos` is constructed
                as

                    metric = metric_matrix_class(
                        metric_func(pos), **metric_kwargs)

                The `mici.matrices.PositiveDefiniteMatrix` subclass should as a
                minimum define `inv`, `log_abs_det`, `grad_log_abs_det`,
                `grad_quadratic_form_inv`, `__matmul__` and `__rmatmul__`
                methods / properties (see documentation of
                `mici.matrices.PositiveDefiniteMatrix` and
                `mici.matrices.DifferentiableMatrix` for definitions of the
                expected behaviour of these methods).
            metric_func (Callable[[array], array]): Function which given a
                position array returns an array containing the parameter value
                of the metric matrix representation passed as the single
                positional argument to the `metric_matrix_class` initializer.
            vjp_metric_func (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable[[array], array], array]]):
                Function which given a position array returns another function
                which takes an array as an argument and returns the
                *vector-Jacobian-product* (VJP) of `metric_func` with respect
                to the position array argument. The VJP is here defined as a
                function of an array `v` (of the same shape as the output of
                `metric_func`) corresponding to

                    vjp(v) = sum(v[..., None] * jacob, tuple(range(v.ndim))

                where `jacob` is the Jacobian of `m = metric_func(q)` wrt `q`
                i.e. the array of partial derivatives of the function such that

                    jacob[..., i] = m[...] / q[i]

                Optionally the function may instead return a 2-tuple of values
                with the first a function to compute a VJP of `metric_func` and
                the second an array containing the value of `metric_func`, both
                evaluated at the passed position array. If `None` is passed
                (the default) an automatic differentiation fallback will be
                used to attempt to construct a function which calculates the
                VJP (and value) of `metric_func` automatically.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
            metric_kwargs (None or Dict[str, object]): An optional dictionary
                of any additional keyword arguments to the initializer of
                `metric_matrix_class`.
        &#34;&#34;&#34;
        self._metric_matrix_class = metric_matrix_class
        self._metric_func = metric_func
        self._vjp_metric_func = autodiff_fallback(
            vjp_metric_func, metric_func, &#39;vjp_and_value&#39;, &#39;vjp_metric_func&#39;)
        self._metric_kwargs = {} if metric_kwargs is None else metric_kwargs
        super().__init__(neg_log_dens, grad_neg_log_dens)

    @cache_in_state(&#39;pos&#39;)
    def metric_func(self, state):
        &#34;&#34;&#34;
        Function computing the parameter of the metric matrix representation.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `metric_func(state.pos)`.
        &#34;&#34;&#34;
        return self._metric_func(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;vjp_metric_func&#39;, &#39;metric_func&#39;])
    def vjp_metric_func(self, state):
        &#34;&#34;&#34;
        Function constructing a vector-Jacobian-product for `metric_func`.

        The vector-Jacobian-product is here defined as a function of an array
        `v` (of the same shape as the output of `metric_func`) corresponding to

            vjp(v) = sum(v[..., None] * jacob, axis=tuple(range(v.ndim))

        where `jacob` is the Jacobian of `m = metric_func(q)` wrt `q` i.e.
        the array of partial derivatives of the function such that

            jacob[..., i] = m[...] / q[i]

        Args:
            state (mici.states.ChainState): State to compute VJP at.

        Returns:
            Callable[[array], array]: Vector-Jacobian-product function.
        &#34;&#34;&#34;
        return self._vjp_metric_func(state.pos)

    @cache_in_state(&#39;pos&#39;)
    def metric(self, state):
        &#34;&#34;&#34;
        Function computing the metric matrix representation.

        The returned type of this function is that specified by the
        `metric_matrix_class` argument to the initializer.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            mici.matrices.PositiveDefiniteMatrix: Metric matrix representation.
        &#34;&#34;&#34;
        return self._metric_matrix_class(
            self.metric_func(state), **self._metric_kwargs)

    def h(self, state):
        return self.h1(state) + self.h2(state)

    def h1(self, state):
        return self.neg_log_dens(state) + 0.5 * self.metric(state).log_abs_det

    def dh1_dpos(self, state):
        # Evaluate VJP of metric function before metric as metric value will
        # potentially be computed in forward pass and cached
        vjp_metric = self.vjp_metric_func(state)
        return (self.grad_neg_log_dens(state) +
                0.5 * vjp_metric(self.metric(state).grad_log_abs_det))

    def h2(self, state):
        return 0.5 * state.mom @ self.metric(state).inv @ state.mom

    def dh2_dpos(self, state):
        # Evaluate VJP of metric function before metric as metric value will
        # potentially be computed in forward pass and cached
        vjp_metric = self.vjp_metric_func(state)
        return 0.5 * vjp_metric(
            self.metric(state).grad_quadratic_form_inv(state.mom))

    def dh2_dmom(self, state):
        return self.metric(state).inv @ state.mom

    def sample_momentum(self, state, rng):
        return self.metric(state).sqrt @ rng.normal(size=state.pos.shape)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.ScalarRiemannianMetricSystem" href="#mici.systems.ScalarRiemannianMetricSystem">ScalarRiemannianMetricSystem</a></li>
<li><a title="mici.systems.DiagonalRiemannianMetricSystem" href="#mici.systems.DiagonalRiemannianMetricSystem">DiagonalRiemannianMetricSystem</a></li>
<li><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem">CholeskyFactoredRiemannianMetricSystem</a></li>
<li><a title="mici.systems.DenseRiemannianMetricSystem" href="#mici.systems.DenseRiemannianMetricSystem">DenseRiemannianMetricSystem</a></li>
<li><a title="mici.systems.SoftAbsRiemannianMetricSystem" href="#mici.systems.SoftAbsRiemannianMetricSystem">SoftAbsRiemannianMetricSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.RiemannianMetricSystem.metric_func"><code class="name flex">
<span>def <span class="ident">metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the parameter of the metric matrix representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>metric_func(state.pos)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1085-L1096" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def metric_func(self, state):
    &#34;&#34;&#34;
    Function computing the parameter of the metric matrix representation.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `metric_func(state.pos)`.
    &#34;&#34;&#34;
    return self._metric_func(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.vjp_metric_func"><code class="name flex">
<span>def <span class="ident">vjp_metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function constructing a vector-Jacobian-product for <code>metric_func</code>.</p>
<p>The vector-Jacobian-product is here defined as a function of an array
<code>v</code> (of the same shape as the output of <code>metric_func</code>) corresponding to</p>
<pre><code>vjp(v) = sum(v[..., None] * jacob, axis=tuple(range(v.ndim))
</code></pre>
<p>where <code>jacob</code> is the Jacobian of <code>m = metric_func(q)</code> wrt <code>q</code> i.e.
the array of partial derivatives of the function such that</p>
<pre><code>jacob[..., i] = m[...] / q[i]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute VJP at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Callable[[array], array]: Vector-Jacobian-product function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1098-L1119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state([&#39;pos&#39;], [&#39;vjp_metric_func&#39;, &#39;metric_func&#39;])
def vjp_metric_func(self, state):
    &#34;&#34;&#34;
    Function constructing a vector-Jacobian-product for `metric_func`.

    The vector-Jacobian-product is here defined as a function of an array
    `v` (of the same shape as the output of `metric_func`) corresponding to

        vjp(v) = sum(v[..., None] * jacob, axis=tuple(range(v.ndim))

    where `jacob` is the Jacobian of `m = metric_func(q)` wrt `q` i.e.
    the array of partial derivatives of the function such that

        jacob[..., i] = m[...] / q[i]

    Args:
        state (mici.states.ChainState): State to compute VJP at.

    Returns:
        Callable[[array], array]: Vector-Jacobian-product function.
    &#34;&#34;&#34;
    return self._vjp_metric_func(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.metric"><code class="name flex">
<span>def <span class="ident">metric</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the metric matrix representation.</p>
<p>The returned type of this function is that specified by the
<code>metric_matrix_class</code> argument to the initializer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>mici.matrices.PositiveDefiniteMatrix: Metric matrix representation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1121-L1136" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def metric(self, state):
    &#34;&#34;&#34;
    Function computing the metric matrix representation.

    The returned type of this function is that specified by the
    `metric_matrix_class` argument to the initializer.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        mici.matrices.PositiveDefiniteMatrix: Metric matrix representation.
    &#34;&#34;&#34;
    return self._metric_matrix_class(
        self.metric_func(state), **self._metric_kwargs)</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1138-L1139" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h(self, state):
    return self.h1(state) + self.h2(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1141-L1142" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h1(self, state):
    return self.neg_log_dens(state) + 0.5 * self.metric(state).log_abs_det</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1144-L1149" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh1_dpos(self, state):
    # Evaluate VJP of metric function before metric as metric value will
    # potentially be computed in forward pass and cached
    vjp_metric = self.vjp_metric_func(state)
    return (self.grad_neg_log_dens(state) +
            0.5 * vjp_metric(self.metric(state).grad_log_abs_det))</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1151-L1152" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h2(self, state):
    return 0.5 * state.mom @ self.metric(state).inv @ state.mom</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.dh2_dpos"><code class="name flex">
<span>def <span class="ident">dh2_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1154-L1159" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh2_dpos(self, state):
    # Evaluate VJP of metric function before metric as metric value will
    # potentially be computed in forward pass and cached
    vjp_metric = self.vjp_metric_func(state)
    return 0.5 * vjp_metric(
        self.metric(state).grad_quadratic_form_inv(state.mom))</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1161-L1162" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh2_dmom(self, state):
    return self.metric(state).inv @ state.mom</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1164-L1165" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample_momentum(self, state, rng):
    return self.metric(state).sqrt @ rng.normal(size=state.pos.shape)</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">ScalarRiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric_scalar_func, vjp_metric_scalar_func=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Riemannian-metric system with scaled identity matrix representation.</p>
<p>Hamiltonian system with a position dependent scaled identity metric matrix
representation which is specified by a scalar function
<code>metric_scalar_function</code> of the position <code>q</code> which outputs a strictly
positive scalar <code>s = metric_scalar_func(q)</code> with the the metric matrix
representation then taken to be <code>s * identity(q.shape[0])</code>.</p>
<p>See documentation of <a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem"><code>RiemannianMetricSystem</code></a> for more general details
about Riemannian-metric Hamiltonian systems.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>metric_scalar_func</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which
given a position array returns a strictly positive scalar
corresponding to the parameter value of the scaled identity
metric matrix representation.</dd>
<dt><strong><code>vjp_metric_scalar_func</code></strong> :&ensp;<code>None</code> or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Callable</code>[[<code>array</code>], <code>float</code>]] or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Tuple</code>[<code>Callable</code>[[<code>array</code>, <code>float</code>]], <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns another function
which takes a scalar as an argument and returns the
<em>vector-Jacobian-product</em> (VJP) of <code>metric_scalar_func</code> with
respect to the position array argument. The VJP is here defined
as a function of a scalar <code>v</code></p>
<pre><code>vjp(v) = v * grad
</code></pre>
<p>where <code>grad</code> is the <code>(dim_pos,)</code> shaped Jacobian (gradient) of
<code>s = metric_scalar_func(q)</code> with respect to <code>q</code> i.e. the array
of partial derivatives of the function such that</p>
<pre><code>grad[i] = s / q[i]
</code></pre>
<p>Optionally the function may instead return a 2-tuple of values
with the first a function to compute a VJP of
<code>metric_scalar_func</code> and the second a float containing the
value of <code>metric_scalar_func</code>, both evaluated at the passed
position array. If <code>None</code> is passed (the default) an automatic
differentiation fallback will be used to attempt to construct a
function which calculates the VJP (and value) of
<code>metric_scalar_func</code> automatically.</p>
</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1168-L1239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ScalarRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;Riemannian-metric system with scaled identity matrix representation.

    Hamiltonian system with a position dependent scaled identity metric matrix
    representation which is specified by a scalar function
    `metric_scalar_function` of the position `q` which outputs a strictly
    positive scalar `s = metric_scalar_func(q)` with the the metric matrix
    representation then taken to be `s * identity(q.shape[0])`.

    See documentation of `RiemannianMetricSystem` for more general details
    about Riemannian-metric Hamiltonian systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_scalar_func,
                 vjp_metric_scalar_func=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric_scalar_func (Callable[[array], float]): Function which
                given a position array returns a strictly positive scalar
                corresponding to the parameter value of the scaled identity
                metric matrix representation.
            vjp_metric_scalar_func (None or
                    Callable[[array], Callable[[array], float]] or
                    Callable[[array], Tuple[Callable[[array, float]], float]]):
                Function which given a position array returns another function
                which takes a scalar as an argument and returns the
                *vector-Jacobian-product* (VJP) of `metric_scalar_func` with
                respect to the position array argument. The VJP is here defined
                as a function of a scalar `v`

                    vjp(v) = v * grad

                where `grad` is the `(dim_pos,)` shaped Jacobian (gradient) of
                `s = metric_scalar_func(q)` with respect to `q` i.e. the array
                of partial derivatives of the function such that

                    grad[i] = s / q[i]

                Optionally the function may instead return a 2-tuple of values
                with the first a function to compute a VJP of
                `metric_scalar_func` and the second a float containing the
                value of `metric_scalar_func`, both evaluated at the passed
                position array. If `None` is passed (the default) an automatic
                differentiation fallback will be used to attempt to construct a
                function which calculates the VJP (and value) of
                `metric_scalar_func` automatically.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;

        super().__init__(
            neg_log_dens, PositiveScaledIdentityMatrix, metric_scalar_func,
            vjp_metric_scalar_func, grad_neg_log_dens)

    @cache_in_state(&#39;pos&#39;)
    def metric(self, state):
        return self._metric_matrix_class(
            self.metric_func(state), size=pos.shape[0])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.ScalarRiemannianMetricSystem.metric"><code class="name flex">
<span>def <span class="ident">metric</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the metric matrix representation.</p>
<p>The returned type of this function is that specified by the
<code>metric_matrix_class</code> argument to the initializer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>mici.matrices.PositiveDefiniteMatrix: Metric matrix representation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1236-L1239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def metric(self, state):
    return self._metric_matrix_class(
        self.metric_func(state), size=pos.shape[0])</code></pre>
</details>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.metric_func"><code class="name flex">
<span>def <span class="ident">metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the parameter of the metric matrix representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>metric_func(state.pos)</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.vjp_metric_func"><code class="name flex">
<span>def <span class="ident">vjp_metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function constructing a vector-Jacobian-product for <code>metric_func</code>.</p>
<p>The vector-Jacobian-product is here defined as a function of an array
<code>v</code> (of the same shape as the output of <code>metric_func</code>) corresponding to</p>
<pre><code>vjp(v) = sum(v[..., None] * jacob, axis=tuple(range(v.ndim))
</code></pre>
<p>where <code>jacob</code> is the Jacobian of <code>m = metric_func(q)</code> wrt <code>q</code> i.e.
the array of partial derivatives of the function such that</p>
<pre><code>jacob[..., i] = m[...] / q[i]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute VJP at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Callable[[array], array]: Vector-Jacobian-product function.</p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">DiagonalRiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric_diagonal_func, vjp_metric_diagonal_func=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Riemannian-metric system with diagonal matrix representation.</p>
<p>Hamiltonian system with a position dependent diagonal metric matrix
representation which is specified by a vector-valued function
<code>metric_diagonal_func</code> of the position <code>q</code> which outputs a 1D array with
strictly positive elements <code>d = metric_diagonal_func(q)</code> with the metric
matrix representation then taken to be <code>diag(d)</code>.</p>
<p>See documentation of <a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem"><code>RiemannianMetricSystem</code></a> for more general details
about Riemannian-metric Hamiltonian systems.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>metric_diagonal_func</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>array</code>]</dt>
<dd>Function which
given a position array returns a 1D array with strictly
positive values corresponding to the diagonal values
(left-to-right) of the diagonal metric matrix representation.</dd>
<dt><strong><code>vjp_metric_diagonal_func</code></strong> :&ensp;<code>None</code> or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Callable</code>[[<code>array</code>], <code>array</code>]] or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Tuple</code>[<code>Callable</code>[[<code>array</code>], <code>array</code>], <code>array</code>]]</dt>
<dd>
<p>Function which given a position array returns another function
which takes a 1D array as an argument and returns the
<em>vector-Jacobian-product</em> (VJP) of <code>metric_diagonal_func</code> with
respect to the position array argument. The VJP is here defined
as a function of a 1D array <code>v</code></p>
<pre><code>vjp(v) = sum(v[:, None] * jacob[:, :], axis=0)
</code></pre>
<p>where <code>jacob</code> is the <code>(dim_pos, dim_pos)</code> shaped Jacobian of
<code>d = metric_diagonal_func(q)</code> with respect to <code>q</code> i.e. the
array of partial derivatives of the function such that</p>
<pre><code>jacob[i, j] = d[i] / q[j]
</code></pre>
<p>Optionally the function may instead return a 2-tuple of values
with the first a function to compute a VJP of
<code>metric_diagonal_func</code> and the second a 1D array containing the
value of <code>metric_diagonal_func</code>, both evaluated at the passed
position array. If <code>None</code> is passed (the default) an automatic
differentiation fallback will be used to attempt to construct a
function which calculates the VJP (and value) of
<code>metric_diagonal_func</code> automatically.</p>
</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1242-L1307" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DiagonalRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;Riemannian-metric system with diagonal matrix representation.

    Hamiltonian system with a position dependent diagonal metric matrix
    representation which is specified by a vector-valued function
    `metric_diagonal_func` of the position `q` which outputs a 1D array with
    strictly positive elements `d = metric_diagonal_func(q)` with the metric
    matrix representation then taken to be `diag(d)`.

    See documentation of `RiemannianMetricSystem` for more general details
    about Riemannian-metric Hamiltonian systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_diagonal_func,
                 vjp_metric_diagonal_func=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric_diagonal_func (Callable[[array], array]): Function which
                given a position array returns a 1D array with strictly
                positive values corresponding to the diagonal values
                (left-to-right) of the diagonal metric matrix representation.
            vjp_metric_diagonal_func (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable[[array], array], array]]):
                Function which given a position array returns another function
                which takes a 1D array as an argument and returns the
                *vector-Jacobian-product* (VJP) of `metric_diagonal_func` with
                respect to the position array argument. The VJP is here defined
                as a function of a 1D array `v`

                    vjp(v) = sum(v[:, None] * jacob[:, :], axis=0)

                where `jacob` is the `(dim_pos, dim_pos)` shaped Jacobian of
                `d = metric_diagonal_func(q)` with respect to `q` i.e. the
                array of partial derivatives of the function such that

                    jacob[i, j] = d[i] / q[j]

                Optionally the function may instead return a 2-tuple of values
                with the first a function to compute a VJP of
                `metric_diagonal_func` and the second a 1D array containing the
                value of `metric_diagonal_func`, both evaluated at the passed
                position array. If `None` is passed (the default) an automatic
                differentiation fallback will be used to attempt to construct a
                function which calculates the VJP (and value) of
                `metric_diagonal_func` automatically.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(
            neg_log_dens, PositiveDiagonalMatrix, metric_diagonal_func,
            vjp_metric_diagonal_func, grad_neg_log_dens)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.metric_func"><code class="name flex">
<span>def <span class="ident">metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the parameter of the metric matrix representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>metric_func(state.pos)</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.vjp_metric_func"><code class="name flex">
<span>def <span class="ident">vjp_metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function constructing a vector-Jacobian-product for <code>metric_func</code>.</p>
<p>The vector-Jacobian-product is here defined as a function of an array
<code>v</code> (of the same shape as the output of <code>metric_func</code>) corresponding to</p>
<pre><code>vjp(v) = sum(v[..., None] * jacob, axis=tuple(range(v.ndim))
</code></pre>
<p>where <code>jacob</code> is the Jacobian of <code>m = metric_func(q)</code> wrt <code>q</code> i.e.
the array of partial derivatives of the function such that</p>
<pre><code>jacob[..., i] = m[...] / q[i]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute VJP at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Callable[[array], array]: Vector-Jacobian-product function.</p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.metric"><code class="name flex">
<span>def <span class="ident">metric</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the metric matrix representation.</p>
<p>The returned type of this function is that specified by the
<code>metric_matrix_class</code> argument to the initializer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>mici.matrices.PositiveDefiniteMatrix: Metric matrix representation.</p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">CholeskyFactoredRiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric_chol_func, vjp_metric_chol_func=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Riemannian-metric system with Cholesky-factored matrix representation.</p>
<p>Hamiltonian system with a position dependent metric matrix representation
which is specified by its Cholesky factor by a matrix function
<code>metric_chol_func</code> of the position <code>q</code> which outputs a lower-triangular
matrix <code>L = metric_chol_func(q)</code> with the metric matrix representation then
taken to be <code>L @ L.T</code>.</p>
<p>See documentation of <a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem"><code>RiemannianMetricSystem</code></a> for more general details
about Riemannian-metric Hamiltonian systems.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>metric_chol_func</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>array</code>]</dt>
<dd>Function which given
a position array returns a 2D array with zeros above the
diagonal corresponding to the lower-triangular Cholesky-factor
of the positive definite metric matrix representation.</dd>
<dt><strong><code>vjp_metric_chol_func</code></strong> :&ensp;<code>None</code> or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Callable</code>[[<code>array</code>], <code>array</code>]] or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Tuple</code>[<code>Callable</code>[[<code>array</code>], <code>array</code>], <code>array</code>]]</dt>
<dd>
<p>Function which given a position array returns another function
which takes a lower-triangular 2D array as an argument (any
values in the array above the diagonal are ignored) and returns
the <em>vector-Jacobian-product</em> (VJP) of <code>metric_chol_func</code> with
respect to the position array argument. The VJP is here defined
as a function of a 2D array <code>v</code></p>
<pre><code>vjp(v) = sum(v[:, :, None] * jacob[:, :, :], axis=(0, 1))
</code></pre>
<p>where <code>jacob</code> is the <code>(dim_pos, dim_pos, dim_pos)</code> shaped
Jacobian of <code>L = metric_chol_func(q)</code> with respect to <code>q</code> i.e.
the array of partial derivatives of the function such that</p>
<pre><code>jacob[i, j, k] = L[i, j] / q[k]
</code></pre>
<p>Optionally the function may instead return a 2-tuple of values
with the first a function to compute a VJP of
<code>metric_chol_func</code> and the second a 2D array containing the
value of <code>metric_chol_func</code>, both evaluated at the passed
position array. If <code>None</code> is passed (the default) an automatic
differentiation fallback will be used to attempt to construct a
function which calculates the VJP (and value) of
<code>metric_chol_func</code> automatically.</p>
</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1310-L1377" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CholeskyFactoredRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;Riemannian-metric system with Cholesky-factored matrix representation.

    Hamiltonian system with a position dependent metric matrix representation
    which is specified by its Cholesky factor by a matrix function
    `metric_chol_func` of the position `q` which outputs a lower-triangular
    matrix `L = metric_chol_func(q)` with the metric matrix representation then
    taken to be `L @ L.T`.

    See documentation of `RiemannianMetricSystem` for more general details
    about Riemannian-metric Hamiltonian systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_chol_func,
                 vjp_metric_chol_func=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric_chol_func (Callable[[array], array]): Function which given
                a position array returns a 2D array with zeros above the
                diagonal corresponding to the lower-triangular Cholesky-factor
                of the positive definite metric matrix representation.
            vjp_metric_chol_func (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable[[array], array], array]]):
                Function which given a position array returns another function
                which takes a lower-triangular 2D array as an argument (any
                values in the array above the diagonal are ignored) and returns
                the *vector-Jacobian-product* (VJP) of `metric_chol_func` with
                respect to the position array argument. The VJP is here defined
                as a function of a 2D array `v`

                    vjp(v) = sum(v[:, :, None] * jacob[:, :, :], axis=(0, 1))

                where `jacob` is the `(dim_pos, dim_pos, dim_pos)` shaped
                Jacobian of `L = metric_chol_func(q)` with respect to `q` i.e.
                the array of partial derivatives of the function such that

                    jacob[i, j, k] = L[i, j] / q[k]

                Optionally the function may instead return a 2-tuple of values
                with the first a function to compute a VJP of
                `metric_chol_func` and the second a 2D array containing the
                value of `metric_chol_func`, both evaluated at the passed
                position array. If `None` is passed (the default) an automatic
                differentiation fallback will be used to attempt to construct a
                function which calculates the VJP (and value) of
                `metric_chol_func` automatically.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(
            neg_log_dens, TriangularFactoredPositiveDefiniteMatrix,
            metric_chol_func, vjp_metric_chol_func, grad_neg_log_dens,
            metric_kwargs={&#39;factor_is_lower&#39;: True})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.metric_func"><code class="name flex">
<span>def <span class="ident">metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the parameter of the metric matrix representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>metric_func(state.pos)</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.vjp_metric_func"><code class="name flex">
<span>def <span class="ident">vjp_metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function constructing a vector-Jacobian-product for <code>metric_func</code>.</p>
<p>The vector-Jacobian-product is here defined as a function of an array
<code>v</code> (of the same shape as the output of <code>metric_func</code>) corresponding to</p>
<pre><code>vjp(v) = sum(v[..., None] * jacob, axis=tuple(range(v.ndim))
</code></pre>
<p>where <code>jacob</code> is the Jacobian of <code>m = metric_func(q)</code> wrt <code>q</code> i.e.
the array of partial derivatives of the function such that</p>
<pre><code>jacob[..., i] = m[...] / q[i]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute VJP at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Callable[[array], array]: Vector-Jacobian-product function.</p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.metric"><code class="name flex">
<span>def <span class="ident">metric</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the metric matrix representation.</p>
<p>The returned type of this function is that specified by the
<code>metric_matrix_class</code> argument to the initializer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>mici.matrices.PositiveDefiniteMatrix: Metric matrix representation.</p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">DenseRiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric_func, vjp_metric_func=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Riemannian-metric system with dense matrix representation.</p>
<p>Hamiltonian system with a position dependent metric matrix representation
which is specified to be a dense matrix function <code>metric_func</code> of the
position <code>q</code> which is guaranteed to be positive definite almost-everywhere,
with <code>M = metric_func(q)</code> then the metric matrix representation.</p>
<p>See documentation of <a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem"><code>RiemannianMetricSystem</code></a> for more general details
about Riemannian-metric Hamiltonian systems.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>metric_func</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>array</code>]</dt>
<dd>Function which given a
position array returns a 2D array corresponding to the positive
definite metric matrix representation. The returned matrices
(2D arrays) are assumed to be positive-definite for all input
positions and a <code>LinAlgError</code> exception may be raised if this
fails to be the case.</dd>
<dt><strong><code>vjp_metric_func</code></strong> :&ensp;<code>None</code> or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Callable</code>[[<code>array</code>], <code>array</code>]] or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Tuple</code>[<code>Callable</code>[[<code>array</code>], <code>array</code>], <code>array</code>]]</dt>
<dd>
<p>Function which given a position array returns another function
which takes a 2D array as an argument and returns the
<em>vector-Jacobian-product</em> (VJP) of <code>metric_func</code> with respect
to the position array argument. The VJP is here defined as a
function of a 2D array <code>v</code></p>
<pre><code>vjp(v) = sum(v[:, :, None] * jacob[:, :, :], axis=(0, 1))
</code></pre>
<p>where <code>jacob</code> is the <code>(dim_pos, dim_pos, dim_pos)</code> shaped
Jacobian of <code>M = metric_func(q)</code> with respect to <code>q</code> i.e. the
array of partial derivatives of the function such that</p>
<pre><code>jacob[i, j, k] = M[i, j] / q[k]
</code></pre>
<p>Optionally the function may instead return a 2-tuple of values
with the first a function to compute a VJP of <code>metric_func</code> and
the second a 2D array containing the value of <code>metric_func</code>,
both evaluated at the passed position array. If <code>None</code> is
passed (the default) an automatic differentiation fallback will
be used to attempt to construct a function which calculates the
VJP (and value) of <code>metric_func</code> automatically.</p>
</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1380-L1445" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DenseRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;Riemannian-metric system with dense matrix representation.

    Hamiltonian system with a position dependent metric matrix representation
    which is specified to be a dense matrix function `metric_func` of the
    position `q` which is guaranteed to be positive definite almost-everywhere,
    with `M = metric_func(q)` then the metric matrix representation.

    See documentation of `RiemannianMetricSystem` for more general details
    about Riemannian-metric Hamiltonian systems.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_func,
                 vjp_metric_func=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric_func (Callable[[array], array]): Function which given a
                position array returns a 2D array corresponding to the positive
                definite metric matrix representation. The returned matrices
                (2D arrays) are assumed to be positive-definite for all input
                positions and a `LinAlgError` exception may be raised if this
                fails to be the case.
            vjp_metric_func (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable[[array], array], array]]):
                Function which given a position array returns another function
                which takes a 2D array as an argument and returns the
                *vector-Jacobian-product* (VJP) of `metric_func` with respect
                to the position array argument. The VJP is here defined as a
                function of a 2D array `v`

                    vjp(v) = sum(v[:, :, None] * jacob[:, :, :], axis=(0, 1))

                where `jacob` is the `(dim_pos, dim_pos, dim_pos)` shaped
                Jacobian of `M = metric_func(q)` with respect to `q` i.e. the
                array of partial derivatives of the function such that

                    jacob[i, j, k] = M[i, j] / q[k]

                Optionally the function may instead return a 2-tuple of values
                with the first a function to compute a VJP of `metric_func` and
                the second a 2D array containing the value of `metric_func`,
                both evaluated at the passed position array. If `None` is
                passed (the default) an automatic differentiation fallback will
                be used to attempt to construct a function which calculates the
                VJP (and value) of `metric_func` automatically.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(
            neg_log_dens, DensePositiveDefiniteMatrix, metric_func,
            vjp_metric_func, grad_neg_log_dens)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.DenseRiemannianMetricSystem.metric_func"><code class="name flex">
<span>def <span class="ident">metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the parameter of the metric matrix representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>metric_func(state.pos)</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.vjp_metric_func"><code class="name flex">
<span>def <span class="ident">vjp_metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function constructing a vector-Jacobian-product for <code>metric_func</code>.</p>
<p>The vector-Jacobian-product is here defined as a function of an array
<code>v</code> (of the same shape as the output of <code>metric_func</code>) corresponding to</p>
<pre><code>vjp(v) = sum(v[..., None] * jacob, axis=tuple(range(v.ndim))
</code></pre>
<p>where <code>jacob</code> is the Jacobian of <code>m = metric_func(q)</code> wrt <code>q</code> i.e.
the array of partial derivatives of the function such that</p>
<pre><code>jacob[..., i] = m[...] / q[i]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute VJP at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Callable[[array], array]: Vector-Jacobian-product function.</p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.metric"><code class="name flex">
<span>def <span class="ident">metric</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the metric matrix representation.</p>
<p>The returned type of this function is that specified by the
<code>metric_matrix_class</code> argument to the initializer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>mici.matrices.PositiveDefiniteMatrix: Metric matrix representation.</p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">SoftAbsRiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, grad_neg_log_dens=None, hess_neg_log_dens=None, mtp_neg_log_dens=None, softabs_coeff=1.0)</span>
</code></dt>
<dd>
<section class="desc"><p>SoftAbs Riemmanian metric Hamiltonian system.</p>
<p>Hamiltonian system with a position dependent metric matrix representation
which is specified to be a dense matrix function <code>metric_func</code> of the
position <code>q</code> which is guaranteed to be positive definite almost-everywhere,
with <code>M = metric_func(q)</code> then the metric matrix representation.</p>
<p>Hamiltonian system with a position dependent metric matrix representation
which is specified to be an eigenvalue-regularised transformation of the
Hessian of the negative log density function (the symmetric matrix of
second derivatives the negative log density function with respect to the
position array components. Specifically if <code>hess_neg_log_dens</code> is a
symmetric 2D square array valued function of the position <code>q</code>, with
<code>H = hess_neg_log_dens(q)</code> then if an eigenvalue decomposition of <code>H</code> is
computed, i.e. <code>eigval, eigvec = eigh(H)</code>, with <code>eigval</code> a 1D array of
real eigenvalues, and <code>eigvec</code> the corresponding 2D array (orthogonal
matrix) with eigenvectors as columns, then the resulting positive-definite
metric matrix representation <code>M</code> is computed as</p>
<pre><code>M = eigvec @ diag(softabs(eigval, softabs_coeff)) @ eigvec.T
</code></pre>
<p>with <code>softabs(x, softabs_coeff) = x / tanh(x * softabs_coeff)</code> an
elementwise function which acts as a smooth approximation to the absolute
function (ensuring all the eigenvalues of <code>M</code> are strictly positive) with
the additional scalar parameter <code>softabs_coeff</code> controlling the smoothness
of the approximation, with <code>softabs</code> tending to the piecewise linear <code>abs</code>
function as <code>softabs_coeff</code> tends to infinity, and becoming increasingly
smooth as <code>softabs_coeff</code> tends to zero.</p>
<p>See documentation of <a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem"><code>RiemannianMetricSystem</code></a> for more general details
about Riemannian-metric Hamiltonian systems.</p>
<h2 id="references">References</h2>
<ol>
<li>Betancourt, M., 2013. A general metric for Riemannian manifold
Hamiltonian Monte Carlo. In Geometric science of information
(pp. 327-334).</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a 2-tuple of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
<dt><strong><code>hess_neg_log_dens</code></strong> :&ensp;<code>None</code> or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the Hessian of
<code>neg_log_dens</code> with respect to the position array argument as a
2D array. Optionally the function may instead return a 3-tuple
of values with the first a 2D array containting the Hessian of
<code>neg_log_dens</code>, the second a 1D array containing the gradient
of <code>neg_log_dens</code> and the third the value of <code>neg_log_dens</code>,
all evaluated at the passed position array. If <code>None</code> is passed
(the default) an automatic differentiation fallback will be
used to attempt to construct a function which calculates the
Hessian (and gradient and value) of <code>neg_log_dens</code>
automatically.</p>
</dd>
<dt><strong><code>mtp_neg_log_dens</code></strong> :&ensp;<code>None</code> or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Callable</code>[[<code>array</code>], <code>array</code>]] or</dt>
<dt><code>Callable</code>[[<code>array</code>], <code>Tuple</code>[<code>Callable</code>, <code>array</code>, <code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns another function
which takes a 2D array (matrix) as an argument and returns the
<em>matrix-Tressian-product</em> (MTP) of <code>neg_log_dens</code> with respect
to the position array argument. The MTP is here defined as a
function of a matrix <code>m</code> corresponding to</p>
<pre><code>mtp(m) = sum(m[:, :, None] * tress[:, :, :], axis=(0, 1))
</code></pre>
<p>where <code>tress</code> is the 'Tressian' of <code>f = neg_log_dens(q)</code> wrt
<code>q</code> i.e. the 3D array of third-order partial derivatives of the
scalar-valued function such that</p>
<pre><code>tress[i, j, k] = f / (q[i] q[j] q[k])
</code></pre>
<p>Optionally the function may instead return a 4-tuple of values
with the first a function to compute a MTP of <code>neg_log_dens</code>,
the second a 2D array containing the Hessian of <code>neg_log_dens</code>,
the third a 1D array containing the gradient of <code>neg_log_dens</code>
and the fourth the value of <code>neg_log_dens</code>, all evaluated at
the passed position array. If <code>None</code> is passed (the default) an
automatic differentiation fallback will be used to attempt to
construct a function which calculates the MTP (and Hesisan and
gradient and value) of <code>neg_log_dens</code> automatically.</p>
</dd>
<dt><strong><code>softabs_coeff</code></strong> :&ensp;<code>float</code></dt>
<dd>Positive regularisation coefficient for
smooth approximation to absolute value used to regularise
Hessian eigenvalues in metric matrix representation. As the
value tends to infinity the approximation becomes increasingly
close to the absolute function.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1448-L1614" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SoftAbsRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;SoftAbs Riemmanian metric Hamiltonian system.

    Hamiltonian system with a position dependent metric matrix representation
    which is specified to be a dense matrix function `metric_func` of the
    position `q` which is guaranteed to be positive definite almost-everywhere,
    with `M = metric_func(q)` then the metric matrix representation.

    Hamiltonian system with a position dependent metric matrix representation
    which is specified to be an eigenvalue-regularised transformation of the
    Hessian of the negative log density function (the symmetric matrix of
    second derivatives the negative log density function with respect to the
    position array components. Specifically if `hess_neg_log_dens` is a
    symmetric 2D square array valued function of the position `q`, with
    `H = hess_neg_log_dens(q)` then if an eigenvalue decomposition of `H` is
    computed, i.e. `eigval, eigvec = eigh(H)`, with `eigval` a 1D array of
    real eigenvalues, and `eigvec` the corresponding 2D array (orthogonal
    matrix) with eigenvectors as columns, then the resulting positive-definite
    metric matrix representation `M` is computed as

        M = eigvec @ diag(softabs(eigval, softabs_coeff)) @ eigvec.T

    with `softabs(x, softabs_coeff) = x / tanh(x * softabs_coeff)` an
    elementwise function which acts as a smooth approximation to the absolute
    function (ensuring all the eigenvalues of `M` are strictly positive) with
    the additional scalar parameter `softabs_coeff` controlling the smoothness
    of the approximation, with `softabs` tending to the piecewise linear `abs`
    function as `softabs_coeff` tends to infinity, and becoming increasingly
    smooth as `softabs_coeff` tends to zero.

    See documentation of `RiemannianMetricSystem` for more general details
    about Riemannian-metric Hamiltonian systems.

    References:

      1. Betancourt, M., 2013. A general metric for Riemannian manifold
         Hamiltonian Monte Carlo. In Geometric science of information
         (pp. 327-334).
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, grad_neg_log_dens=None,
                 hess_neg_log_dens=None, mtp_neg_log_dens=None,
                 softabs_coeff=1.):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a 2-tuple of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
            hess_neg_log_dens (None or
                    Callable[[array], array or Tuple[array, array, float]]):
                Function which given a position array returns the Hessian of
                `neg_log_dens` with respect to the position array argument as a
                2D array. Optionally the function may instead return a 3-tuple
                of values with the first a 2D array containting the Hessian of
                `neg_log_dens`, the second a 1D array containing the gradient
                of `neg_log_dens` and the third the value of `neg_log_dens`,
                all evaluated at the passed position array. If `None` is passed
                (the default) an automatic differentiation fallback will be
                used to attempt to construct a function which calculates the
                Hessian (and gradient and value) of `neg_log_dens`
                automatically.
            mtp_neg_log_dens (None or
                    Callable[[array], Callable[[array], array]] or
                    Callable[[array], Tuple[Callable, array, array, float]]):
                Function which given a position array returns another function
                which takes a 2D array (matrix) as an argument and returns the
                *matrix-Tressian-product* (MTP) of `neg_log_dens` with respect
                to the position array argument. The MTP is here defined as a
                function of a matrix `m` corresponding to

                    mtp(m) = sum(m[:, :, None] * tress[:, :, :], axis=(0, 1))

                where `tress` is the &#39;Tressian&#39; of `f = neg_log_dens(q)` wrt
                `q` i.e. the 3D array of third-order partial derivatives of the
                scalar-valued function such that

                    tress[i, j, k] = f / (q[i] q[j] q[k])

                Optionally the function may instead return a 4-tuple of values
                with the first a function to compute a MTP of `neg_log_dens`,
                the second a 2D array containing the Hessian of `neg_log_dens`,
                the third a 1D array containing the gradient of `neg_log_dens`
                and the fourth the value of `neg_log_dens`, all evaluated at
                the passed position array. If `None` is passed (the default) an
                automatic differentiation fallback will be used to attempt to
                construct a function which calculates the MTP (and Hesisan and
                gradient and value) of `neg_log_dens` automatically.
            softabs_coeff (float): Positive regularisation coefficient for
                smooth approximation to absolute value used to regularise
                Hessian eigenvalues in metric matrix representation. As the
                value tends to infinity the approximation becomes increasingly
                close to the absolute function.
        &#34;&#34;&#34;
        self._hess_neg_log_dens = autodiff_fallback(
            hess_neg_log_dens, neg_log_dens, &#39;hessian_grad_and_value&#39;,
            &#39;neg_log_dens&#39;)
        self._mtp_neg_log_dens = autodiff_fallback(
            mtp_neg_log_dens, neg_log_dens, &#39;mtp_hessian_grad_and_value&#39;,
            &#39;mtp_neg_log_dens&#39;)
        super().__init__(neg_log_dens,
                         SoftAbsRegularisedPositiveDefiniteMatrix,
                         self._hess_neg_log_dens, self._mtp_neg_log_dens,
                         grad_neg_log_dens,
                         metric_kwargs={&#39;softabs_coeff&#39;: softabs_coeff})

    def metric_func(self, state):
        return self.hess_neg_log_dens(state)

    def vjp_metric_func(self, state):
        return self.mtp_neg_log_dens(state)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;hess_neg_log_dens&#39;, &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def hess_neg_log_dens(self, state):
        &#34;&#34;&#34;Hessian of negative log density with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            hessian (array): 2D array of `neg_log_dens(state)` second
                derivatives with respect to `state.pos`, with `hessian[i, j]`
                the second derivative of `neg_log_dens(state)` with respect to
                `state.pos[i]` and `state.pos[j]`.
        &#34;&#34;&#34;
        return self._hess_neg_log_dens(state.pos)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;mtp_neg_log_dens&#39;, &#39;hess_neg_log_dens&#39;,
                  &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def mtp_neg_log_dens(self, state):
        &#34;&#34;&#34;Generate MTP of negative log density with respect to position.

        The matrix-Tressian-product (MTP) is here defined as a function of a
        matrix `m` corresponding to

            mtp(m) = sum(m[:, :, None] * tress[:, :, :], axis=(0, 1))

        where `tress` is the &#39;Tressian&#39; of `f = neg_log_dens(q)` with respect
        to `q = state.pos` i.e. the 3D array of third-order partial derivatives
        of the scalar-valued function such that

            tress[i, j, k] = f / (q[i] q[j] q[k])

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            mtp (Callable[[array], array]): Function which accepts a 2D array
                of shape `(state.pos.shape[0], state.pos.shape[0])` as an
                argument and returns an array of shape `state.pos.shape`
                containing the computed MTP value.
        &#34;&#34;&#34;
        return self._mtp_neg_log_dens(state.pos)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.metric_func"><code class="name flex">
<span>def <span class="ident">metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the parameter of the metric matrix representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>metric_func(state.pos)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1566-L1567" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def metric_func(self, state):
    return self.hess_neg_log_dens(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.vjp_metric_func"><code class="name flex">
<span>def <span class="ident">vjp_metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function constructing a vector-Jacobian-product for <code>metric_func</code>.</p>
<p>The vector-Jacobian-product is here defined as a function of an array
<code>v</code> (of the same shape as the output of <code>metric_func</code>) corresponding to</p>
<pre><code>vjp(v) = sum(v[..., None] * jacob, axis=tuple(range(v.ndim))
</code></pre>
<p>where <code>jacob</code> is the Jacobian of <code>m = metric_func(q)</code> wrt <code>q</code> i.e.
the array of partial derivatives of the function such that</p>
<pre><code>jacob[..., i] = m[...] / q[i]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute VJP at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Callable[[array], array]: Vector-Jacobian-product function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1569-L1570" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def vjp_metric_func(self, state):
    return self.mtp_neg_log_dens(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.hess_neg_log_dens"><code class="name flex">
<span>def <span class="ident">hess_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hessian of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hessian</code></strong> :&ensp;<code>array</code></dt>
<dd>2D array of <code>neg_log_dens(state)</code> second
derivatives with respect to <code>state.pos</code>, with <code>hessian[i, j]</code>
the second derivative of <code>neg_log_dens(state)</code> with respect to
<code>state.pos[i]</code> and <code>state.pos[j]</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1572-L1586" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state(
    [&#39;pos&#39;], [&#39;hess_neg_log_dens&#39;, &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
def hess_neg_log_dens(self, state):
    &#34;&#34;&#34;Hessian of negative log density with respect to position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        hessian (array): 2D array of `neg_log_dens(state)` second
            derivatives with respect to `state.pos`, with `hessian[i, j]`
            the second derivative of `neg_log_dens(state)` with respect to
            `state.pos[i]` and `state.pos[j]`.
    &#34;&#34;&#34;
    return self._hess_neg_log_dens(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.mtp_neg_log_dens"><code class="name flex">
<span>def <span class="ident">mtp_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate MTP of negative log density with respect to position.</p>
<p>The matrix-Tressian-product (MTP) is here defined as a function of a
matrix <code>m</code> corresponding to</p>
<pre><code>mtp(m) = sum(m[:, :, None] * tress[:, :, :], axis=(0, 1))
</code></pre>
<p>where <code>tress</code> is the 'Tressian' of <code>f = neg_log_dens(q)</code> with respect
to <code>q = state.pos</code> i.e. the 3D array of third-order partial derivatives
of the scalar-valued function such that</p>
<pre><code>tress[i, j, k] = f / (q[i] q[j] q[k])
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mtp</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>array</code>]</dt>
<dd>Function which accepts a 2D array
of shape <code>(state.pos.shape[0], state.pos.shape[0])</code> as an
argument and returns an array of shape <code>state.pos.shape</code>
containing the computed MTP value.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/systems.py#L1588-L1614" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state(
    [&#39;pos&#39;], [&#39;mtp_neg_log_dens&#39;, &#39;hess_neg_log_dens&#39;,
              &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
def mtp_neg_log_dens(self, state):
    &#34;&#34;&#34;Generate MTP of negative log density with respect to position.

    The matrix-Tressian-product (MTP) is here defined as a function of a
    matrix `m` corresponding to

        mtp(m) = sum(m[:, :, None] * tress[:, :, :], axis=(0, 1))

    where `tress` is the &#39;Tressian&#39; of `f = neg_log_dens(q)` with respect
    to `q = state.pos` i.e. the 3D array of third-order partial derivatives
    of the scalar-valued function such that

        tress[i, j, k] = f / (q[i] q[j] q[k])

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        mtp (Callable[[array], array]): Function which accepts a 2D array
            of shape `(state.pos.shape[0], state.pos.shape[0])` as an
            argument and returns an array of shape `state.pos.shape`
            containing the computed MTP value.
    &#34;&#34;&#34;
    return self._mtp_neg_log_dens(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.metric"><code class="name flex">
<span>def <span class="ident">metric</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Function computing the metric matrix representation.</p>
<p>The returned type of this function is that specified by the
<code>metric_matrix_class</code> argument to the initializer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>mici.matrices.PositiveDefiniteMatrix: Metric matrix representation.</p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
Copyright  2019 Matt Graham
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2.dev0+g1b644f6.d20200507</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad(); hljs.configure({languages: ["python"]});</script>
</body>
</html>