<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>mici.systems API documentation</title>
<meta name="description" content="Hamiltonian systems encapsulating energy functions and their derivatives." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>mici.systems</code></h1>
</header>
<section id="section-intro">
<p>Hamiltonian systems encapsulating energy functions and their derivatives.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L0-L653" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Hamiltonian systems encapsulating energy functions and their derivatives.&#34;&#34;&#34;

from abc import ABC, abstractmethod
import logging
import numpy as np
from mici.states import cache_in_state, multi_cache_in_state
from mici.matrices import (
    IdentityMatrix, PositiveScaledIdentityMatrix, PositiveDiagonalMatrix,
    DenseSquareMatrix, TriangularFactoredDefiniteMatrix, DenseDefiniteMatrix,
    DensePositiveDefiniteMatrix, EigendecomposedSymmetricMatrix,
    SoftAbsRegularisedPositiveDefiniteMatrix)
from mici.autodiff import autodiff_fallback


class System(ABC):
    r&#34;&#34;&#34;Base class for Hamiltonian systems.

    The Hamiltonian function \(h\) is assumed to have the general form

    \[ h(q, p) = h_1(q) + h_2(q, p) \]

    where \(q\) and \(p\) are the position and momentum variables respectively,
    and \(h_1\) and \(h_2\) Hamiltonian component functions. The exact
    Hamiltonian flow for the \(h_1\) component can be always be computed as it
    depends only on the position variable however depending on the form of
    \(h_2\) the corresponding exact Hamiltonian flow may or may not be
    simulable.

    By default \(h_1\) is assumed to correspond to the negative logarithm of an
    unnormalised density on the position variables with respect to the Lebesgue
    measure, with the corresponding distribution on the position space being
    the target distribution it is wished to draw approximate samples from.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                the negative logarithm of the unnormalised density specified by
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a pair of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        self._neg_log_dens = neg_log_dens
        self._grad_neg_log_dens = autodiff_fallback(
            grad_neg_log_dens, neg_log_dens,
            &#39;grad_and_value&#39;, &#39;grad_neg_log_dens&#39;)

    @cache_in_state(&#39;pos&#39;)
    def neg_log_dens(self, state):
        &#34;&#34;&#34;Negative logarithm of unnormalised density of target distribution.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of computed negative log density.
        &#34;&#34;&#34;
        return self._neg_log_dens(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def grad_neg_log_dens(self, state):
        &#34;&#34;&#34;Derivative of negative log density with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `neg_log_dens(state)` derivative with respect to
                `state.pos`.
        &#34;&#34;&#34;
        return self._grad_neg_log_dens(state.pos)

    def h1(self, state):
        &#34;&#34;&#34;Hamiltonian component depending only on position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of `h1` Hamiltonian component.
        &#34;&#34;&#34;
        return self.neg_log_dens(state)

    def dh1_dpos(self, state):
        &#34;&#34;&#34;Derivative of `h1` Hamiltonian component with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of computed `h1` derivative.
        &#34;&#34;&#34;
        return self.grad_neg_log_dens(state)

    def h1_flow(self, state, dt):
        &#34;&#34;&#34;Apply exact flow map corresponding to `h1` Hamiltonian component.

        `state` argument is modified in place.

        Args:
            state (mici.states.ChainState): State to start flow at.
            dt (float): Time interval to simulate flow for.
        &#34;&#34;&#34;
        state.mom -= dt * self.dh1_dpos(state)

    @abstractmethod
    def h2(self, state):
        &#34;&#34;&#34;Hamiltonian component depending on momentum and optionally position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of `h2` Hamiltonian component.
        &#34;&#34;&#34;

    @abstractmethod
    def dh2_dmom(self, state):
        &#34;&#34;&#34;Derivative of `h2` Hamiltonian component with respect to momentum.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h2(state)` derivative with respect to `state.pos`.
        &#34;&#34;&#34;

    def h(self, state):
        &#34;&#34;&#34;Hamiltonian function for system.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of Hamiltonian.
        &#34;&#34;&#34;
        return self.h1(state) + self.h2(state)

    def dh_dpos(self, state):
        &#34;&#34;&#34;Derivative of Hamiltonian with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h(state)` derivative with respect to `state.pos`.
        &#34;&#34;&#34;
        if hasattr(self, &#39;dh2_dpos&#39;):
            return self.dh1_dpos(state) + self.dh2_dpos(state)
        else:
            return self.dh1_dpos(state)

    def dh_dmom(self, state):
        &#34;&#34;&#34;Derivative of Hamiltonian with respect to momentum.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h(state)` derivative with respect to `state.mom`.
        &#34;&#34;&#34;
        return self.dh2_dmom(state)

    @abstractmethod
    def sample_momentum(self, state, rng):
        &#34;&#34;&#34;
        Sample a momentum from its conditional distribution given a position.

        Args:
            state (mici.states.ChainState): State defining position to
               condition on.

        Returns:
            mom (array): Sampled momentum.
        &#34;&#34;&#34;


class EuclideanMetricSystem(System):
    r&#34;&#34;&#34;Hamiltonian system with a Euclidean metric on the position space.

    Here Euclidean metric is defined to mean a metric with a fixed positive
    definite matrix representation \(M\). The momentum variables are taken to
    be independent of the position variables and with a zero-mean Gaussian
    marginal distribution with covariance specified by \(M\), so that the
    \(h_2\) Hamiltonian component is

    \[ h_2(q, p) = \frac{1}{2} p^T M^{-1} p \]

    where \(q\) and \(p\) are the position and momentum variables respectively.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric (None or array or Matrix): Matrix object corresponding to
                matrix representation of metric on position space and
                covariance of Gaussian marginal distribution on momentum
                vector. If `None` is passed (the default), the identity matrix
                will be used. If a 1D array is passed then this is assumed to
                specify a metric with diagonal matrix representation and the
                array to the matrix diagonal. If a 2D array is passed then this
                is assumed to specify a metric with a dense positive definite
                matrix representation specified by the array.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                the negative logarithm of the unnormalised density specified by
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a pair of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens, grad_neg_log_dens)
        if metric is None:
            self.metric = IdentityMatrix()
        elif isinstance(metric, np.ndarray):
            if metric.ndim == 1:
                self.metric = PositiveDiagonalMatrix(metric)
            elif metric.ndim == 2:
                self.metric = DensePositiveDefiniteMatrix(metric)
            else:
                raise ValueError(&#39;If NumPy ndarray value is used for `metric`&#39;
                                 &#39; must be either 1D (diagonal matrix) or 2D &#39;
                                 &#39;(dense positive definite matrix)&#39;)
        else:
            self.metric = metric

    @cache_in_state(&#39;mom&#39;)
    def h2(self, state):
        return 0.5 * state.mom @ self.metric.inv @ state.mom

    @cache_in_state(&#39;mom&#39;)
    def dh2_dmom(self, state):
        return self.metric.inv @ state.mom

    def h2_flow(self, state, dt):
        state.pos += dt * self.dh2_dmom(state)

    def dh2_flow_dmom(self, dt):
        return dt * self.metric.inv, IdentityMatrix(self.metric.shape[0])

    def sample_momentum(self, state, rng):
        return self.metric.sqrt @ rng.standard_normal(state.pos.shape)


class GaussianEuclideanMetricSystem(EuclideanMetricSystem):
    r&#34;&#34;&#34;Euclidean Hamiltonian system with a tractable Gaussian component.

    Here Euclidean metric is defined to mean a metric with a fixed positive
    definite matrix representation \(M\). The momentum variables are taken to
    be independent of the position variables and with a zero-mean Gaussian
    marginal distribution with covariance specified by \(M\).

    Additionally the target distribution on the position variables is assumed
    to be defined by an unnormalised density with respect to the standard
    Gaussian measure on the position space (with identity covariance and zero
    mean), with the Hamiltonian component \(h_1\) corresponding to the negative
    logarithm of this density rather than the density with respect to the
    Lebesgue measure on the position space. The Hamiltonian component function
    \(h_2\) is therefore assumed to have the form

    \[ h_2(q, p) = \frac{1}{2} q^T q + \frac{1}{2} p^T M^{-1} p \]

    where \(q\) and \(p\) are the position and momentum variables respectively.
    In this case the Hamiltonian flow due to the quadratic \(h_2\) component
    can be solved for analytically, allowing an integrator to be defined using
    this alternative splitting of the Hamiltonian [1].

    References:

      1. Shahbaba, B., Lan, S., Johnson, W.O. and Neal, R.M., 2014. Split
         Hamiltonian Monte Carlo. Statistics and Computing, 24(3), pp.339-349.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the standard Gaussian measure on the position space,
                with the corresponding distribution on the position space being
                the target distribution it is wished to draw approximate
                samples from.
            metric (None or array or Matrix): Matrix object corresponding to
                matrix representation of metric on position space and
                covariance of Gaussian marginal distribution on momentum
                vector. If `None` is passed (the default), the identity matrix
                will be used. If a 1D array is passed then this is assumed to
                specify a metric with diagonal matrix representation and the
                array to the matrix diagonal. If a 2D array is passed then this
                is assumed to specify a metric with a dense positive definite
                matrix representation specified by the array.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position vector returns the derivative
                of the negative logarithm of the unnormalised density specified
                by `neg_log_dens` with respect to its position vector argument.
                Optionally the function may instead return a pair of values
                with the first being the value of the `neg_log_dens` evaluated
                at the passed position vector and the second being the value of
                its derivative with respect to the position argument. If `None`
                is passed (the default) an automatic differentiation backend
                will be used to construct the derivative of `neg_log_dens`
                automatically if available.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens, metric, grad_neg_log_dens)

    def h2(self, state):
        return (0.5 * state.pos @ state.pos +
                0.5 * state.mom @ self.metric.inv @ state.mom)

    @cache_in_state(&#39;mom&#39;)
    def dh2_dmom(self, state):
        return self.metric.inv @ state.mom

    @cache_in_state(&#39;mom&#39;)
    def dh2_dpos(self, state):
        return state.pos

    def h2_flow(self, state, dt):
        omega = 1. / self.metric.eigval**0.5
        sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
        eigvec_T_pos = self.metric.eigvec.T @ state.pos
        eigvec_T_mom = self.metric.eigvec.T @ state.mom
        state.pos = self.metric.eigvec @ (
            cos_omega_dt * eigvec_T_pos +
            (sin_omega_dt * omega) * eigvec_T_mom)
        state.mom = self.metric.eigvec @ (
            cos_omega_dt * eigvec_T_mom -
            (sin_omega_dt / omega) * eigvec_T_pos)

    def dh2_flow_dmom(self, dt):
        omega = 1. / self.metric.eigval**0.5
        sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
        return (
            EigendecomposedSymmetricMatrix(
                self.metric.eigvec, sin_omega_dt * omega),
            EigendecomposedSymmetricMatrix(
                self.metric.eigvec, cos_omega_dt))


class _ConstrainedEuclideanMetricSystem(EuclideanMetricSystem):
    &#34;&#34;&#34;Base class for Euclidean Hamiltonian systems subject to constraints.

    The system is assumed to be subject to a set of holonomic constraints on
    the position component of the state. These constraints are specified by a
    vector constraint function which takes as argument the position component,
    and which is equal to zero in all components when the constraints are
    satisfied. The constraint function implicitly defines a manifold embedded
    in the position space of constraint satisfying configurations. There are
    also implicitly a set of constraints on the momentum component of the state
    due to the requirment that velocity (momentum pre-multiplied by inverse
    metric) is always tangential to the constraint manifold.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, constr, metric=None,
                 dens_wrt_hausdorff=True, grad_neg_log_dens=None,
                 jacob_constr=None):
        super().__init__(neg_log_dens=neg_log_dens, metric=metric,
                         grad_neg_log_dens=grad_neg_log_dens)
        self._constr = constr
        self.dens_wrt_hausdorff = dens_wrt_hausdorff
        self._jacob_constr = autodiff_fallback(
            jacob_constr, constr, &#39;jacobian_and_value&#39;, &#39;jacob_constr&#39;)

    @cache_in_state(&#39;pos&#39;)
    def constr(self, state):
        return self._constr(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;jacob_constr&#39;, &#39;constr&#39;])
    def jacob_constr(self, state):
        return self._jacob_constr(state.pos)

    def jacob_constr_inner_product(
            self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
        raise NotImplementedError()

    @cache_in_state(&#39;pos&#39;)
    def gram(self, state):
        return self.jacob_constr_inner_product(
            self.jacob_constr(state), self.metric.inv)

    def inv_gram(self, state):
        return self.gram(state).inv

    def log_det_sqrt_gram(self, state):
        return self.gram(state).log_abs_det_sqrt

    def grad_log_det_sqrt_gram(self, state):
        raise NotImplementedError()

    def h1(self, state):
        if self.dens_wrt_hausdorff:
            return self.neg_log_dens(state)
        else:
            return self.neg_log_dens(state) + self.log_det_sqrt_gram(state)

    def dh1_dpos(self, state):
        if self.dens_wrt_hausdorff:
            return self.grad_neg_log_dens(state)
        else:
            return (self.grad_neg_log_dens(state) +
                    self.grad_log_det_sqrt_gram(state))

    def project_onto_cotangent_space(self, mom, state):
        jacob_constr = self.jacob_constr(state)
        # Use parenthesis to force right-to-left evaluation to avoid
        # matrix-matrix products
        mom -= (self.jacob_constr(state).T @ (
                    self.inv_gram(state) @ (
                        self.jacob_constr(state) @ (self.metric.inv @ mom))))

    def sample_momentum(self, state, rng):
        mom = super().sample_momentum(state, rng)
        self.project_onto_cotangent_space(mom, state)
        return mom


class DenseConstrainedEuclideanMetricSystem(_ConstrainedEuclideanMetricSystem):
    &#34;&#34;&#34;Euclidean Hamiltonian systems subject to a dense set of constraints.

    The system is assumed to be subject to a set of holonomic constraints on
    the position component of the state. These constraints are specified by a
    vector constraint function which takes as argument the position component,
    and which is equal to zero in all components when the constraints are
    satisfied. The constraint function implicitly defines a manifold embedded
    in the position space of constraint satisfying configurations. There are
    also implicitly a set of constraints on the momentum component of the state
    due to the requirment that velocity (momentum pre-multiplied by inverse
    metric) is always tangential to the constraint manifold.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, constr, metric=None,
                 dens_wrt_hausdorff=True, grad_neg_log_dens=None,
                 jacob_constr=None, mhp_constr=None):
        super().__init__(neg_log_dens=neg_log_dens, constr=constr,
                         metric=metric, dens_wrt_hausdorff=dens_wrt_hausdorff,
                         grad_neg_log_dens=grad_neg_log_dens,
                         jacob_constr=jacob_constr)
        if not dens_wrt_hausdorff:
            self._mhp_constr = autodiff_fallback(
                mhp_constr, constr, &#39;mhp_jacobian_and_value&#39;, &#39;mhp_constr&#39;)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;mhp_constr&#39;, &#39;jacob_constr&#39;, &#39;constr&#39;])
    def mhp_constr(self, state):
        return self._mhp_constr(state.pos)

    def jacob_constr_inner_product(
            self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
        if jacob_constr_2 is None or jacob_constr_2 is jacob_constr_1:
            return DenseDefiniteMatrix(
                jacob_constr_1 @ inner_product_matrix @ jacob_constr_1.T,
                sign=1 if inner_product_matrix.is_posdef else -1)
        else:
            return DenseSquareMatrix(
                jacob_constr_1 @ inner_product_matrix @ jacob_constr_2.T)

    @cache_in_state(&#39;pos&#39;)
    def grad_log_det_sqrt_gram(self, state):
        return self.mhp_constr(state)(
            self.inv_gram(state) @ self.jacob_constr(state) @ self.metric.inv)


class GaussianDenseConstrainedEuclideanMetricSystem(
        GaussianEuclideanMetricSystem, DenseConstrainedEuclideanMetricSystem):

    def __init__(self, neg_log_dens, constr, metric=None,
                 dens_wrt_hausdorff=True, grad_neg_log_dens=None,
                 jacob_constr=None, mhp_constr=None):
        DenseConstrainedEuclideanMetricSystem.__init__(
            self, neg_log_dens=neg_log_dens, constr=constr, metric=metric,
            dens_wrt_hausdorff=dens_wrt_hausdorff,
            grad_neg_log_dens=grad_neg_log_dens, jacob_constr=jacob_constr,
            mhp_constr=mhp_constr)


class RiemannianMetricSystem(System):
    &#34;&#34;&#34;Riemannian Hamiltonian system with a position dependent metric tensor.

    The momentum variables are assumed to have a zero-mean Gaussian conditional
    distribution given the position variables, with covariance specified by a
    position dependent positive-definite metric tensor [1]. Due to the coupling
    between the position and momentum variables in the quadratic form of the
    negative log density of the Gaussian conditional distribution on the
    momentum variables, the Hamiltonian system is non-separable, requiring use
    of a numerical integrator with implicit steps.

    References:

      1. Girolami, M. and Calderhead, B., 2011. Riemann manifold Langevin and
         Hamiltonian Monte Varlo methods. Journal of the Royal Statistical
         Society: Series B (Statistical Methodology), 73(2), pp.123-214.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_matrix_class, metric_func,
                 vjp_metric_func=None, grad_neg_log_dens=None,
                 metric_kwargs=None):
        self._metric_matrix_class = metric_matrix_class
        self._metric_func = metric_func
        self._vjp_metric_func = autodiff_fallback(
            vjp_metric_func, metric_func, &#39;vjp_and_value&#39;, &#39;vjp_metric_func&#39;)
        self._metric_kwargs = {} if metric_kwargs is None else metric_kwargs
        super().__init__(neg_log_dens, grad_neg_log_dens)

    @cache_in_state(&#39;pos&#39;)
    def metric_func(self, state):
        return self._metric_func(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;vjp_metric_func&#39;, &#39;metric_func&#39;])
    def vjp_metric_func(self, state):
        return self._vjp_metric_func(state.pos)

    @cache_in_state(&#39;pos&#39;)
    def metric(self, state):
        return self._metric_matrix_class(
            self.metric_func(state), **self._metric_kwargs)

    def h(self, state):
        return self.h1(state) + self.h2(state)

    def h1(self, state):
        return self.neg_log_dens(state) + self.metric(state).log_abs_det_sqrt

    def dh1_dpos(self, state):
        # Evaluate VJP of metric function before metric as metric value will
        # be computed in forward pass and cached
        vjp_metric = self.vjp_metric_func(state)
        return (self.grad_neg_log_dens(state) +
                vjp_metric(self.metric(state).grad_log_abs_det_sqrt))

    def h2(self, state):
        return 0.5 * state.mom @ self.metric(state).inv @ state.mom

    def dh2_dpos(self, state):
        # Evaluate VJP of metric function before metric as metric value will
        # be computed in forward pass and cached
        vjp_metric = self.vjp_metric_func(state)
        return 0.5 * vjp_metric(
            self.metric(state).grad_quadratic_form_inv(state.mom))

    def dh2_dmom(self, state):
        return self.metric(state).inv @ state.mom

    def sample_momentum(self, state, rng):
        return self.metric(state).sqrt @ rng.normal(size=state.pos.shape)


class ScalarRiemannianMetricSystem(RiemannianMetricSystem):

    def __init__(self, neg_log_dens, metric_scalar_func,
                 vjp_metric_scalar_func=None, grad_neg_log_dens=None):
        super().__init__(
            neg_log_dens, PositiveScaledIdentityMatrix, metric_scalar_func,
            vjp_metric_scalar_func, grad_neg_log_dens)


class DiagonalRiemannianMetricSystem(RiemannianMetricSystem):

    def __init__(self, neg_log_dens, metric_diagonal_func,
                 vjp_metric_diagonal_func=None, grad_neg_log_dens=None):
        super().__init__(
            neg_log_dens, PositiveDiagonalMatrix, metric_diagonal_func,
            vjp_metric_diagonal_func, grad_neg_log_dens)


class CholeskyFactoredRiemannianMetricSystem(RiemannianMetricSystem):

    def __init__(self, neg_log_dens, metric_chol_func,
                 vjp_metric_chol_func=None, grad_neg_log_dens=None):
        super().__init__(
            neg_log_dens, TriangularFactoredDefiniteMatrix,
            metric_chol_func, vjp_metric_chol_func, grad_neg_log_dens)


class DenseRiemannianMetricSystem(RiemannianMetricSystem):

    def __init__(self, neg_log_dens, metric_func,
                 vjp_metric_func=None, grad_neg_log_dens=None):
        super().__init__(
            neg_log_dens, DensePositiveDefiniteMatrix, metric_func,
            vjp_metric_func, grad_neg_log_dens)


class SoftAbsRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;SoftAbs Riemmanian metric Hamiltonian system.

    Hamiltonian system with a position dependent metric tensor which is
    specified to be an eigenvalue-regularised transformation of the Hessian of
    the potential energy function (with the &#39;soft-absolute&#39; regularisation
    ensuring all the eigenvalues are strictly positive and so the resulting
    metric tensor is positive definite everywhere).

    References:

    1. Betancourt, M., 2013. A general metric for Riemannian manifold
       Hamiltonian Monte Carlo. In Geometric science of information
       (pp. 327-334).
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, grad_neg_log_dens=None,
                 hess_neg_log_dens=None, mtp_neg_log_dens=None,
                 softabs_coeff=1.):
        self._hess_neg_log_dens = autodiff_fallback(
            hess_neg_log_dens, neg_log_dens, &#39;hessian_grad_and_value&#39;,
            &#39;neg_log_dens&#39;)
        self._mtp_neg_log_dens = autodiff_fallback(
            mtp_neg_log_dens, neg_log_dens, &#39;mtp_hessian_grad_and_value&#39;,
            &#39;mtp_neg_log_dens&#39;)
        super().__init__(neg_log_dens,
                         SoftAbsRegularisedPositiveDefiniteMatrix,
                         self._hess_neg_log_dens, self._mtp_neg_log_dens,
                         grad_neg_log_dens,
                         metric_kwargs={&#39;softabs_coeff&#39;: softabs_coeff})

    def metric_func(self, state):
        return self.hess_neg_log_dens(state)

    def vjp_metric_func(self, state):
        return self.mtp_neg_log_dens(state)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;hess_neg_log_dens&#39;, &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def hess_neg_log_dens(self, state):
        return self._hess_neg_log_dens(state.pos)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;mtp_neg_log_dens&#39;, &#39;hess_neg_log_dens&#39;,
                  &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def mtp_neg_log_dens(self, state):
        return self._mtp_neg_log_dens(state.pos)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mici.systems.System"><code class="flex name class">
<span>class <span class="ident">System</span></span>
<span>(</span><span>neg_log_dens, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for Hamiltonian systems.</p>
<p>The Hamiltonian function <span><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span> is assumed to have the general form</p>
<p><span><span class="MathJax_Preview"> h(q, p) = h_1(q) + h_2(q, p) </span><script type="math/tex; mode=display"> h(q, p) = h_1(q) + h_2(q, p) </script></span></p>
<p>where <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> and <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> are the position and momentum variables respectively,
and <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> and <span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> Hamiltonian component functions. The exact
Hamiltonian flow for the <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> component can be always be computed as it
depends only on the position variable however depending on the form of
<span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> the corresponding exact Hamiltonian flow may or may not be
simulable.</p>
<p>By default <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> is assumed to correspond to the negative logarithm of an
unnormalised density on the position variables with respect to the Lebesgue
measure, with the corresponding distribution on the position space being
the target distribution it is wished to draw approximate samples from.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
the negative logarithm of the unnormalised density specified by
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a pair of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L15-L188" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class System(ABC):
    r&#34;&#34;&#34;Base class for Hamiltonian systems.

    The Hamiltonian function \(h\) is assumed to have the general form

    \[ h(q, p) = h_1(q) + h_2(q, p) \]

    where \(q\) and \(p\) are the position and momentum variables respectively,
    and \(h_1\) and \(h_2\) Hamiltonian component functions. The exact
    Hamiltonian flow for the \(h_1\) component can be always be computed as it
    depends only on the position variable however depending on the form of
    \(h_2\) the corresponding exact Hamiltonian flow may or may not be
    simulable.

    By default \(h_1\) is assumed to correspond to the negative logarithm of an
    unnormalised density on the position variables with respect to the Lebesgue
    measure, with the corresponding distribution on the position space being
    the target distribution it is wished to draw approximate samples from.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                the negative logarithm of the unnormalised density specified by
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a pair of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        self._neg_log_dens = neg_log_dens
        self._grad_neg_log_dens = autodiff_fallback(
            grad_neg_log_dens, neg_log_dens,
            &#39;grad_and_value&#39;, &#39;grad_neg_log_dens&#39;)

    @cache_in_state(&#39;pos&#39;)
    def neg_log_dens(self, state):
        &#34;&#34;&#34;Negative logarithm of unnormalised density of target distribution.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of computed negative log density.
        &#34;&#34;&#34;
        return self._neg_log_dens(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def grad_neg_log_dens(self, state):
        &#34;&#34;&#34;Derivative of negative log density with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `neg_log_dens(state)` derivative with respect to
                `state.pos`.
        &#34;&#34;&#34;
        return self._grad_neg_log_dens(state.pos)

    def h1(self, state):
        &#34;&#34;&#34;Hamiltonian component depending only on position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of `h1` Hamiltonian component.
        &#34;&#34;&#34;
        return self.neg_log_dens(state)

    def dh1_dpos(self, state):
        &#34;&#34;&#34;Derivative of `h1` Hamiltonian component with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of computed `h1` derivative.
        &#34;&#34;&#34;
        return self.grad_neg_log_dens(state)

    def h1_flow(self, state, dt):
        &#34;&#34;&#34;Apply exact flow map corresponding to `h1` Hamiltonian component.

        `state` argument is modified in place.

        Args:
            state (mici.states.ChainState): State to start flow at.
            dt (float): Time interval to simulate flow for.
        &#34;&#34;&#34;
        state.mom -= dt * self.dh1_dpos(state)

    @abstractmethod
    def h2(self, state):
        &#34;&#34;&#34;Hamiltonian component depending on momentum and optionally position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of `h2` Hamiltonian component.
        &#34;&#34;&#34;

    @abstractmethod
    def dh2_dmom(self, state):
        &#34;&#34;&#34;Derivative of `h2` Hamiltonian component with respect to momentum.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h2(state)` derivative with respect to `state.pos`.
        &#34;&#34;&#34;

    def h(self, state):
        &#34;&#34;&#34;Hamiltonian function for system.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            float: Value of Hamiltonian.
        &#34;&#34;&#34;
        return self.h1(state) + self.h2(state)

    def dh_dpos(self, state):
        &#34;&#34;&#34;Derivative of Hamiltonian with respect to position.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h(state)` derivative with respect to `state.pos`.
        &#34;&#34;&#34;
        if hasattr(self, &#39;dh2_dpos&#39;):
            return self.dh1_dpos(state) + self.dh2_dpos(state)
        else:
            return self.dh1_dpos(state)

    def dh_dmom(self, state):
        &#34;&#34;&#34;Derivative of Hamiltonian with respect to momentum.

        Args:
            state (mici.states.ChainState): State to compute value at.

        Returns:
            array: Value of `h(state)` derivative with respect to `state.mom`.
        &#34;&#34;&#34;
        return self.dh2_dmom(state)

    @abstractmethod
    def sample_momentum(self, state, rng):
        &#34;&#34;&#34;
        Sample a momentum from its conditional distribution given a position.

        Args:
            state (mici.states.ChainState): State defining position to
               condition on.

        Returns:
            mom (array): Sampled momentum.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></li>
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.System.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Negative logarithm of unnormalised density of target distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of computed negative log density.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L61-L71" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def neg_log_dens(self, state):
    &#34;&#34;&#34;Negative logarithm of unnormalised density of target distribution.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        float: Value of computed negative log density.
    &#34;&#34;&#34;
    return self._neg_log_dens(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of negative log density with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>neg_log_dens(state)</code> derivative with respect to
<code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L73-L84" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state([&#39;pos&#39;], [&#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
def grad_neg_log_dens(self, state):
    &#34;&#34;&#34;Derivative of negative log density with respect to position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `neg_log_dens(state)` derivative with respect to
            `state.pos`.
    &#34;&#34;&#34;
    return self._grad_neg_log_dens(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending only on position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h1</code> Hamiltonian component.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L86-L95" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h1(self, state):
    &#34;&#34;&#34;Hamiltonian component depending only on position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        float: Value of `h1` Hamiltonian component.
    &#34;&#34;&#34;
    return self.neg_log_dens(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of computed <code>h1</code> derivative.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L97-L106" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh1_dpos(self, state):
    &#34;&#34;&#34;Derivative of `h1` Hamiltonian component with respect to position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of computed `h1` derivative.
    &#34;&#34;&#34;
    return self.grad_neg_log_dens(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component.</p>
<p><code>state</code> argument is modified in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to start flow at.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval to simulate flow for.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L108-L117" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h1_flow(self, state, dt):
    &#34;&#34;&#34;Apply exact flow map corresponding to `h1` Hamiltonian component.

    `state` argument is modified in place.

    Args:
        state (mici.states.ChainState): State to start flow at.
        dt (float): Time interval to simulate flow for.
    &#34;&#34;&#34;
    state.mom -= dt * self.dh1_dpos(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian component depending on momentum and optionally position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of <code>h2</code> Hamiltonian component.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L119-L128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def h2(self, state):
    &#34;&#34;&#34;Hamiltonian component depending on momentum and optionally position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        float: Value of `h2` Hamiltonian component.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.systems.System.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h2(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L130-L139" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def dh2_dmom(self, state):
    &#34;&#34;&#34;Derivative of `h2` Hamiltonian component with respect to momentum.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `h2(state)` derivative with respect to `state.pos`.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.systems.System.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian function for system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>float</code></strong></dt>
<dd>Value of Hamiltonian.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L141-L150" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h(self, state):
    &#34;&#34;&#34;Hamiltonian function for system.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        float: Value of Hamiltonian.
    &#34;&#34;&#34;
    return self.h1(state) + self.h2(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.pos</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L152-L164" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh_dpos(self, state):
    &#34;&#34;&#34;Derivative of Hamiltonian with respect to position.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `h(state)` derivative with respect to `state.pos`.
    &#34;&#34;&#34;
    if hasattr(self, &#39;dh2_dpos&#39;):
        return self.dh1_dpos(state) + self.dh2_dpos(state)
    else:
        return self.dh1_dpos(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of Hamiltonian with respect to momentum.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State to compute value at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong></dt>
<dd>Value of <code>h(state)</code> derivative with respect to <code>state.mom</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L166-L175" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh_dmom(self, state):
    &#34;&#34;&#34;Derivative of Hamiltonian with respect to momentum.

    Args:
        state (mici.states.ChainState): State to compute value at.

    Returns:
        array: Value of `h(state)` derivative with respect to `state.mom`.
    &#34;&#34;&#34;
    return self.dh2_dmom(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.System.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a momentum from its conditional distribution given a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>State defining position to
condition on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sampled momentum.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L177-L188" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def sample_momentum(self, state, rng):
    &#34;&#34;&#34;
    Sample a momentum from its conditional distribution given a position.

    Args:
        state (mici.states.ChainState): State defining position to
           condition on.

    Returns:
        mom (array): Sampled momentum.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.systems.EuclideanMetricSystem"><code class="flex name class">
<span>class <span class="ident">EuclideanMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Hamiltonian system with a Euclidean metric on the position space.</p>
<p>Here Euclidean metric is defined to mean a metric with a fixed positive
definite matrix representation <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>. The momentum variables are taken to
be independent of the position variables and with a zero-mean Gaussian
marginal distribution with covariance specified by <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>, so that the
<span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> Hamiltonian component is</p>
<p><span><span class="MathJax_Preview"> h_2(q, p) = \frac{1}{2} p^T M^{-1} p </span><script type="math/tex; mode=display"> h_2(q, p) = \frac{1}{2} p^T M^{-1} p </script></span></p>
<p>where <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> and <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> are the position and momentum variables respectively.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>None</code> or <code>array</code> or <code>Matrix</code></dt>
<dd>Matrix object corresponding to
matrix representation of metric on position space and
covariance of Gaussian marginal distribution on momentum
vector. If <code>None</code> is passed (the default), the identity matrix
will be used. If a 1D array is passed then this is assumed to
specify a metric with diagonal matrix representation and the
array to the matrix diagonal. If a 2D array is passed then this
is assumed to specify a metric with a dense positive definite
matrix representation specified by the array.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
the negative logarithm of the unnormalised density specified by
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a pair of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L191-L265" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EuclideanMetricSystem(System):
    r&#34;&#34;&#34;Hamiltonian system with a Euclidean metric on the position space.

    Here Euclidean metric is defined to mean a metric with a fixed positive
    definite matrix representation \(M\). The momentum variables are taken to
    be independent of the position variables and with a zero-mean Gaussian
    marginal distribution with covariance specified by \(M\), so that the
    \(h_2\) Hamiltonian component is

    \[ h_2(q, p) = \frac{1}{2} p^T M^{-1} p \]

    where \(q\) and \(p\) are the position and momentum variables respectively.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the Lebesgue measure, with the corresponding
                distribution on the position space being the target
                distribution it is wished to draw approximate samples from.
            metric (None or array or Matrix): Matrix object corresponding to
                matrix representation of metric on position space and
                covariance of Gaussian marginal distribution on momentum
                vector. If `None` is passed (the default), the identity matrix
                will be used. If a 1D array is passed then this is assumed to
                specify a metric with diagonal matrix representation and the
                array to the matrix diagonal. If a 2D array is passed then this
                is assumed to specify a metric with a dense positive definite
                matrix representation specified by the array.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position array returns the derivative of
                the negative logarithm of the unnormalised density specified by
                `neg_log_dens` with respect to the position array argument.
                Optionally the function may instead return a pair of values
                with the first being the array corresponding to the derivative
                and the second being the value of the `neg_log_dens` evaluated
                at the passed position array. If `None` is passed (the default)
                an automatic differentiation fallback will be used to attempt
                to construct the derivative of `neg_log_dens` automatically.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens, grad_neg_log_dens)
        if metric is None:
            self.metric = IdentityMatrix()
        elif isinstance(metric, np.ndarray):
            if metric.ndim == 1:
                self.metric = PositiveDiagonalMatrix(metric)
            elif metric.ndim == 2:
                self.metric = DensePositiveDefiniteMatrix(metric)
            else:
                raise ValueError(&#39;If NumPy ndarray value is used for `metric`&#39;
                                 &#39; must be either 1D (diagonal matrix) or 2D &#39;
                                 &#39;(dense positive definite matrix)&#39;)
        else:
            self.metric = metric

    @cache_in_state(&#39;mom&#39;)
    def h2(self, state):
        return 0.5 * state.mom @ self.metric.inv @ state.mom

    @cache_in_state(&#39;mom&#39;)
    def dh2_dmom(self, state):
        return self.metric.inv @ state.mom

    def h2_flow(self, state, dt):
        state.pos += dt * self.dh2_dmom(state)

    def dh2_flow_dmom(self, dt):
        return dt * self.metric.inv, IdentityMatrix(self.metric.shape[0])

    def sample_momentum(self, state, rng):
        return self.metric.sqrt @ rng.standard_normal(state.pos.shape)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></li>
<li>mici.systems._ConstrainedEuclideanMetricSystem</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.EuclideanMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.h2" href="#mici.systems.System.h2">h2</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending on momentum and optionally position </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L250-L252" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;mom&#39;)
def h2(self, state):
    return 0.5 * state.mom @ self.metric.inv @ state.mom</code></pre>
</details>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.dh2_dmom" href="#mici.systems.System.dh2_dmom">dh2_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L254-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;mom&#39;)
def dh2_dmom(self, state):
    return self.metric.inv @ state.mom</code></pre>
</details>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.h2_flow"><code class="name flex">
<span>def <span class="ident">h2_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L258-L259" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h2_flow(self, state, dt):
    state.pos += dt * self.dh2_dmom(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.dh2_flow_dmom"><code class="name flex">
<span>def <span class="ident">dh2_flow_dmom</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L261-L262" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh2_flow_dmom(self, dt):
    return dt * self.metric.inv, IdentityMatrix(self.metric.shape[0])</code></pre>
</details>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.sample_momentum" href="#mici.systems.System.sample_momentum">sample_momentum</a></code>
</p>
<section class="desc inherited"><p>Sample a momentum from its conditional distribution given a position </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L264-L265" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample_momentum(self, state, rng):
    return self.metric.sqrt @ rng.standard_normal(state.pos.shape)</code></pre>
</details>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.neg_log_dens" href="#mici.systems.System.neg_log_dens">neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Negative logarithm of unnormalised density of target distribution </p></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.grad_neg_log_dens" href="#mici.systems.System.grad_neg_log_dens">grad_neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Derivative of negative log density with respect to position </p></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.h1" href="#mici.systems.System.h1">h1</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending only on position </p></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.dh1_dpos" href="#mici.systems.System.dh1_dpos">dh1_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position </p></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.h1_flow" href="#mici.systems.System.h1_flow">h1_flow</a></code>
</p>
<section class="desc inherited"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component </p></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.h" href="#mici.systems.System.h">h</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian function for system </p></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.dh_dpos" href="#mici.systems.System.dh_dpos">dh_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to position </p></section>
</dd>
<dt id="mici.systems.EuclideanMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.dh_dmom" href="#mici.systems.System.dh_dmom">dh_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to momentum </p></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem"><code class="flex name class">
<span>class <span class="ident">GaussianEuclideanMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Euclidean Hamiltonian system with a tractable Gaussian component.</p>
<p>Here Euclidean metric is defined to mean a metric with a fixed positive
definite matrix representation <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>. The momentum variables are taken to
be independent of the position variables and with a zero-mean Gaussian
marginal distribution with covariance specified by <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>.</p>
<p>Additionally the target distribution on the position variables is assumed
to be defined by an unnormalised density with respect to the standard
Gaussian measure on the position space (with identity covariance and zero
mean), with the Hamiltonian component <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> corresponding to the negative
logarithm of this density rather than the density with respect to the
Lebesgue measure on the position space. The Hamiltonian component function
<span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> is therefore assumed to have the form</p>
<p><span><span class="MathJax_Preview"> h_2(q, p) = \frac{1}{2} q^T q + \frac{1}{2} p^T M^{-1} p </span><script type="math/tex; mode=display"> h_2(q, p) = \frac{1}{2} q^T q + \frac{1}{2} p^T M^{-1} p </script></span></p>
<p>where <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> and <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> are the position and momentum variables respectively.
In this case the Hamiltonian flow due to the quadratic <span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> component
can be solved for analytically, allowing an integrator to be defined using
this alternative splitting of the Hamiltonian [1].</p>
<h2 id="references">References</h2>
<ol>
<li>Shahbaba, B., Lan, S., Johnson, W.O. and Neal, R.M., 2014. Split
Hamiltonian Monte Carlo. Statistics and Computing, 24(3), pp.339-349.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the standard Gaussian measure on the position space,
with the corresponding distribution on the position space being
the target distribution it is wished to draw approximate
samples from.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>None</code> or <code>array</code> or <code>Matrix</code></dt>
<dd>Matrix object corresponding to
matrix representation of metric on position space and
covariance of Gaussian marginal distribution on momentum
vector. If <code>None</code> is passed (the default), the identity matrix
will be used. If a 1D array is passed then this is assumed to
specify a metric with diagonal matrix representation and the
array to the matrix diagonal. If a 2D array is passed then this
is assumed to specify a metric with a dense positive definite
matrix representation specified by the array.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position vector returns the derivative
of the negative logarithm of the unnormalised density specified
by <code>neg_log_dens</code> with respect to its position vector argument.
Optionally the function may instead return a pair of values
with the first being the value of the <code>neg_log_dens</code> evaluated
at the passed position vector and the second being the value of
its derivative with respect to the position argument. If <code>None</code>
is passed (the default) an automatic differentiation backend
will be used to construct the derivative of <code>neg_log_dens</code>
automatically if available.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L268-L362" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GaussianEuclideanMetricSystem(EuclideanMetricSystem):
    r&#34;&#34;&#34;Euclidean Hamiltonian system with a tractable Gaussian component.

    Here Euclidean metric is defined to mean a metric with a fixed positive
    definite matrix representation \(M\). The momentum variables are taken to
    be independent of the position variables and with a zero-mean Gaussian
    marginal distribution with covariance specified by \(M\).

    Additionally the target distribution on the position variables is assumed
    to be defined by an unnormalised density with respect to the standard
    Gaussian measure on the position space (with identity covariance and zero
    mean), with the Hamiltonian component \(h_1\) corresponding to the negative
    logarithm of this density rather than the density with respect to the
    Lebesgue measure on the position space. The Hamiltonian component function
    \(h_2\) is therefore assumed to have the form

    \[ h_2(q, p) = \frac{1}{2} q^T q + \frac{1}{2} p^T M^{-1} p \]

    where \(q\) and \(p\) are the position and momentum variables respectively.
    In this case the Hamiltonian flow due to the quadratic \(h_2\) component
    can be solved for analytically, allowing an integrator to be defined using
    this alternative splitting of the Hamiltonian [1].

    References:

      1. Shahbaba, B., Lan, S., Johnson, W.O. and Neal, R.M., 2014. Split
         Hamiltonian Monte Carlo. Statistics and Computing, 24(3), pp.339-349.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric=None, grad_neg_log_dens=None):
        &#34;&#34;&#34;
        Args:
            neg_log_dens (Callable[[array], float]): Function which given a
                position array returns the negative logarithm of an
                unnormalised probability density on the position space with
                respect to the standard Gaussian measure on the position space,
                with the corresponding distribution on the position space being
                the target distribution it is wished to draw approximate
                samples from.
            metric (None or array or Matrix): Matrix object corresponding to
                matrix representation of metric on position space and
                covariance of Gaussian marginal distribution on momentum
                vector. If `None` is passed (the default), the identity matrix
                will be used. If a 1D array is passed then this is assumed to
                specify a metric with diagonal matrix representation and the
                array to the matrix diagonal. If a 2D array is passed then this
                is assumed to specify a metric with a dense positive definite
                matrix representation specified by the array.
            grad_neg_log_dens (
                    None or Callable[[array], array or Tuple[array, float]]):
                Function which given a position vector returns the derivative
                of the negative logarithm of the unnormalised density specified
                by `neg_log_dens` with respect to its position vector argument.
                Optionally the function may instead return a pair of values
                with the first being the value of the `neg_log_dens` evaluated
                at the passed position vector and the second being the value of
                its derivative with respect to the position argument. If `None`
                is passed (the default) an automatic differentiation backend
                will be used to construct the derivative of `neg_log_dens`
                automatically if available.
        &#34;&#34;&#34;
        super().__init__(neg_log_dens, metric, grad_neg_log_dens)

    def h2(self, state):
        return (0.5 * state.pos @ state.pos +
                0.5 * state.mom @ self.metric.inv @ state.mom)

    @cache_in_state(&#39;mom&#39;)
    def dh2_dmom(self, state):
        return self.metric.inv @ state.mom

    @cache_in_state(&#39;mom&#39;)
    def dh2_dpos(self, state):
        return state.pos

    def h2_flow(self, state, dt):
        omega = 1. / self.metric.eigval**0.5
        sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
        eigvec_T_pos = self.metric.eigvec.T @ state.pos
        eigvec_T_mom = self.metric.eigvec.T @ state.mom
        state.pos = self.metric.eigvec @ (
            cos_omega_dt * eigvec_T_pos +
            (sin_omega_dt * omega) * eigvec_T_mom)
        state.mom = self.metric.eigvec @ (
            cos_omega_dt * eigvec_T_mom -
            (sin_omega_dt / omega) * eigvec_T_pos)

    def dh2_flow_dmom(self, dt):
        omega = 1. / self.metric.eigval**0.5
        sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
        return (
            EigendecomposedSymmetricMatrix(
                self.metric.eigvec, sin_omega_dt * omega),
            EigendecomposedSymmetricMatrix(
                self.metric.eigvec, cos_omega_dt))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem">GaussianDenseConstrainedEuclideanMetricSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.GaussianEuclideanMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.h2" href="#mici.systems.System.h2">h2</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending on momentum and optionally position </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L331-L333" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h2(self, state):
    return (0.5 * state.pos @ state.pos +
            0.5 * state.mom @ self.metric.inv @ state.mom)</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.dh2_dmom" href="#mici.systems.System.dh2_dmom">dh2_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L335-L337" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;mom&#39;)
def dh2_dmom(self, state):
    return self.metric.inv @ state.mom</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh2_dpos"><code class="name flex">
<span>def <span class="ident">dh2_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L339-L341" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;mom&#39;)
def dh2_dpos(self, state):
    return state.pos</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.h2_flow"><code class="name flex">
<span>def <span class="ident">h2_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L343-L353" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h2_flow(self, state, dt):
    omega = 1. / self.metric.eigval**0.5
    sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
    eigvec_T_pos = self.metric.eigvec.T @ state.pos
    eigvec_T_mom = self.metric.eigvec.T @ state.mom
    state.pos = self.metric.eigvec @ (
        cos_omega_dt * eigvec_T_pos +
        (sin_omega_dt * omega) * eigvec_T_mom)
    state.mom = self.metric.eigvec @ (
        cos_omega_dt * eigvec_T_mom -
        (sin_omega_dt / omega) * eigvec_T_pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh2_flow_dmom"><code class="name flex">
<span>def <span class="ident">dh2_flow_dmom</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L355-L362" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh2_flow_dmom(self, dt):
    omega = 1. / self.metric.eigval**0.5
    sin_omega_dt, cos_omega_dt = np.sin(omega * dt), np.cos(omega * dt)
    return (
        EigendecomposedSymmetricMatrix(
            self.metric.eigvec, sin_omega_dt * omega),
        EigendecomposedSymmetricMatrix(
            self.metric.eigvec, cos_omega_dt))</code></pre>
</details>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.sample_momentum" href="#mici.systems.EuclideanMetricSystem.sample_momentum">sample_momentum</a></code>
</p>
<section class="desc inherited"><p>Sample a momentum from its conditional distribution given a position </p></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.neg_log_dens" href="#mici.systems.EuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Negative logarithm of unnormalised density of target distribution </p></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.EuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Derivative of negative log density with respect to position </p></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.h1" href="#mici.systems.EuclideanMetricSystem.h1">h1</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending only on position </p></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.dh1_dpos" href="#mici.systems.EuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position </p></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.h1_flow" href="#mici.systems.EuclideanMetricSystem.h1_flow">h1_flow</a></code>
</p>
<section class="desc inherited"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component </p></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.h" href="#mici.systems.EuclideanMetricSystem.h">h</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian function for system </p></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.dh_dpos" href="#mici.systems.EuclideanMetricSystem.dh_dpos">dh_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to position </p></section>
</dd>
<dt id="mici.systems.GaussianEuclideanMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.dh_dmom" href="#mici.systems.EuclideanMetricSystem.dh_dmom">dh_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to momentum </p></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem"><code class="flex name class">
<span>class <span class="ident">DenseConstrainedEuclideanMetricSystem</span></span>
<span>(</span><span>neg_log_dens, constr, metric=None, dens_wrt_hausdorff=True, grad_neg_log_dens=None, jacob_constr=None, mhp_constr=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Euclidean Hamiltonian systems subject to a dense set of constraints.</p>
<p>The system is assumed to be subject to a set of holonomic constraints on
the position component of the state. These constraints are specified by a
vector constraint function which takes as argument the position component,
and which is equal to zero in all components when the constraints are
satisfied. The constraint function implicitly defines a manifold embedded
in the position space of constraint satisfying configurations. There are
also implicitly a set of constraints on the momentum component of the state
due to the requirment that velocity (momentum pre-multiplied by inverse
metric) is always tangential to the constraint manifold.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>None</code> or <code>array</code> or <code>Matrix</code></dt>
<dd>Matrix object corresponding to
matrix representation of metric on position space and
covariance of Gaussian marginal distribution on momentum
vector. If <code>None</code> is passed (the default), the identity matrix
will be used. If a 1D array is passed then this is assumed to
specify a metric with diagonal matrix representation and the
array to the matrix diagonal. If a 2D array is passed then this
is assumed to specify a metric with a dense positive definite
matrix representation specified by the array.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
the negative logarithm of the unnormalised density specified by
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a pair of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L442-L485" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DenseConstrainedEuclideanMetricSystem(_ConstrainedEuclideanMetricSystem):
    &#34;&#34;&#34;Euclidean Hamiltonian systems subject to a dense set of constraints.

    The system is assumed to be subject to a set of holonomic constraints on
    the position component of the state. These constraints are specified by a
    vector constraint function which takes as argument the position component,
    and which is equal to zero in all components when the constraints are
    satisfied. The constraint function implicitly defines a manifold embedded
    in the position space of constraint satisfying configurations. There are
    also implicitly a set of constraints on the momentum component of the state
    due to the requirment that velocity (momentum pre-multiplied by inverse
    metric) is always tangential to the constraint manifold.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, constr, metric=None,
                 dens_wrt_hausdorff=True, grad_neg_log_dens=None,
                 jacob_constr=None, mhp_constr=None):
        super().__init__(neg_log_dens=neg_log_dens, constr=constr,
                         metric=metric, dens_wrt_hausdorff=dens_wrt_hausdorff,
                         grad_neg_log_dens=grad_neg_log_dens,
                         jacob_constr=jacob_constr)
        if not dens_wrt_hausdorff:
            self._mhp_constr = autodiff_fallback(
                mhp_constr, constr, &#39;mhp_jacobian_and_value&#39;, &#39;mhp_constr&#39;)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;mhp_constr&#39;, &#39;jacob_constr&#39;, &#39;constr&#39;])
    def mhp_constr(self, state):
        return self._mhp_constr(state.pos)

    def jacob_constr_inner_product(
            self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
        if jacob_constr_2 is None or jacob_constr_2 is jacob_constr_1:
            return DenseDefiniteMatrix(
                jacob_constr_1 @ inner_product_matrix @ jacob_constr_1.T,
                sign=1 if inner_product_matrix.is_posdef else -1)
        else:
            return DenseSquareMatrix(
                jacob_constr_1 @ inner_product_matrix @ jacob_constr_2.T)

    @cache_in_state(&#39;pos&#39;)
    def grad_log_det_sqrt_gram(self, state):
        return self.mhp_constr(state)(
            self.inv_gram(state) @ self.jacob_constr(state) @ self.metric.inv)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mici.systems._ConstrainedEuclideanMetricSystem</li>
<li><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem">GaussianDenseConstrainedEuclideanMetricSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.mhp_constr"><code class="name flex">
<span>def <span class="ident">mhp_constr</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L467-L470" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state(
    [&#39;pos&#39;], [&#39;mhp_constr&#39;, &#39;jacob_constr&#39;, &#39;constr&#39;])
def mhp_constr(self, state):
    return self._mhp_constr(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.jacob_constr_inner_product"><code class="name flex">
<span>def <span class="ident">jacob_constr_inner_product</span></span>(<span>self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L472-L480" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def jacob_constr_inner_product(
        self, jacob_constr_1, inner_product_matrix, jacob_constr_2=None):
    if jacob_constr_2 is None or jacob_constr_2 is jacob_constr_1:
        return DenseDefiniteMatrix(
            jacob_constr_1 @ inner_product_matrix @ jacob_constr_1.T,
            sign=1 if inner_product_matrix.is_posdef else -1)
    else:
        return DenseSquareMatrix(
            jacob_constr_1 @ inner_product_matrix @ jacob_constr_2.T)</code></pre>
</details>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram"><code class="name flex">
<span>def <span class="ident">grad_log_det_sqrt_gram</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L482-L485" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def grad_log_det_sqrt_gram(self, state):
    return self.mhp_constr(state)(
        self.inv_gram(state) @ self.jacob_constr(state) @ self.metric.inv)</code></pre>
</details>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.sample_momentum" href="#mici.systems.EuclideanMetricSystem.sample_momentum">sample_momentum</a></code>
</p>
<section class="desc inherited"><p>Sample a momentum from its conditional distribution given a position </p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.neg_log_dens" href="#mici.systems.EuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Negative logarithm of unnormalised density of target distribution </p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.EuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Derivative of negative log density with respect to position </p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.h1" href="#mici.systems.EuclideanMetricSystem.h1">h1</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending only on position </p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.dh1_dpos" href="#mici.systems.EuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position </p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.h1_flow" href="#mici.systems.EuclideanMetricSystem.h1_flow">h1_flow</a></code>
</p>
<section class="desc inherited"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component </p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.h" href="#mici.systems.EuclideanMetricSystem.h">h</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian function for system </p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.dh_dpos" href="#mici.systems.EuclideanMetricSystem.dh_dpos">dh_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to position </p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code>.<code><a title="mici.systems.EuclideanMetricSystem.dh_dmom" href="#mici.systems.EuclideanMetricSystem.dh_dmom">dh_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to momentum </p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.h2" href="#mici.systems.System.h2">h2</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending on momentum and optionally position </p></section>
</dd>
<dt id="mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.dh2_dmom" href="#mici.systems.System.dh2_dmom">dh2_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum </p></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem"><code class="flex name class">
<span>class <span class="ident">GaussianDenseConstrainedEuclideanMetricSystem</span></span>
<span>(</span><span>neg_log_dens, constr, metric=None, dens_wrt_hausdorff=True, grad_neg_log_dens=None, jacob_constr=None, mhp_constr=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Euclidean Hamiltonian system with a tractable Gaussian component.</p>
<p>Here Euclidean metric is defined to mean a metric with a fixed positive
definite matrix representation <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>. The momentum variables are taken to
be independent of the position variables and with a zero-mean Gaussian
marginal distribution with covariance specified by <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>.</p>
<p>Additionally the target distribution on the position variables is assumed
to be defined by an unnormalised density with respect to the standard
Gaussian measure on the position space (with identity covariance and zero
mean), with the Hamiltonian component <span><span class="MathJax_Preview">h_1</span><script type="math/tex">h_1</script></span> corresponding to the negative
logarithm of this density rather than the density with respect to the
Lebesgue measure on the position space. The Hamiltonian component function
<span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> is therefore assumed to have the form</p>
<p><span><span class="MathJax_Preview"> h_2(q, p) = \frac{1}{2} q^T q + \frac{1}{2} p^T M^{-1} p </span><script type="math/tex; mode=display"> h_2(q, p) = \frac{1}{2} q^T q + \frac{1}{2} p^T M^{-1} p </script></span></p>
<p>where <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> and <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> are the position and momentum variables respectively.
In this case the Hamiltonian flow due to the quadratic <span><span class="MathJax_Preview">h_2</span><script type="math/tex">h_2</script></span> component
can be solved for analytically, allowing an integrator to be defined using
this alternative splitting of the Hamiltonian [1].</p>
<h2 id="references">References</h2>
<ol>
<li>Shahbaba, B., Lan, S., Johnson, W.O. and Neal, R.M., 2014. Split
Hamiltonian Monte Carlo. Statistics and Computing, 24(3), pp.339-349.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the standard Gaussian measure on the position space,
with the corresponding distribution on the position space being
the target distribution it is wished to draw approximate
samples from.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>None</code> or <code>array</code> or <code>Matrix</code></dt>
<dd>Matrix object corresponding to
matrix representation of metric on position space and
covariance of Gaussian marginal distribution on momentum
vector. If <code>None</code> is passed (the default), the identity matrix
will be used. If a 1D array is passed then this is assumed to
specify a metric with diagonal matrix representation and the
array to the matrix diagonal. If a 2D array is passed then this
is assumed to specify a metric with a dense positive definite
matrix representation specified by the array.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position vector returns the derivative
of the negative logarithm of the unnormalised density specified
by <code>neg_log_dens</code> with respect to its position vector argument.
Optionally the function may instead return a pair of values
with the first being the value of the <code>neg_log_dens</code> evaluated
at the passed position vector and the second being the value of
its derivative with respect to the position argument. If <code>None</code>
is passed (the default) an automatic differentiation backend
will be used to construct the derivative of <code>neg_log_dens</code>
automatically if available.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L488-L498" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GaussianDenseConstrainedEuclideanMetricSystem(
        GaussianEuclideanMetricSystem, DenseConstrainedEuclideanMetricSystem):

    def __init__(self, neg_log_dens, constr, metric=None,
                 dens_wrt_hausdorff=True, grad_neg_log_dens=None,
                 jacob_constr=None, mhp_constr=None):
        DenseConstrainedEuclideanMetricSystem.__init__(
            self, neg_log_dens=neg_log_dens, constr=constr, metric=metric,
            dens_wrt_hausdorff=dens_wrt_hausdorff,
            grad_neg_log_dens=grad_neg_log_dens, jacob_constr=jacob_constr,
            mhp_constr=mhp_constr)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></li>
<li><a title="mici.systems.DenseConstrainedEuclideanMetricSystem" href="#mici.systems.DenseConstrainedEuclideanMetricSystem">DenseConstrainedEuclideanMetricSystem</a></li>
<li>mici.systems._ConstrainedEuclideanMetricSystem</li>
<li><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code>.<code><a title="mici.systems.GaussianEuclideanMetricSystem.h2" href="#mici.systems.GaussianEuclideanMetricSystem.h2">h2</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending on momentum and optionally position </p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code>.<code><a title="mici.systems.GaussianEuclideanMetricSystem.sample_momentum" href="#mici.systems.GaussianEuclideanMetricSystem.sample_momentum">sample_momentum</a></code>
</p>
<section class="desc inherited"><p>Sample a momentum from its conditional distribution given a position </p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code>.<code><a title="mici.systems.GaussianEuclideanMetricSystem.neg_log_dens" href="#mici.systems.GaussianEuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Negative logarithm of unnormalised density of target distribution </p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code>.<code><a title="mici.systems.GaussianEuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.GaussianEuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Derivative of negative log density with respect to position </p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code>.<code><a title="mici.systems.GaussianEuclideanMetricSystem.h1" href="#mici.systems.GaussianEuclideanMetricSystem.h1">h1</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending only on position </p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code>.<code><a title="mici.systems.GaussianEuclideanMetricSystem.dh1_dpos" href="#mici.systems.GaussianEuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position </p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code>.<code><a title="mici.systems.GaussianEuclideanMetricSystem.h1_flow" href="#mici.systems.GaussianEuclideanMetricSystem.h1_flow">h1_flow</a></code>
</p>
<section class="desc inherited"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component </p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code>.<code><a title="mici.systems.GaussianEuclideanMetricSystem.h" href="#mici.systems.GaussianEuclideanMetricSystem.h">h</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian function for system </p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code>.<code><a title="mici.systems.GaussianEuclideanMetricSystem.dh_dpos" href="#mici.systems.GaussianEuclideanMetricSystem.dh_dpos">dh_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to position </p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code>.<code><a title="mici.systems.GaussianEuclideanMetricSystem.dh_dmom" href="#mici.systems.GaussianEuclideanMetricSystem.dh_dmom">dh_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to momentum </p></section>
</dd>
<dt id="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem" href="#mici.systems.DenseConstrainedEuclideanMetricSystem">DenseConstrainedEuclideanMetricSystem</a></code>.<code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_dmom" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_dmom">dh2_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum </p></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.RiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">RiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric_matrix_class, metric_func, vjp_metric_func=None, grad_neg_log_dens=None, metric_kwargs=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Riemannian Hamiltonian system with a position dependent metric tensor.</p>
<p>The momentum variables are assumed to have a zero-mean Gaussian conditional
distribution given the position variables, with covariance specified by a
position dependent positive-definite metric tensor [1]. Due to the coupling
between the position and momentum variables in the quadratic form of the
negative log density of the Gaussian conditional distribution on the
momentum variables, the Hamiltonian system is non-separable, requiring use
of a numerical integrator with implicit steps.</p>
<h2 id="references">References</h2>
<ol>
<li>Girolami, M. and Calderhead, B., 2011. Riemann manifold Langevin and
Hamiltonian Monte Varlo methods. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 73(2), pp.123-214.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
the negative logarithm of the unnormalised density specified by
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a pair of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L501-L569" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RiemannianMetricSystem(System):
    &#34;&#34;&#34;Riemannian Hamiltonian system with a position dependent metric tensor.

    The momentum variables are assumed to have a zero-mean Gaussian conditional
    distribution given the position variables, with covariance specified by a
    position dependent positive-definite metric tensor [1]. Due to the coupling
    between the position and momentum variables in the quadratic form of the
    negative log density of the Gaussian conditional distribution on the
    momentum variables, the Hamiltonian system is non-separable, requiring use
    of a numerical integrator with implicit steps.

    References:

      1. Girolami, M. and Calderhead, B., 2011. Riemann manifold Langevin and
         Hamiltonian Monte Varlo methods. Journal of the Royal Statistical
         Society: Series B (Statistical Methodology), 73(2), pp.123-214.
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, metric_matrix_class, metric_func,
                 vjp_metric_func=None, grad_neg_log_dens=None,
                 metric_kwargs=None):
        self._metric_matrix_class = metric_matrix_class
        self._metric_func = metric_func
        self._vjp_metric_func = autodiff_fallback(
            vjp_metric_func, metric_func, &#39;vjp_and_value&#39;, &#39;vjp_metric_func&#39;)
        self._metric_kwargs = {} if metric_kwargs is None else metric_kwargs
        super().__init__(neg_log_dens, grad_neg_log_dens)

    @cache_in_state(&#39;pos&#39;)
    def metric_func(self, state):
        return self._metric_func(state.pos)

    @multi_cache_in_state([&#39;pos&#39;], [&#39;vjp_metric_func&#39;, &#39;metric_func&#39;])
    def vjp_metric_func(self, state):
        return self._vjp_metric_func(state.pos)

    @cache_in_state(&#39;pos&#39;)
    def metric(self, state):
        return self._metric_matrix_class(
            self.metric_func(state), **self._metric_kwargs)

    def h(self, state):
        return self.h1(state) + self.h2(state)

    def h1(self, state):
        return self.neg_log_dens(state) + self.metric(state).log_abs_det_sqrt

    def dh1_dpos(self, state):
        # Evaluate VJP of metric function before metric as metric value will
        # be computed in forward pass and cached
        vjp_metric = self.vjp_metric_func(state)
        return (self.grad_neg_log_dens(state) +
                vjp_metric(self.metric(state).grad_log_abs_det_sqrt))

    def h2(self, state):
        return 0.5 * state.mom @ self.metric(state).inv @ state.mom

    def dh2_dpos(self, state):
        # Evaluate VJP of metric function before metric as metric value will
        # be computed in forward pass and cached
        vjp_metric = self.vjp_metric_func(state)
        return 0.5 * vjp_metric(
            self.metric(state).grad_quadratic_form_inv(state.mom))

    def dh2_dmom(self, state):
        return self.metric(state).inv @ state.mom

    def sample_momentum(self, state, rng):
        return self.metric(state).sqrt @ rng.normal(size=state.pos.shape)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.systems.ScalarRiemannianMetricSystem" href="#mici.systems.ScalarRiemannianMetricSystem">ScalarRiemannianMetricSystem</a></li>
<li><a title="mici.systems.DiagonalRiemannianMetricSystem" href="#mici.systems.DiagonalRiemannianMetricSystem">DiagonalRiemannianMetricSystem</a></li>
<li><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem">CholeskyFactoredRiemannianMetricSystem</a></li>
<li><a title="mici.systems.DenseRiemannianMetricSystem" href="#mici.systems.DenseRiemannianMetricSystem">DenseRiemannianMetricSystem</a></li>
<li><a title="mici.systems.SoftAbsRiemannianMetricSystem" href="#mici.systems.SoftAbsRiemannianMetricSystem">SoftAbsRiemannianMetricSystem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.RiemannianMetricSystem.metric_func"><code class="name flex">
<span>def <span class="ident">metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L529-L531" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def metric_func(self, state):
    return self._metric_func(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.vjp_metric_func"><code class="name flex">
<span>def <span class="ident">vjp_metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L533-L535" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state([&#39;pos&#39;], [&#39;vjp_metric_func&#39;, &#39;metric_func&#39;])
def vjp_metric_func(self, state):
    return self._vjp_metric_func(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.metric"><code class="name flex">
<span>def <span class="ident">metric</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L537-L540" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cache_in_state(&#39;pos&#39;)
def metric(self, state):
    return self._metric_matrix_class(
        self.metric_func(state), **self._metric_kwargs)</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.h" href="#mici.systems.System.h">h</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian function for system </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L542-L543" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h(self, state):
    return self.h1(state) + self.h2(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.h1" href="#mici.systems.System.h1">h1</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending only on position </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L545-L546" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h1(self, state):
    return self.neg_log_dens(state) + self.metric(state).log_abs_det_sqrt</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.dh1_dpos" href="#mici.systems.System.dh1_dpos">dh1_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L548-L553" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh1_dpos(self, state):
    # Evaluate VJP of metric function before metric as metric value will
    # be computed in forward pass and cached
    vjp_metric = self.vjp_metric_func(state)
    return (self.grad_neg_log_dens(state) +
            vjp_metric(self.metric(state).grad_log_abs_det_sqrt))</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.h2" href="#mici.systems.System.h2">h2</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending on momentum and optionally position </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L555-L556" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def h2(self, state):
    return 0.5 * state.mom @ self.metric(state).inv @ state.mom</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.dh2_dpos"><code class="name flex">
<span>def <span class="ident">dh2_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L558-L563" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh2_dpos(self, state):
    # Evaluate VJP of metric function before metric as metric value will
    # be computed in forward pass and cached
    vjp_metric = self.vjp_metric_func(state)
    return 0.5 * vjp_metric(
        self.metric(state).grad_quadratic_form_inv(state.mom))</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.dh2_dmom" href="#mici.systems.System.dh2_dmom">dh2_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L565-L566" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh2_dmom(self, state):
    return self.metric(state).inv @ state.mom</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.sample_momentum" href="#mici.systems.System.sample_momentum">sample_momentum</a></code>
</p>
<section class="desc inherited"><p>Sample a momentum from its conditional distribution given a position </p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L568-L569" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample_momentum(self, state, rng):
    return self.metric(state).sqrt @ rng.normal(size=state.pos.shape)</code></pre>
</details>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.neg_log_dens" href="#mici.systems.System.neg_log_dens">neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Negative logarithm of unnormalised density of target distribution </p></section>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.grad_neg_log_dens" href="#mici.systems.System.grad_neg_log_dens">grad_neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Derivative of negative log density with respect to position </p></section>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.h1_flow" href="#mici.systems.System.h1_flow">h1_flow</a></code>
</p>
<section class="desc inherited"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component </p></section>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.dh_dpos" href="#mici.systems.System.dh_dpos">dh_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to position </p></section>
</dd>
<dt id="mici.systems.RiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.System" href="#mici.systems.System">System</a></code>.<code><a title="mici.systems.System.dh_dmom" href="#mici.systems.System.dh_dmom">dh_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to momentum </p></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">ScalarRiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric_scalar_func, vjp_metric_scalar_func=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Riemannian Hamiltonian system with a position dependent metric tensor.</p>
<p>The momentum variables are assumed to have a zero-mean Gaussian conditional
distribution given the position variables, with covariance specified by a
position dependent positive-definite metric tensor [1]. Due to the coupling
between the position and momentum variables in the quadratic form of the
negative log density of the Gaussian conditional distribution on the
momentum variables, the Hamiltonian system is non-separable, requiring use
of a numerical integrator with implicit steps.</p>
<h2 id="references">References</h2>
<ol>
<li>Girolami, M. and Calderhead, B., 2011. Riemann manifold Langevin and
Hamiltonian Monte Varlo methods. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 73(2), pp.123-214.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
the negative logarithm of the unnormalised density specified by
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a pair of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L572-L578" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ScalarRiemannianMetricSystem(RiemannianMetricSystem):

    def __init__(self, neg_log_dens, metric_scalar_func,
                 vjp_metric_scalar_func=None, grad_neg_log_dens=None):
        super().__init__(
            neg_log_dens, PositiveScaledIdentityMatrix, metric_scalar_func,
            vjp_metric_scalar_func, grad_neg_log_dens)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.ScalarRiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h" href="#mici.systems.RiemannianMetricSystem.h">h</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian function for system </p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h1" href="#mici.systems.RiemannianMetricSystem.h1">h1</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending only on position </p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh1_dpos" href="#mici.systems.RiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position </p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h2" href="#mici.systems.RiemannianMetricSystem.h2">h2</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending on momentum and optionally position </p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh2_dmom" href="#mici.systems.RiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum </p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.sample_momentum" href="#mici.systems.RiemannianMetricSystem.sample_momentum">sample_momentum</a></code>
</p>
<section class="desc inherited"><p>Sample a momentum from its conditional distribution given a position </p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.neg_log_dens" href="#mici.systems.RiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Negative logarithm of unnormalised density of target distribution </p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.RiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Derivative of negative log density with respect to position </p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h1_flow" href="#mici.systems.RiemannianMetricSystem.h1_flow">h1_flow</a></code>
</p>
<section class="desc inherited"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component </p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh_dpos" href="#mici.systems.RiemannianMetricSystem.dh_dpos">dh_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to position </p></section>
</dd>
<dt id="mici.systems.ScalarRiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh_dmom" href="#mici.systems.RiemannianMetricSystem.dh_dmom">dh_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to momentum </p></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">DiagonalRiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric_diagonal_func, vjp_metric_diagonal_func=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Riemannian Hamiltonian system with a position dependent metric tensor.</p>
<p>The momentum variables are assumed to have a zero-mean Gaussian conditional
distribution given the position variables, with covariance specified by a
position dependent positive-definite metric tensor [1]. Due to the coupling
between the position and momentum variables in the quadratic form of the
negative log density of the Gaussian conditional distribution on the
momentum variables, the Hamiltonian system is non-separable, requiring use
of a numerical integrator with implicit steps.</p>
<h2 id="references">References</h2>
<ol>
<li>Girolami, M. and Calderhead, B., 2011. Riemann manifold Langevin and
Hamiltonian Monte Varlo methods. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 73(2), pp.123-214.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
the negative logarithm of the unnormalised density specified by
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a pair of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L581-L587" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DiagonalRiemannianMetricSystem(RiemannianMetricSystem):

    def __init__(self, neg_log_dens, metric_diagonal_func,
                 vjp_metric_diagonal_func=None, grad_neg_log_dens=None):
        super().__init__(
            neg_log_dens, PositiveDiagonalMatrix, metric_diagonal_func,
            vjp_metric_diagonal_func, grad_neg_log_dens)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h" href="#mici.systems.RiemannianMetricSystem.h">h</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian function for system </p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h1" href="#mici.systems.RiemannianMetricSystem.h1">h1</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending only on position </p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh1_dpos" href="#mici.systems.RiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position </p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h2" href="#mici.systems.RiemannianMetricSystem.h2">h2</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending on momentum and optionally position </p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh2_dmom" href="#mici.systems.RiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum </p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.sample_momentum" href="#mici.systems.RiemannianMetricSystem.sample_momentum">sample_momentum</a></code>
</p>
<section class="desc inherited"><p>Sample a momentum from its conditional distribution given a position </p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.neg_log_dens" href="#mici.systems.RiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Negative logarithm of unnormalised density of target distribution </p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.RiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Derivative of negative log density with respect to position </p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h1_flow" href="#mici.systems.RiemannianMetricSystem.h1_flow">h1_flow</a></code>
</p>
<section class="desc inherited"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component </p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh_dpos" href="#mici.systems.RiemannianMetricSystem.dh_dpos">dh_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to position </p></section>
</dd>
<dt id="mici.systems.DiagonalRiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh_dmom" href="#mici.systems.RiemannianMetricSystem.dh_dmom">dh_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to momentum </p></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">CholeskyFactoredRiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric_chol_func, vjp_metric_chol_func=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Riemannian Hamiltonian system with a position dependent metric tensor.</p>
<p>The momentum variables are assumed to have a zero-mean Gaussian conditional
distribution given the position variables, with covariance specified by a
position dependent positive-definite metric tensor [1]. Due to the coupling
between the position and momentum variables in the quadratic form of the
negative log density of the Gaussian conditional distribution on the
momentum variables, the Hamiltonian system is non-separable, requiring use
of a numerical integrator with implicit steps.</p>
<h2 id="references">References</h2>
<ol>
<li>Girolami, M. and Calderhead, B., 2011. Riemann manifold Langevin and
Hamiltonian Monte Varlo methods. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 73(2), pp.123-214.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
the negative logarithm of the unnormalised density specified by
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a pair of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L590-L596" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CholeskyFactoredRiemannianMetricSystem(RiemannianMetricSystem):

    def __init__(self, neg_log_dens, metric_chol_func,
                 vjp_metric_chol_func=None, grad_neg_log_dens=None):
        super().__init__(
            neg_log_dens, TriangularFactoredDefiniteMatrix,
            metric_chol_func, vjp_metric_chol_func, grad_neg_log_dens)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h" href="#mici.systems.RiemannianMetricSystem.h">h</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian function for system </p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h1" href="#mici.systems.RiemannianMetricSystem.h1">h1</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending only on position </p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh1_dpos" href="#mici.systems.RiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position </p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h2" href="#mici.systems.RiemannianMetricSystem.h2">h2</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending on momentum and optionally position </p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh2_dmom" href="#mici.systems.RiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum </p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.sample_momentum" href="#mici.systems.RiemannianMetricSystem.sample_momentum">sample_momentum</a></code>
</p>
<section class="desc inherited"><p>Sample a momentum from its conditional distribution given a position </p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.neg_log_dens" href="#mici.systems.RiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Negative logarithm of unnormalised density of target distribution </p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.RiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Derivative of negative log density with respect to position </p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h1_flow" href="#mici.systems.RiemannianMetricSystem.h1_flow">h1_flow</a></code>
</p>
<section class="desc inherited"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component </p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh_dpos" href="#mici.systems.RiemannianMetricSystem.dh_dpos">dh_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to position </p></section>
</dd>
<dt id="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh_dmom" href="#mici.systems.RiemannianMetricSystem.dh_dmom">dh_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to momentum </p></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">DenseRiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, metric_func, vjp_metric_func=None, grad_neg_log_dens=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Riemannian Hamiltonian system with a position dependent metric tensor.</p>
<p>The momentum variables are assumed to have a zero-mean Gaussian conditional
distribution given the position variables, with covariance specified by a
position dependent positive-definite metric tensor [1]. Due to the coupling
between the position and momentum variables in the quadratic form of the
negative log density of the Gaussian conditional distribution on the
momentum variables, the Hamiltonian system is non-separable, requiring use
of a numerical integrator with implicit steps.</p>
<h2 id="references">References</h2>
<ol>
<li>Girolami, M. and Calderhead, B., 2011. Riemann manifold Langevin and
Hamiltonian Monte Varlo methods. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 73(2), pp.123-214.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
the negative logarithm of the unnormalised density specified by
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a pair of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L599-L605" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DenseRiemannianMetricSystem(RiemannianMetricSystem):

    def __init__(self, neg_log_dens, metric_func,
                 vjp_metric_func=None, grad_neg_log_dens=None):
        super().__init__(
            neg_log_dens, DensePositiveDefiniteMatrix, metric_func,
            vjp_metric_func, grad_neg_log_dens)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.DenseRiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h" href="#mici.systems.RiemannianMetricSystem.h">h</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian function for system </p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h1" href="#mici.systems.RiemannianMetricSystem.h1">h1</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending only on position </p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh1_dpos" href="#mici.systems.RiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position </p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h2" href="#mici.systems.RiemannianMetricSystem.h2">h2</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending on momentum and optionally position </p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh2_dmom" href="#mici.systems.RiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum </p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.sample_momentum" href="#mici.systems.RiemannianMetricSystem.sample_momentum">sample_momentum</a></code>
</p>
<section class="desc inherited"><p>Sample a momentum from its conditional distribution given a position </p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.neg_log_dens" href="#mici.systems.RiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Negative logarithm of unnormalised density of target distribution </p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.RiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Derivative of negative log density with respect to position </p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h1_flow" href="#mici.systems.RiemannianMetricSystem.h1_flow">h1_flow</a></code>
</p>
<section class="desc inherited"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component </p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh_dpos" href="#mici.systems.RiemannianMetricSystem.dh_dpos">dh_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to position </p></section>
</dd>
<dt id="mici.systems.DenseRiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh_dmom" href="#mici.systems.RiemannianMetricSystem.dh_dmom">dh_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to momentum </p></section>
</dd>
</dl>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem"><code class="flex name class">
<span>class <span class="ident">SoftAbsRiemannianMetricSystem</span></span>
<span>(</span><span>neg_log_dens, grad_neg_log_dens=None, hess_neg_log_dens=None, mtp_neg_log_dens=None, softabs_coeff=1.0)</span>
</code></dt>
<dd>
<section class="desc"><p>SoftAbs Riemmanian metric Hamiltonian system.</p>
<p>Hamiltonian system with a position dependent metric tensor which is
specified to be an eigenvalue-regularised transformation of the Hessian of
the potential energy function (with the 'soft-absolute' regularisation
ensuring all the eigenvalues are strictly positive and so the resulting
metric tensor is positive definite everywhere).</p>
<p>References:</p>
<ol>
<li>Betancourt, M., 2013. A general metric for Riemannian manifold
Hamiltonian Monte Carlo. In Geometric science of information
(pp. 327-334).</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neg_log_dens</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Function which given a
position array returns the negative logarithm of an
unnormalised probability density on the position space with
respect to the Lebesgue measure, with the corresponding
distribution on the position space being the target
distribution it is wished to draw approximate samples from.</dd>
<dt><strong><code>grad_neg_log_dens</code></strong> :&ensp;</dt>
<dt><code>None</code> or <code>Callable</code>[[<code>array</code>], <code>array</code> or <code>Tuple</code>[<code>array</code>, <code>float</code>]]</dt>
<dd>
<p>Function which given a position array returns the derivative of
the negative logarithm of the unnormalised density specified by
<code>neg_log_dens</code> with respect to the position array argument.
Optionally the function may instead return a pair of values
with the first being the array corresponding to the derivative
and the second being the value of the <code>neg_log_dens</code> evaluated
at the passed position array. If <code>None</code> is passed (the default)
an automatic differentiation fallback will be used to attempt
to construct the derivative of <code>neg_log_dens</code> automatically.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L608-L654" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SoftAbsRiemannianMetricSystem(RiemannianMetricSystem):
    &#34;&#34;&#34;SoftAbs Riemmanian metric Hamiltonian system.

    Hamiltonian system with a position dependent metric tensor which is
    specified to be an eigenvalue-regularised transformation of the Hessian of
    the potential energy function (with the &#39;soft-absolute&#39; regularisation
    ensuring all the eigenvalues are strictly positive and so the resulting
    metric tensor is positive definite everywhere).

    References:

    1. Betancourt, M., 2013. A general metric for Riemannian manifold
       Hamiltonian Monte Carlo. In Geometric science of information
       (pp. 327-334).
    &#34;&#34;&#34;

    def __init__(self, neg_log_dens, grad_neg_log_dens=None,
                 hess_neg_log_dens=None, mtp_neg_log_dens=None,
                 softabs_coeff=1.):
        self._hess_neg_log_dens = autodiff_fallback(
            hess_neg_log_dens, neg_log_dens, &#39;hessian_grad_and_value&#39;,
            &#39;neg_log_dens&#39;)
        self._mtp_neg_log_dens = autodiff_fallback(
            mtp_neg_log_dens, neg_log_dens, &#39;mtp_hessian_grad_and_value&#39;,
            &#39;mtp_neg_log_dens&#39;)
        super().__init__(neg_log_dens,
                         SoftAbsRegularisedPositiveDefiniteMatrix,
                         self._hess_neg_log_dens, self._mtp_neg_log_dens,
                         grad_neg_log_dens,
                         metric_kwargs={&#39;softabs_coeff&#39;: softabs_coeff})

    def metric_func(self, state):
        return self.hess_neg_log_dens(state)

    def vjp_metric_func(self, state):
        return self.mtp_neg_log_dens(state)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;hess_neg_log_dens&#39;, &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def hess_neg_log_dens(self, state):
        return self._hess_neg_log_dens(state.pos)

    @multi_cache_in_state(
        [&#39;pos&#39;], [&#39;mtp_neg_log_dens&#39;, &#39;hess_neg_log_dens&#39;,
                  &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
    def mtp_neg_log_dens(self, state):
        return self._mtp_neg_log_dens(state.pos)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></li>
<li><a title="mici.systems.System" href="#mici.systems.System">System</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.metric_func"><code class="name flex">
<span>def <span class="ident">metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L639-L640" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def metric_func(self, state):
    return self.hess_neg_log_dens(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.vjp_metric_func"><code class="name flex">
<span>def <span class="ident">vjp_metric_func</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L642-L643" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def vjp_metric_func(self, state):
    return self.mtp_neg_log_dens(state)</code></pre>
</details>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.hess_neg_log_dens"><code class="name flex">
<span>def <span class="ident">hess_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L645-L648" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state(
    [&#39;pos&#39;], [&#39;hess_neg_log_dens&#39;, &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
def hess_neg_log_dens(self, state):
    return self._hess_neg_log_dens(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.mtp_neg_log_dens"><code class="name flex">
<span>def <span class="ident">mtp_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/931c4cd978e705a7d3c162db8658f2f38de64c49/mici/systems.py#L650-L654" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@multi_cache_in_state(
    [&#39;pos&#39;], [&#39;mtp_neg_log_dens&#39;, &#39;hess_neg_log_dens&#39;,
              &#39;grad_neg_log_dens&#39;, &#39;neg_log_dens&#39;])
def mtp_neg_log_dens(self, state):
    return self._mtp_neg_log_dens(state.pos)</code></pre>
</details>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h" href="#mici.systems.RiemannianMetricSystem.h">h</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian function for system </p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.h1"><code class="name flex">
<span>def <span class="ident">h1</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h1" href="#mici.systems.RiemannianMetricSystem.h1">h1</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending only on position </p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.dh1_dpos"><code class="name flex">
<span>def <span class="ident">dh1_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh1_dpos" href="#mici.systems.RiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h1</code> Hamiltonian component with respect to position </p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.h2"><code class="name flex">
<span>def <span class="ident">h2</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h2" href="#mici.systems.RiemannianMetricSystem.h2">h2</a></code>
</p>
<section class="desc inherited"><p>Hamiltonian component depending on momentum and optionally position </p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.dh2_dmom"><code class="name flex">
<span>def <span class="ident">dh2_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh2_dmom" href="#mici.systems.RiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of <code>h2</code> Hamiltonian component with respect to momentum </p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.sample_momentum"><code class="name flex">
<span>def <span class="ident">sample_momentum</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.sample_momentum" href="#mici.systems.RiemannianMetricSystem.sample_momentum">sample_momentum</a></code>
</p>
<section class="desc inherited"><p>Sample a momentum from its conditional distribution given a position </p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.neg_log_dens"><code class="name flex">
<span>def <span class="ident">neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.neg_log_dens" href="#mici.systems.RiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Negative logarithm of unnormalised density of target distribution </p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.grad_neg_log_dens"><code class="name flex">
<span>def <span class="ident">grad_neg_log_dens</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.RiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code>
</p>
<section class="desc inherited"><p>Derivative of negative log density with respect to position </p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.h1_flow"><code class="name flex">
<span>def <span class="ident">h1_flow</span></span>(<span>self, state, dt)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.h1_flow" href="#mici.systems.RiemannianMetricSystem.h1_flow">h1_flow</a></code>
</p>
<section class="desc inherited"><p>Apply exact flow map corresponding to <code>h1</code> Hamiltonian component </p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.dh_dpos"><code class="name flex">
<span>def <span class="ident">dh_dpos</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh_dpos" href="#mici.systems.RiemannianMetricSystem.dh_dpos">dh_dpos</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to position </p></section>
</dd>
<dt id="mici.systems.SoftAbsRiemannianMetricSystem.dh_dmom"><code class="name flex">
<span>def <span class="ident">dh_dmom</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code>.<code><a title="mici.systems.RiemannianMetricSystem.dh_dmom" href="#mici.systems.RiemannianMetricSystem.dh_dmom">dh_dmom</a></code>
</p>
<section class="desc inherited"><p>Derivative of Hamiltonian with respect to momentum </p></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="mici docs home" href="index.html">
<img width="400" src="../images/mici-logo-rectangular.svg" alt="mici">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Package</h3>
<ul>
<li><code><a title="mici" href="index.html">mici</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mici.systems.System" href="#mici.systems.System">System</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.System.neg_log_dens" href="#mici.systems.System.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.System.grad_neg_log_dens" href="#mici.systems.System.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.System.h1" href="#mici.systems.System.h1">h1</a></code></li>
<li><code><a title="mici.systems.System.dh1_dpos" href="#mici.systems.System.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.System.h1_flow" href="#mici.systems.System.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.System.h2" href="#mici.systems.System.h2">h2</a></code></li>
<li><code><a title="mici.systems.System.dh2_dmom" href="#mici.systems.System.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.System.h" href="#mici.systems.System.h">h</a></code></li>
<li><code><a title="mici.systems.System.dh_dpos" href="#mici.systems.System.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.System.dh_dmom" href="#mici.systems.System.dh_dmom">dh_dmom</a></code></li>
<li><code><a title="mici.systems.System.sample_momentum" href="#mici.systems.System.sample_momentum">sample_momentum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.EuclideanMetricSystem" href="#mici.systems.EuclideanMetricSystem">EuclideanMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.EuclideanMetricSystem.h2" href="#mici.systems.EuclideanMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.dh2_dmom" href="#mici.systems.EuclideanMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.h2_flow" href="#mici.systems.EuclideanMetricSystem.h2_flow">h2_flow</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.dh2_flow_dmom" href="#mici.systems.EuclideanMetricSystem.dh2_flow_dmom">dh2_flow_dmom</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.sample_momentum" href="#mici.systems.EuclideanMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.neg_log_dens" href="#mici.systems.EuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.EuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.h1" href="#mici.systems.EuclideanMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.dh1_dpos" href="#mici.systems.EuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.h1_flow" href="#mici.systems.EuclideanMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.h" href="#mici.systems.EuclideanMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.dh_dpos" href="#mici.systems.EuclideanMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.EuclideanMetricSystem.dh_dmom" href="#mici.systems.EuclideanMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.GaussianEuclideanMetricSystem" href="#mici.systems.GaussianEuclideanMetricSystem">GaussianEuclideanMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.h2" href="#mici.systems.GaussianEuclideanMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh2_dmom" href="#mici.systems.GaussianEuclideanMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh2_dpos" href="#mici.systems.GaussianEuclideanMetricSystem.dh2_dpos">dh2_dpos</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.h2_flow" href="#mici.systems.GaussianEuclideanMetricSystem.h2_flow">h2_flow</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh2_flow_dmom" href="#mici.systems.GaussianEuclideanMetricSystem.dh2_flow_dmom">dh2_flow_dmom</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.sample_momentum" href="#mici.systems.GaussianEuclideanMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.neg_log_dens" href="#mici.systems.GaussianEuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.GaussianEuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.h1" href="#mici.systems.GaussianEuclideanMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh1_dpos" href="#mici.systems.GaussianEuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.h1_flow" href="#mici.systems.GaussianEuclideanMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.h" href="#mici.systems.GaussianEuclideanMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh_dpos" href="#mici.systems.GaussianEuclideanMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.GaussianEuclideanMetricSystem.dh_dmom" href="#mici.systems.GaussianEuclideanMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem" href="#mici.systems.DenseConstrainedEuclideanMetricSystem">DenseConstrainedEuclideanMetricSystem</a></code></h4>
<ul class="">
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.mhp_constr" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.mhp_constr">mhp_constr</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.jacob_constr_inner_product" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.jacob_constr_inner_product">jacob_constr_inner_product</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.grad_log_det_sqrt_gram">grad_log_det_sqrt_gram</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.sample_momentum" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.neg_log_dens" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.h1" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.dh1_dpos" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.h1_flow" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.h" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dpos" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dmom" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.dh_dmom">dh_dmom</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.h2" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_dmom" href="#mici.systems.DenseConstrainedEuclideanMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem">GaussianDenseConstrainedEuclideanMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h2" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.sample_momentum" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.neg_log_dens" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.grad_neg_log_dens" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh1_dpos" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1_flow" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dpos" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dmom" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh_dmom">dh_dmom</a></code></li>
<li><code><a title="mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh2_dmom" href="#mici.systems.GaussianDenseConstrainedEuclideanMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.RiemannianMetricSystem" href="#mici.systems.RiemannianMetricSystem">RiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.RiemannianMetricSystem.metric_func" href="#mici.systems.RiemannianMetricSystem.metric_func">metric_func</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.vjp_metric_func" href="#mici.systems.RiemannianMetricSystem.vjp_metric_func">vjp_metric_func</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.metric" href="#mici.systems.RiemannianMetricSystem.metric">metric</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.h" href="#mici.systems.RiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.h1" href="#mici.systems.RiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.dh1_dpos" href="#mici.systems.RiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.h2" href="#mici.systems.RiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.dh2_dpos" href="#mici.systems.RiemannianMetricSystem.dh2_dpos">dh2_dpos</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.dh2_dmom" href="#mici.systems.RiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.sample_momentum" href="#mici.systems.RiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.neg_log_dens" href="#mici.systems.RiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.RiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.h1_flow" href="#mici.systems.RiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.dh_dpos" href="#mici.systems.RiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.RiemannianMetricSystem.dh_dmom" href="#mici.systems.RiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.ScalarRiemannianMetricSystem" href="#mici.systems.ScalarRiemannianMetricSystem">ScalarRiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.h" href="#mici.systems.ScalarRiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.h1" href="#mici.systems.ScalarRiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.dh1_dpos" href="#mici.systems.ScalarRiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.h2" href="#mici.systems.ScalarRiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.dh2_dmom" href="#mici.systems.ScalarRiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.sample_momentum" href="#mici.systems.ScalarRiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.neg_log_dens" href="#mici.systems.ScalarRiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.ScalarRiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.h1_flow" href="#mici.systems.ScalarRiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.dh_dpos" href="#mici.systems.ScalarRiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.ScalarRiemannianMetricSystem.dh_dmom" href="#mici.systems.ScalarRiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.DiagonalRiemannianMetricSystem" href="#mici.systems.DiagonalRiemannianMetricSystem">DiagonalRiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.h" href="#mici.systems.DiagonalRiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.h1" href="#mici.systems.DiagonalRiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.dh1_dpos" href="#mici.systems.DiagonalRiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.h2" href="#mici.systems.DiagonalRiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.dh2_dmom" href="#mici.systems.DiagonalRiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.sample_momentum" href="#mici.systems.DiagonalRiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.neg_log_dens" href="#mici.systems.DiagonalRiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.DiagonalRiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.h1_flow" href="#mici.systems.DiagonalRiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.dh_dpos" href="#mici.systems.DiagonalRiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.DiagonalRiemannianMetricSystem.dh_dmom" href="#mici.systems.DiagonalRiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem">CholeskyFactoredRiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.h" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.h1" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh1_dpos" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.h2" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh2_dmom" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.sample_momentum" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.neg_log_dens" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.h1_flow" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dpos" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dmom" href="#mici.systems.CholeskyFactoredRiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.DenseRiemannianMetricSystem" href="#mici.systems.DenseRiemannianMetricSystem">DenseRiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.h" href="#mici.systems.DenseRiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.h1" href="#mici.systems.DenseRiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.dh1_dpos" href="#mici.systems.DenseRiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.h2" href="#mici.systems.DenseRiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.dh2_dmom" href="#mici.systems.DenseRiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.sample_momentum" href="#mici.systems.DenseRiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.neg_log_dens" href="#mici.systems.DenseRiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.DenseRiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.h1_flow" href="#mici.systems.DenseRiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.dh_dpos" href="#mici.systems.DenseRiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.DenseRiemannianMetricSystem.dh_dmom" href="#mici.systems.DenseRiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.systems.SoftAbsRiemannianMetricSystem" href="#mici.systems.SoftAbsRiemannianMetricSystem">SoftAbsRiemannianMetricSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.metric_func" href="#mici.systems.SoftAbsRiemannianMetricSystem.metric_func">metric_func</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.vjp_metric_func" href="#mici.systems.SoftAbsRiemannianMetricSystem.vjp_metric_func">vjp_metric_func</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.hess_neg_log_dens" href="#mici.systems.SoftAbsRiemannianMetricSystem.hess_neg_log_dens">hess_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.mtp_neg_log_dens" href="#mici.systems.SoftAbsRiemannianMetricSystem.mtp_neg_log_dens">mtp_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.h" href="#mici.systems.SoftAbsRiemannianMetricSystem.h">h</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.h1" href="#mici.systems.SoftAbsRiemannianMetricSystem.h1">h1</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.dh1_dpos" href="#mici.systems.SoftAbsRiemannianMetricSystem.dh1_dpos">dh1_dpos</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.h2" href="#mici.systems.SoftAbsRiemannianMetricSystem.h2">h2</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.dh2_dmom" href="#mici.systems.SoftAbsRiemannianMetricSystem.dh2_dmom">dh2_dmom</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.sample_momentum" href="#mici.systems.SoftAbsRiemannianMetricSystem.sample_momentum">sample_momentum</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.neg_log_dens" href="#mici.systems.SoftAbsRiemannianMetricSystem.neg_log_dens">neg_log_dens</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.grad_neg_log_dens" href="#mici.systems.SoftAbsRiemannianMetricSystem.grad_neg_log_dens">grad_neg_log_dens</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.h1_flow" href="#mici.systems.SoftAbsRiemannianMetricSystem.h1_flow">h1_flow</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.dh_dpos" href="#mici.systems.SoftAbsRiemannianMetricSystem.dh_dpos">dh_dpos</a></code></li>
<li><code><a title="mici.systems.SoftAbsRiemannianMetricSystem.dh_dmom" href="#mici.systems.SoftAbsRiemannianMetricSystem.dh_dmom">dh_dmom</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
Copyright  2019 Matt Graham
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>