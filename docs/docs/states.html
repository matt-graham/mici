<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>mici.states API documentation</title>
<meta name="description" content="Objects for recording state of a Markov chain." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>mici.states</code></h1>
</header>
<section id="section-intro">
<p>Objects for recording state of a Markov chain.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/fa4d7f0c3188b6d00a78ecaecb001fecf7d8b0d7/mici/states.py#L0-L156" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Objects for recording state of a Markov chain.&#34;&#34;&#34;

import copy
from functools import wraps


def cache_in_state(*depends_on):
    &#34;&#34;&#34;Decorator to memoize / cache output of a function of state variable(s).

    Used to wrap functions of a chain state vaiable(s) to allow caching of
    the values computed to prevent recomputation when possible.

    Args:
       *depends_on: One or more strings defining which state variables the
           computed values depend on e.g. &#39;pos&#39;, &#39;mom&#39;, such that the cache is
           correctly cleared when one of these parent dependency&#39;s value
           changes.
    &#34;&#34;&#34;
    def cache_in_state_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            key = (type(self).__name__ + &#39;.&#39; + method.__name__, id(self))
            if key not in state._cache:
                for dep in depends_on:
                    state._dependencies[dep].add(key)
            if key not in state._cache or state._cache[key] is None:
                state._cache[key] = method(self, state)
            return state._cache[key]
        return wrapper
    return cache_in_state_decorator


def multi_cache_in_state(depends_on, vars, primary_index=0):
    &#34;&#34;&#34;Decorator to cache multiple outputs of a function of state variable(s).

    Used to wrap functions of a chain state vaiable(s) to allow caching of
    the values computed to prevent recomputation when possible.

    This variant allows for functions which also cache intermediate computed
    results which may be used separately elsewhere for example the value of a
    function calculate in the forward pass of a reverse-mode automatic-
    differentation implementation of its gradient.

    Args:
        depends_on (List[str]): A list of strings defining which state
            variables the computed values depend on e.g. `[&#39;pos&#39;, &#39;mom&#39;]`, such
            that the cache is correctly cleared when one of these parent
            dependency&#39;s value changes.
        vars (List[str]): A list of strings defining the variables in the state
            cache dict corresponding to the outputs of the wrapped function
            (method) in the corresponding returned order.
        primary_index (int): Index of primary output of function (i.e. value to
            be returned) in vars list / position in output of function.
    &#34;&#34;&#34;
    def multi_cache_in_state_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            id_ = id(self)
            type_prefix = type(self).__name__ + &#39;.&#39;
            prim_key = (type_prefix + vars[primary_index], id_)
            keys = [(type_prefix + v, id_) for v in vars]
            for i, key in enumerate(keys):
                if key not in state._cache:
                    for dep in depends_on:
                        state._dependencies[dep].add(key)
            if prim_key not in state._cache or state._cache[prim_key] is None:
                vals = method(self, state)
                if isinstance(vals, tuple):
                    for k, v in zip(keys, vals):
                        state._cache[k] = v
                else:
                    state._cache[prim_key] = vals
            return state._cache[prim_key]
        return wrapper
    return multi_cache_in_state_decorator


class ChainState(object):
    &#34;&#34;&#34;Markov chain state.

    As well as recording the chain state variable values, the state object is
    also used to cache derived quantities to avoid recalculation if these
    values are subsequently reused.
    &#34;&#34;&#34;

    def __init__(self, _dependencies=None, _cache=None, **vars):
        &#34;&#34;&#34;Create a new `ChainState` instance.

        Any keyword arguments passed to the constructor will be used to set
        state variable attributes of state object for example

            state = ChainState(pos=pos_val, mom=mom_val, dir=dir_val)

        will return a `ChainState` instance `state` with variable attributes
        `state.pos`, `state.mom` and `state.dir` with initial values set to
        `pos_val`, `mom_val` and `dir_val` respectively. The keyword arguments
        `_dependencies` and `_cache` are reserved for the dependency set and
        cache dictionary respectively used to implement the caching of derived
        quantities and cannot be used as state variable names.
        &#34;&#34;&#34;
        # set vars attribute by directly writing to __dict__ to ensure set
        # before any cally to __setattr__
        self.__dict__[&#39;vars&#39;] = vars
        if _dependencies is None:
            _dependencies = {name: set() for name in vars}
        self._dependencies = _dependencies
        if _cache is None:
            _cache = {}
        self._cache = _cache

    def __getattr__(self, name):
        if name in self.vars:
            return self.vars[name]
        else:
            raise AttributeError(
                f&#34;&#39;{type(self).__name__}&#39; object has no attribute &#39;{name}&#39;&#34;)

    def __setattr__(self, name, value):
        if name in self.vars:
            self.vars[name] = value
            # clear any dependent cached values
            for dep in self._dependencies[name]:
                self._cache[dep] = None
        else:
            return super().__setattr__(name, value)

    def __contains__(self, name):
        return name in self.vars

    def copy(self):
        &#34;&#34;&#34;Create a deep copy of the state object.

        Returns:
            state_copy (ChainState): A copy of the state object which can be
                updated without affecting the original object&#39;s attributes.
        &#34;&#34;&#34;
        return type(self)(
            _cache=self._cache.copy(), _dependencies=self._dependencies,
            **{name: copy.copy(val) for name, val in self.vars.items()})

    def __str__(self):
        return (
            &#39;(\n &#39; +
            &#39;,\n &#39;.join([f&#39;{name}={val}&#39; for name, val in self.vars.items()]) +
            &#39;)&#39;
        )

    def __repr__(self):
        return type(self).__name__ + str(self)

    def __getstate__(self):
        return self.vars

    def __setstate__(self, state):
        self.__dict__[&#39;vars&#39;] = state
        self._dependencies = {name: set() for name in self.vars}
        self._cache = {}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mici.states.cache_in_state"><code class="name flex">
<span>def <span class="ident">cache_in_state</span></span>(<span>*depends_on)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorator to memoize / cache output of a function of state variable(s).</p>
<p>Used to wrap functions of a chain state vaiable(s) to allow caching of
the values computed to prevent recomputation when possible.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*depends_on</code></strong></dt>
<dd>One or more strings defining which state variables the
computed values depend on e.g. 'pos', 'mom', such that the cache is
correctly cleared when one of these parent dependency's value
changes.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/fa4d7f0c3188b6d00a78ecaecb001fecf7d8b0d7/mici/states.py#L7-L30" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cache_in_state(*depends_on):
    &#34;&#34;&#34;Decorator to memoize / cache output of a function of state variable(s).

    Used to wrap functions of a chain state vaiable(s) to allow caching of
    the values computed to prevent recomputation when possible.

    Args:
       *depends_on: One or more strings defining which state variables the
           computed values depend on e.g. &#39;pos&#39;, &#39;mom&#39;, such that the cache is
           correctly cleared when one of these parent dependency&#39;s value
           changes.
    &#34;&#34;&#34;
    def cache_in_state_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            key = (type(self).__name__ + &#39;.&#39; + method.__name__, id(self))
            if key not in state._cache:
                for dep in depends_on:
                    state._dependencies[dep].add(key)
            if key not in state._cache or state._cache[key] is None:
                state._cache[key] = method(self, state)
            return state._cache[key]
        return wrapper
    return cache_in_state_decorator</code></pre>
</details>
</dd>
<dt id="mici.states.multi_cache_in_state"><code class="name flex">
<span>def <span class="ident">multi_cache_in_state</span></span>(<span>depends_on, vars, primary_index=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorator to cache multiple outputs of a function of state variable(s).</p>
<p>Used to wrap functions of a chain state vaiable(s) to allow caching of
the values computed to prevent recomputation when possible.</p>
<p>This variant allows for functions which also cache intermediate computed
results which may be used separately elsewhere for example the value of a
function calculate in the forward pass of a reverse-mode automatic-
differentation implementation of its gradient.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>depends_on</code></strong> :&ensp;<code>List</code>[<code>str</code>]</dt>
<dd>A list of strings defining which state
variables the computed values depend on e.g. <code>['pos', 'mom']</code>, such
that the cache is correctly cleared when one of these parent
dependency's value changes.</dd>
<dt><strong><code>vars</code></strong> :&ensp;<code>List</code>[<code>str</code>]</dt>
<dd>A list of strings defining the variables in the state
cache dict corresponding to the outputs of the wrapped function
(method) in the corresponding returned order.</dd>
<dt><strong><code>primary_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of primary output of function (i.e. value to
be returned) in vars list / position in output of function.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/fa4d7f0c3188b6d00a78ecaecb001fecf7d8b0d7/mici/states.py#L33-L75" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def multi_cache_in_state(depends_on, vars, primary_index=0):
    &#34;&#34;&#34;Decorator to cache multiple outputs of a function of state variable(s).

    Used to wrap functions of a chain state vaiable(s) to allow caching of
    the values computed to prevent recomputation when possible.

    This variant allows for functions which also cache intermediate computed
    results which may be used separately elsewhere for example the value of a
    function calculate in the forward pass of a reverse-mode automatic-
    differentation implementation of its gradient.

    Args:
        depends_on (List[str]): A list of strings defining which state
            variables the computed values depend on e.g. `[&#39;pos&#39;, &#39;mom&#39;]`, such
            that the cache is correctly cleared when one of these parent
            dependency&#39;s value changes.
        vars (List[str]): A list of strings defining the variables in the state
            cache dict corresponding to the outputs of the wrapped function
            (method) in the corresponding returned order.
        primary_index (int): Index of primary output of function (i.e. value to
            be returned) in vars list / position in output of function.
    &#34;&#34;&#34;
    def multi_cache_in_state_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            id_ = id(self)
            type_prefix = type(self).__name__ + &#39;.&#39;
            prim_key = (type_prefix + vars[primary_index], id_)
            keys = [(type_prefix + v, id_) for v in vars]
            for i, key in enumerate(keys):
                if key not in state._cache:
                    for dep in depends_on:
                        state._dependencies[dep].add(key)
            if prim_key not in state._cache or state._cache[prim_key] is None:
                vals = method(self, state)
                if isinstance(vals, tuple):
                    for k, v in zip(keys, vals):
                        state._cache[k] = v
                else:
                    state._cache[prim_key] = vals
            return state._cache[prim_key]
        return wrapper
    return multi_cache_in_state_decorator</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mici.states.ChainState"><code class="flex name class">
<span>class <span class="ident">ChainState</span></span>
<span>(</span><span>**vars)</span>
</code></dt>
<dd>
<section class="desc"><p>Markov chain state.</p>
<p>As well as recording the chain state variable values, the state object is
also used to cache derived quantities to avoid recalculation if these
values are subsequently reused.</p>
<p>Create a new <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a> instance.</p>
<p>Any keyword arguments passed to the constructor will be used to set
state variable attributes of state object for example</p>
<pre><code>state = ChainState(pos=pos_val, mom=mom_val, dir=dir_val)
</code></pre>
<p>will return a <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a> instance <code>state</code> with variable attributes
<code>state.pos</code>, <code>state.mom</code> and <code>state.dir</code> with initial values set to
<code>pos_val</code>, <code>mom_val</code> and <code>dir_val</code> respectively. The keyword arguments
<code>_dependencies</code> and <code>_cache</code> are reserved for the dependency set and
cache dictionary respectively used to implement the caching of derived
quantities and cannot be used as state variable names.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/fa4d7f0c3188b6d00a78ecaecb001fecf7d8b0d7/mici/states.py#L78-L157" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ChainState(object):
    &#34;&#34;&#34;Markov chain state.

    As well as recording the chain state variable values, the state object is
    also used to cache derived quantities to avoid recalculation if these
    values are subsequently reused.
    &#34;&#34;&#34;

    def __init__(self, _dependencies=None, _cache=None, **vars):
        &#34;&#34;&#34;Create a new `ChainState` instance.

        Any keyword arguments passed to the constructor will be used to set
        state variable attributes of state object for example

            state = ChainState(pos=pos_val, mom=mom_val, dir=dir_val)

        will return a `ChainState` instance `state` with variable attributes
        `state.pos`, `state.mom` and `state.dir` with initial values set to
        `pos_val`, `mom_val` and `dir_val` respectively. The keyword arguments
        `_dependencies` and `_cache` are reserved for the dependency set and
        cache dictionary respectively used to implement the caching of derived
        quantities and cannot be used as state variable names.
        &#34;&#34;&#34;
        # set vars attribute by directly writing to __dict__ to ensure set
        # before any cally to __setattr__
        self.__dict__[&#39;vars&#39;] = vars
        if _dependencies is None:
            _dependencies = {name: set() for name in vars}
        self._dependencies = _dependencies
        if _cache is None:
            _cache = {}
        self._cache = _cache

    def __getattr__(self, name):
        if name in self.vars:
            return self.vars[name]
        else:
            raise AttributeError(
                f&#34;&#39;{type(self).__name__}&#39; object has no attribute &#39;{name}&#39;&#34;)

    def __setattr__(self, name, value):
        if name in self.vars:
            self.vars[name] = value
            # clear any dependent cached values
            for dep in self._dependencies[name]:
                self._cache[dep] = None
        else:
            return super().__setattr__(name, value)

    def __contains__(self, name):
        return name in self.vars

    def copy(self):
        &#34;&#34;&#34;Create a deep copy of the state object.

        Returns:
            state_copy (ChainState): A copy of the state object which can be
                updated without affecting the original object&#39;s attributes.
        &#34;&#34;&#34;
        return type(self)(
            _cache=self._cache.copy(), _dependencies=self._dependencies,
            **{name: copy.copy(val) for name, val in self.vars.items()})

    def __str__(self):
        return (
            &#39;(\n &#39; +
            &#39;,\n &#39;.join([f&#39;{name}={val}&#39; for name, val in self.vars.items()]) +
            &#39;)&#39;
        )

    def __repr__(self):
        return type(self).__name__ + str(self)

    def __getstate__(self):
        return self.vars

    def __setstate__(self, state):
        self.__dict__[&#39;vars&#39;] = state
        self._dependencies = {name: set() for name in self.vars}
        self._cache = {}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mici.states.ChainState.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a deep copy of the state object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state_copy</code></strong> :&ensp;<a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>A copy of the state object which can be
updated without affecting the original object's attributes.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/fa4d7f0c3188b6d00a78ecaecb001fecf7d8b0d7/mici/states.py#L130-L139" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;Create a deep copy of the state object.

    Returns:
        state_copy (ChainState): A copy of the state object which can be
            updated without affecting the original object&#39;s attributes.
    &#34;&#34;&#34;
    return type(self)(
        _cache=self._cache.copy(), _dependencies=self._dependencies,
        **{name: copy.copy(val) for name, val in self.vars.items()})</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="mici docs home" href="index.html">
<img width="400" src="../images/mici-logo-rectangular.svg" alt="mici">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Package</h3>
<ul>
<li><code><a title="mici" href="index.html">mici</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mici.states.cache_in_state" href="#mici.states.cache_in_state">cache_in_state</a></code></li>
<li><code><a title="mici.states.multi_cache_in_state" href="#mici.states.multi_cache_in_state">multi_cache_in_state</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mici.states.ChainState" href="#mici.states.ChainState">ChainState</a></code></h4>
<ul class="">
<li><code><a title="mici.states.ChainState.copy" href="#mici.states.ChainState.copy">copy</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
Copyright Â© 2019 Matt Graham
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>