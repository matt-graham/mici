<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2.dev0+g1b644f6.d20200630" />
<title>mici.states API documentation</title>
<meta name="description" content="Objects for recording state of a Markov chain and caching computations." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding-top:5px;padding-bottom:5px;padding-right:10px;padding-left:35px;text-indent:-25px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:1000px){#sidebar{width:540px;position:fixed;z-index:1;top:0;bottom:0;overflow-x:hidden;overflow-y:auto}#content{margin-left:540px;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}#footer{margin-left:540px}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="mici docs home" href="index.html">
<img width="400" src="../images/mici-logo-rectangular.svg" alt="mici">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Package</h3>
<ul>
<li><code><a title="mici" href="index.html">mici</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mici.states.cache_in_state" href="#mici.states.cache_in_state">cache_in_state</a></code></li>
<li><code><a title="mici.states.cache_in_state_with_aux" href="#mici.states.cache_in_state_with_aux">cache_in_state_with_aux</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<code><a title="mici.states.ChainState" href="#mici.states.ChainState">ChainState</a></code>
<ul class="">
<li><code><a title="mici.states.ChainState.copy" href="#mici.states.ChainState.copy">copy</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<article id="content">
<header>
<h1 class="title">Module <code>mici.states</code></h1>
</header>
<section id="section-intro">
<p>Objects for recording state of a Markov chain and caching computations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/aaaad1aae5ce2d12baf95e59bc5ade40149c397b/mici/states.py#L0-L271" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Objects for recording state of a Markov chain and caching computations.&#34;&#34;&#34;

import copy
from functools import wraps
from collections import Counter
from mici.errors import ReadOnlyStateError


def _cache_key_func(system, method):
    &#34;&#34;&#34;Construct cache key for a given system and method pair.&#34;&#34;&#34;
    if not isinstance(method, str):
        method = method.__name__
    return (f&#39;{type(system).__name__}.{method}&#39;, id(system))


def cache_in_state(*depends_on):
    &#34;&#34;&#34;Memoizing decorator for system methods.

    Used to decorate `mici.systems.System` methods which compute a function of
    one or more chain state variable(s), with the decorated method caching the
    value returned by the method being wrapped in the `ChainState` object to
    prevent the need for recomputation on future calls if the state variables
    the returned value depends on have not been changed in between the calls.

    Additionally for `ChainState` instances initialized with a `_call_counts`
    argument, the memoized method will update a counter for the method in the
    `_call_counts` attribute every time the method being decorated is called
    (i.e. when there isn&#39;t a valid cached value available).

    Args:
       *depends_on: One or more strings corresponding to the names of any state
           variables the value returned by the method depends on, e.g. &#39;pos&#39; or
           &#39;mom&#39;, such that the cache in the state object is correctly cleared
           when the value of any of these variables (attributes) of the state
           object changes.
    &#34;&#34;&#34;
    def cache_in_state_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            key = _cache_key_func(self, method)
            if key not in state._cache:
                for dep in depends_on:
                    state._dependencies[dep].add(key)
            if key not in state._cache or state._cache[key] is None:
                state._cache[key] = method(self, state)
                if state._call_counts is not None:
                    state._call_counts[key] += 1
            return state._cache[key]
        return wrapper
    return cache_in_state_decorator


def cache_in_state_with_aux(depends_on, auxiliary_outputs):
    &#34;&#34;&#34;Memoizing decorator for system methods with possible auxiliary outputs.

    Used to decorate `mici.systems.System` methods which compute a function of
    one or more chain state variable(s), with the decorated method caching the
    value or values returned by the method being wrapped in the `ChainState`
    object to prevent the need for recomputation on future calls if the state
    variables the returned value(s) depends on have not been changed in between
    the calls.

    Compared to the `cache_in_state` decorator, this variant allows for methods
    which may optionally also return additional auxiliary outputs, such as
    intermediate result computed while computing the primary output, which
    correspond to the output of another system method decorated with the
    `cache_in_state` or `cache_in_state_with_aux` decorators. If such auxiliary
    outputs are returned they are also used to update cache entry for the
    corresponding decorated method, potentially saving recomputation in
    subsequent calls to that method. A common instance of this pattern is in
    derivative values computed using automatic differentiation (AD), with the
    primal value being differentiated usually either calculated alongside the
    derivative (in forward-mode AD) or calculated first in a forward-pass before
    the derivatives are calculated in a reverse-pass (in reverse-mode AD). By
    caching the value of the primal computed as part of the derivative
    calculation, a subsequent call to a method corresponding to calculation of
    the primal itself will retrieve the cached value and not recompute the
    primal, providing the relevant state variables the primal (and derivative)
    depend on have not been changed in between.

    Additionally for `ChainState` instances initialized with a `_call_counts`
    argument, the memoized method will update a counter for the method in the
    `_call_counts` attribute every time the method being decorated is called
    (i.e. when there isn&#39;t a valid cached value available).

    Args:
        depends_on (str or Tuple[str]): A string or tuple of strings, with each
            string corresponding to the name of a state variables the value(s)
            returned by the method depends on, e.g. &#39;pos&#39; or &#39;mom&#39;, such that
            the cache in the state object is correctly cleared when the value of
            any of these variables (attributes) of the state object changes.
        auxiliary_outputs (str or Tuple[str]): A string or tuple of strings,
            with each string defining an auxiliary output the wrapped method may
            additionally return in addition to the primary output. If auxiliary
            outputs are returned, the returned value should be a tuple with
            first entry the &#39;primary&#39; output corresponding to the value
            associated with the name of the method and the subsequent entries in
            the tuple corresponding to the auxiliary outputs in the order
            specified by the entries in the `auxiliary_outputs` argument. If the
            primary output is itself a tuple, it must be wrapped in another
            tuple even when no auxiliary outputs are being returned.
    &#34;&#34;&#34;
    if isinstance(depends_on, str):
        depends_on = (depends_on,)
    if isinstance(auxiliary_outputs, str):
        auxiliary_outputs = (auxiliary_outputs,)

    def cache_in_state_with_aux_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            prim_key = _cache_key_func(self, method)
            keys = [prim_key] + [
                _cache_key_func(self, a) for a in auxiliary_outputs]
            for i, key in enumerate(keys):
                if key not in state._cache:
                    for dep in depends_on:
                        state._dependencies[dep].add(key)
            if prim_key not in state._cache or state._cache[prim_key] is None:
                vals = method(self, state)
                if isinstance(vals, tuple):
                    for k, v in zip(keys, vals):
                        state._cache[k] = v
                else:
                    state._cache[prim_key] = vals
                if state._call_counts is not None:
                    state._call_counts[prim_key] += 1
            return state._cache[prim_key]
        return wrapper

    return cache_in_state_with_aux_decorator


class ChainState(object):
    &#34;&#34;&#34;Markov chain state.

    As well as recording the chain state variable values, the state object is
    also used to cache derived quantities to avoid recalculation if these
    values are subsequently reused.

    Additionally for `ChainState` instances initialized with a `_call_counts`
    dictionary, any memoized system methods (i.e. those decorated with
    `cache_in_state` or `cache_in_state_with_aux`) will update a counter for the
    method in the state `_call_counts` dictionary attribute every time the
    decorated method is called (i.e. when there isn&#39;t a valid cached value
    available).
    &#34;&#34;&#34;

    def __init__(self, *, _call_counts=None, _read_only=False,
                 _dependencies=None, _cache=None, **variables):
        &#34;&#34;&#34;Create a new `ChainState` instance.

        Any keyword arguments passed to the constructor (with names not starting
        with an underscore) will be used to set state variable attributes of
        state object for example

            state = ChainState(pos=pos_val, mom=mom_val, dir=dir_val)

        will return a `ChainState` instance `state` with variable attributes
        `state.pos`, `state.mom` and `state.dir` with initial values set to
        `pos_val`, `mom_val` and `dir_val` respectively.

        Keyword arguments with a leading underscore in the name are reserved
        for additional arguments to the constructor not corresponding to
        state variables. Additionally the name `copy` should not be used as
        attribute access to this name will be blocked by the `copy` method.

        Kwargs:
            **variables: Keyword arguments corresponding to state variables. All
                names must not begin with an underscore and no name can be
                `copy`. See description above for details.
            _call_counts (None or Dict): If a dictionary is passed this will be
                used to store counts of the number of calls of system methods
                decorated with `cache_in_state` or `cache_in_state_with_aux`
                when called on this state object and when no cached value for
                the method is available so that the wrapped method is called.
                The `_call_counts` dictionary persists between all copies of a
                state so will count any decorated method calls on copies of the
                state as well - e.g. all copies of a state in a sampled Markov
                chain, allowing the `_call_counts` dictionary to be used to
                monitor the number of method call while sampling a chain.
            _read_only (bool): If `True` a `mici.errors.ReadOnlyStateError`
                exception will be raised when attempting to set any attributes
                of the state object after construction. Defaults to `False`.
            _dependencies (None or Dict): Intended for internal use only. If not
                `None` this should be a dictionary with string keys
                corresponding to the state variable names and values which are
                sets of strings indicating any dependencies of the relevant
                state variable in the cache.
            _cache (None or Dict): Intended for internal use only. If not `None`
                this should be a dictionary with keys corresponding to unique
                identifiers for methods decorated with the `cache_in_state` or
                `cache_in_state_with_aux` decorators and values corresponding
                to cached computed outputs of these methods or `None` for when
                a cached output is not available.
        &#34;&#34;&#34;
        # Set attributes by directly writing to __dict__ to ensure set before
        # any call to __setattr__
        self.__dict__[&#39;_variables&#39;] = variables
        if _dependencies is None:
            _dependencies = {name: set() for name in variables}
        self.__dict__[&#39;_dependencies&#39;] = _dependencies
        if _cache is None:
            _cache = {}
        self.__dict__[&#39;_cache&#39;] = _cache
        self.__dict__[&#39;_call_counts&#39;] = (
            Counter(_call_counts) if not isinstance(_call_counts, Counter)
            else _call_counts)
        self.__dict__[&#39;_read_only&#39;] = _read_only

    def __getattr__(self, name):
        if name in self._variables:
            return self._variables[name]
        else:
            raise AttributeError(
                f&#34;&#39;{type(self).__name__}&#39; object has no attribute &#39;{name}&#39;&#34;)

    def __setattr__(self, name, value):
        if self._read_only:
            raise ReadOnlyStateError(&#39;ChainState instance is read-only.&#39;)
        if name in self._variables:
            self._variables[name] = value
            # clear any dependent cached values
            for dep in self._dependencies[name]:
                self._cache[dep] = None
        else:
            return super().__setattr__(name, value)

    def __contains__(self, name):
        return name in self._variables

    def copy(self, read_only=False):
        &#34;&#34;&#34;Create a deep copy of the state object.

        Args:
            read_only (bool): Whether the state copy should be read-only.

        Returns:
            state_copy (ChainState): A copy of the state object with variable
                attributes that are independent copies of the original state
                object&#39;s variables.
        &#34;&#34;&#34;
        return type(self)(
            _dependencies=self._dependencies, _cache=self._cache.copy(),
            _call_counts=self._call_counts, _read_only=read_only,
            **{name: copy.copy(val) for name, val in self._variables.items()})

    def __str__(self):
        return (
            &#39;(\n &#39; +
            &#39;,\n &#39;.join([f&#39;{k}={v}&#39; for k, v in self._variables.items()]) +
            &#39;)&#39;
        )

    def __repr__(self):
        return type(self).__name__ + str(self)

    def __getstate__(self):
        return {
            &#39;variables&#39;: self._variables,
            &#39;dependencies&#39;: self._dependencies,
            # Don&#39;t pickle callable cached &#39;variables&#39; such as derivative
            # functions
            &#39;cache&#39;: {k: v for k, v in self._cache.items() if not callable(v)},
            &#39;call_counts&#39;: self._call_counts,
            &#39;read_only&#39;: self._read_only}

    def __setstate__(self, state):
        self.__dict__[&#39;_variables&#39;] = state[&#39;variables&#39;]
        self.__dict__[&#39;_dependencies&#39;] = state[&#39;dependencies&#39;]
        self.__dict__[&#39;_cache&#39;] = state[&#39;cache&#39;]
        self.__dict__[&#39;_call_counts&#39;] = state[&#39;call_counts&#39;]
        self.__dict__[&#39;_read_only&#39;] = state[&#39;read_only&#39;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mici.states.cache_in_state"><code class="name flex">
<span>def <span class="ident">cache_in_state</span></span>(<span>*depends_on)</span>
</code></dt>
<dd>
<section class="desc"><p>Memoizing decorator for system methods.</p>
<p>Used to decorate <a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a> methods which compute a function of
one or more chain state variable(s), with the decorated method caching the
value returned by the method being wrapped in the <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a> object to
prevent the need for recomputation on future calls if the state variables
the returned value depends on have not been changed in between the calls.</p>
<p>Additionally for <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a> instances initialized with a <code>_call_counts</code>
argument, the memoized method will update a counter for the method in the
<code>_call_counts</code> attribute every time the method being decorated is called
(i.e. when there isn't a valid cached value available).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*depends_on</code></strong></dt>
<dd>One or more strings corresponding to the names of any state
variables the value returned by the method depends on, e.g. 'pos' or
'mom', such that the cache in the state object is correctly cleared
when the value of any of these variables (attributes) of the state
object changes.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/aaaad1aae5ce2d12baf95e59bc5ade40149c397b/mici/states.py#L16-L50" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cache_in_state(*depends_on):
    &#34;&#34;&#34;Memoizing decorator for system methods.

    Used to decorate `mici.systems.System` methods which compute a function of
    one or more chain state variable(s), with the decorated method caching the
    value returned by the method being wrapped in the `ChainState` object to
    prevent the need for recomputation on future calls if the state variables
    the returned value depends on have not been changed in between the calls.

    Additionally for `ChainState` instances initialized with a `_call_counts`
    argument, the memoized method will update a counter for the method in the
    `_call_counts` attribute every time the method being decorated is called
    (i.e. when there isn&#39;t a valid cached value available).

    Args:
       *depends_on: One or more strings corresponding to the names of any state
           variables the value returned by the method depends on, e.g. &#39;pos&#39; or
           &#39;mom&#39;, such that the cache in the state object is correctly cleared
           when the value of any of these variables (attributes) of the state
           object changes.
    &#34;&#34;&#34;
    def cache_in_state_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            key = _cache_key_func(self, method)
            if key not in state._cache:
                for dep in depends_on:
                    state._dependencies[dep].add(key)
            if key not in state._cache or state._cache[key] is None:
                state._cache[key] = method(self, state)
                if state._call_counts is not None:
                    state._call_counts[key] += 1
            return state._cache[key]
        return wrapper
    return cache_in_state_decorator</code></pre>
</details>
</dd>
<dt id="mici.states.cache_in_state_with_aux"><code class="name flex">
<span>def <span class="ident">cache_in_state_with_aux</span></span>(<span>depends_on, auxiliary_outputs)</span>
</code></dt>
<dd>
<section class="desc"><p>Memoizing decorator for system methods with possible auxiliary outputs.</p>
<p>Used to decorate <a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a> methods which compute a function of
one or more chain state variable(s), with the decorated method caching the
value or values returned by the method being wrapped in the <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a>
object to prevent the need for recomputation on future calls if the state
variables the returned value(s) depends on have not been changed in between
the calls.</p>
<p>Compared to the <a title="mici.states.cache_in_state" href="#mici.states.cache_in_state"><code>cache_in_state()</code></a> decorator, this variant allows for methods
which may optionally also return additional auxiliary outputs, such as
intermediate result computed while computing the primary output, which
correspond to the output of another system method decorated with the
<a title="mici.states.cache_in_state" href="#mici.states.cache_in_state"><code>cache_in_state()</code></a> or <a title="mici.states.cache_in_state_with_aux" href="#mici.states.cache_in_state_with_aux"><code>cache_in_state_with_aux()</code></a> decorators. If such auxiliary
outputs are returned they are also used to update cache entry for the
corresponding decorated method, potentially saving recomputation in
subsequent calls to that method. A common instance of this pattern is in
derivative values computed using automatic differentiation (AD), with the
primal value being differentiated usually either calculated alongside the
derivative (in forward-mode AD) or calculated first in a forward-pass before
the derivatives are calculated in a reverse-pass (in reverse-mode AD). By
caching the value of the primal computed as part of the derivative
calculation, a subsequent call to a method corresponding to calculation of
the primal itself will retrieve the cached value and not recompute the
primal, providing the relevant state variables the primal (and derivative)
depend on have not been changed in between.</p>
<p>Additionally for <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a> instances initialized with a <code>_call_counts</code>
argument, the memoized method will update a counter for the method in the
<code>_call_counts</code> attribute every time the method being decorated is called
(i.e. when there isn't a valid cached value available).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>depends_on</code></strong> :&ensp;<code>str</code> or <code>Tuple</code>[<code>str</code>]</dt>
<dd>A string or tuple of strings, with each
string corresponding to the name of a state variables the value(s)
returned by the method depends on, e.g. 'pos' or 'mom', such that
the cache in the state object is correctly cleared when the value of
any of these variables (attributes) of the state object changes.</dd>
<dt><strong><code>auxiliary_outputs</code></strong> :&ensp;<code>str</code> or <code>Tuple</code>[<code>str</code>]</dt>
<dd>A string or tuple of strings,
with each string defining an auxiliary output the wrapped method may
additionally return in addition to the primary output. If auxiliary
outputs are returned, the returned value should be a tuple with
first entry the 'primary' output corresponding to the value
associated with the name of the method and the subsequent entries in
the tuple corresponding to the auxiliary outputs in the order
specified by the entries in the <code>auxiliary_outputs</code> argument. If the
primary output is itself a tuple, it must be wrapped in another
tuple even when no auxiliary outputs are being returned.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/aaaad1aae5ce2d12baf95e59bc5ade40149c397b/mici/states.py#L53-L130" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cache_in_state_with_aux(depends_on, auxiliary_outputs):
    &#34;&#34;&#34;Memoizing decorator for system methods with possible auxiliary outputs.

    Used to decorate `mici.systems.System` methods which compute a function of
    one or more chain state variable(s), with the decorated method caching the
    value or values returned by the method being wrapped in the `ChainState`
    object to prevent the need for recomputation on future calls if the state
    variables the returned value(s) depends on have not been changed in between
    the calls.

    Compared to the `cache_in_state` decorator, this variant allows for methods
    which may optionally also return additional auxiliary outputs, such as
    intermediate result computed while computing the primary output, which
    correspond to the output of another system method decorated with the
    `cache_in_state` or `cache_in_state_with_aux` decorators. If such auxiliary
    outputs are returned they are also used to update cache entry for the
    corresponding decorated method, potentially saving recomputation in
    subsequent calls to that method. A common instance of this pattern is in
    derivative values computed using automatic differentiation (AD), with the
    primal value being differentiated usually either calculated alongside the
    derivative (in forward-mode AD) or calculated first in a forward-pass before
    the derivatives are calculated in a reverse-pass (in reverse-mode AD). By
    caching the value of the primal computed as part of the derivative
    calculation, a subsequent call to a method corresponding to calculation of
    the primal itself will retrieve the cached value and not recompute the
    primal, providing the relevant state variables the primal (and derivative)
    depend on have not been changed in between.

    Additionally for `ChainState` instances initialized with a `_call_counts`
    argument, the memoized method will update a counter for the method in the
    `_call_counts` attribute every time the method being decorated is called
    (i.e. when there isn&#39;t a valid cached value available).

    Args:
        depends_on (str or Tuple[str]): A string or tuple of strings, with each
            string corresponding to the name of a state variables the value(s)
            returned by the method depends on, e.g. &#39;pos&#39; or &#39;mom&#39;, such that
            the cache in the state object is correctly cleared when the value of
            any of these variables (attributes) of the state object changes.
        auxiliary_outputs (str or Tuple[str]): A string or tuple of strings,
            with each string defining an auxiliary output the wrapped method may
            additionally return in addition to the primary output. If auxiliary
            outputs are returned, the returned value should be a tuple with
            first entry the &#39;primary&#39; output corresponding to the value
            associated with the name of the method and the subsequent entries in
            the tuple corresponding to the auxiliary outputs in the order
            specified by the entries in the `auxiliary_outputs` argument. If the
            primary output is itself a tuple, it must be wrapped in another
            tuple even when no auxiliary outputs are being returned.
    &#34;&#34;&#34;
    if isinstance(depends_on, str):
        depends_on = (depends_on,)
    if isinstance(auxiliary_outputs, str):
        auxiliary_outputs = (auxiliary_outputs,)

    def cache_in_state_with_aux_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            prim_key = _cache_key_func(self, method)
            keys = [prim_key] + [
                _cache_key_func(self, a) for a in auxiliary_outputs]
            for i, key in enumerate(keys):
                if key not in state._cache:
                    for dep in depends_on:
                        state._dependencies[dep].add(key)
            if prim_key not in state._cache or state._cache[prim_key] is None:
                vals = method(self, state)
                if isinstance(vals, tuple):
                    for k, v in zip(keys, vals):
                        state._cache[k] = v
                else:
                    state._cache[prim_key] = vals
                if state._call_counts is not None:
                    state._call_counts[prim_key] += 1
            return state._cache[prim_key]
        return wrapper

    return cache_in_state_with_aux_decorator</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mici.states.ChainState"><code class="flex name class">
<span>class <span class="ident">ChainState</span></span>
<span>(</span><span>**variables)</span>
</code></dt>
<dd>
<section class="desc"><p>Markov chain state.</p>
<p>As well as recording the chain state variable values, the state object is
also used to cache derived quantities to avoid recalculation if these
values are subsequently reused.</p>
<p>Additionally for <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a> instances initialized with a <code>_call_counts</code>
dictionary, any memoized system methods (i.e. those decorated with
<a title="mici.states.cache_in_state" href="#mici.states.cache_in_state"><code>cache_in_state()</code></a> or <a title="mici.states.cache_in_state_with_aux" href="#mici.states.cache_in_state_with_aux"><code>cache_in_state_with_aux()</code></a>) will update a counter for the
method in the state <code>_call_counts</code> dictionary attribute every time the
decorated method is called (i.e. when there isn't a valid cached value
available).</p>
<p>Create a new <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a> instance.</p>
<p>Any keyword arguments passed to the constructor (with names not starting
with an underscore) will be used to set state variable attributes of
state object for example</p>
<pre><code>state = ChainState(pos=pos_val, mom=mom_val, dir=dir_val)
</code></pre>
<p>will return a <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a> instance <code>state</code> with variable attributes
<code>state.pos</code>, <code>state.mom</code> and <code>state.dir</code> with initial values set to
<code>pos_val</code>, <code>mom_val</code> and <code>dir_val</code> respectively.</p>
<p>Keyword arguments with a leading underscore in the name are reserved
for additional arguments to the constructor not corresponding to
state variables. Additionally the name <code>copy</code> should not be used as
attribute access to this name will be blocked by the <code>copy</code> method.</p>
<h2 id="kwargs">Kwargs</h2>
<dl>
<dt><strong><code>**variables</code></strong></dt>
<dd>Keyword arguments corresponding to state variables. All
names must not begin with an underscore and no name can be
<code>copy</code>. See description above for details.</dd>
<dt><strong><code>_call_counts</code></strong> :&ensp;<code>None</code> or <code>Dict</code></dt>
<dd>If a dictionary is passed this will be
used to store counts of the number of calls of system methods
decorated with <a title="mici.states.cache_in_state" href="#mici.states.cache_in_state"><code>cache_in_state()</code></a> or <a title="mici.states.cache_in_state_with_aux" href="#mici.states.cache_in_state_with_aux"><code>cache_in_state_with_aux()</code></a>
when called on this state object and when no cached value for
the method is available so that the wrapped method is called.
The <code>_call_counts</code> dictionary persists between all copies of a
state so will count any decorated method calls on copies of the
state as well - e.g. all copies of a state in a sampled Markov
chain, allowing the <code>_call_counts</code> dictionary to be used to
monitor the number of method call while sampling a chain.</dd>
<dt><strong><code>_read_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code> a <a title="mici.errors.ReadOnlyStateError" href="errors.html#mici.errors.ReadOnlyStateError"><code>ReadOnlyStateError</code></a>
exception will be raised when attempting to set any attributes
of the state object after construction. Defaults to <code>False</code>.</dd>
<dt><strong><code>_dependencies</code></strong> :&ensp;<code>None</code> or <code>Dict</code></dt>
<dd>Intended for internal use only. If not
<code>None</code> this should be a dictionary with string keys
corresponding to the state variable names and values which are
sets of strings indicating any dependencies of the relevant
state variable in the cache.</dd>
<dt><strong><code>_cache</code></strong> :&ensp;<code>None</code> or <code>Dict</code></dt>
<dd>Intended for internal use only. If not <code>None</code>
this should be a dictionary with keys corresponding to unique
identifiers for methods decorated with the <a title="mici.states.cache_in_state" href="#mici.states.cache_in_state"><code>cache_in_state()</code></a> or
<a title="mici.states.cache_in_state_with_aux" href="#mici.states.cache_in_state_with_aux"><code>cache_in_state_with_aux()</code></a> decorators and values corresponding
to cached computed outputs of these methods or <code>None</code> for when
a cached output is not available.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/aaaad1aae5ce2d12baf95e59bc5ade40149c397b/mici/states.py#L133-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ChainState(object):
    &#34;&#34;&#34;Markov chain state.

    As well as recording the chain state variable values, the state object is
    also used to cache derived quantities to avoid recalculation if these
    values are subsequently reused.

    Additionally for `ChainState` instances initialized with a `_call_counts`
    dictionary, any memoized system methods (i.e. those decorated with
    `cache_in_state` or `cache_in_state_with_aux`) will update a counter for the
    method in the state `_call_counts` dictionary attribute every time the
    decorated method is called (i.e. when there isn&#39;t a valid cached value
    available).
    &#34;&#34;&#34;

    def __init__(self, *, _call_counts=None, _read_only=False,
                 _dependencies=None, _cache=None, **variables):
        &#34;&#34;&#34;Create a new `ChainState` instance.

        Any keyword arguments passed to the constructor (with names not starting
        with an underscore) will be used to set state variable attributes of
        state object for example

            state = ChainState(pos=pos_val, mom=mom_val, dir=dir_val)

        will return a `ChainState` instance `state` with variable attributes
        `state.pos`, `state.mom` and `state.dir` with initial values set to
        `pos_val`, `mom_val` and `dir_val` respectively.

        Keyword arguments with a leading underscore in the name are reserved
        for additional arguments to the constructor not corresponding to
        state variables. Additionally the name `copy` should not be used as
        attribute access to this name will be blocked by the `copy` method.

        Kwargs:
            **variables: Keyword arguments corresponding to state variables. All
                names must not begin with an underscore and no name can be
                `copy`. See description above for details.
            _call_counts (None or Dict): If a dictionary is passed this will be
                used to store counts of the number of calls of system methods
                decorated with `cache_in_state` or `cache_in_state_with_aux`
                when called on this state object and when no cached value for
                the method is available so that the wrapped method is called.
                The `_call_counts` dictionary persists between all copies of a
                state so will count any decorated method calls on copies of the
                state as well - e.g. all copies of a state in a sampled Markov
                chain, allowing the `_call_counts` dictionary to be used to
                monitor the number of method call while sampling a chain.
            _read_only (bool): If `True` a `mici.errors.ReadOnlyStateError`
                exception will be raised when attempting to set any attributes
                of the state object after construction. Defaults to `False`.
            _dependencies (None or Dict): Intended for internal use only. If not
                `None` this should be a dictionary with string keys
                corresponding to the state variable names and values which are
                sets of strings indicating any dependencies of the relevant
                state variable in the cache.
            _cache (None or Dict): Intended for internal use only. If not `None`
                this should be a dictionary with keys corresponding to unique
                identifiers for methods decorated with the `cache_in_state` or
                `cache_in_state_with_aux` decorators and values corresponding
                to cached computed outputs of these methods or `None` for when
                a cached output is not available.
        &#34;&#34;&#34;
        # Set attributes by directly writing to __dict__ to ensure set before
        # any call to __setattr__
        self.__dict__[&#39;_variables&#39;] = variables
        if _dependencies is None:
            _dependencies = {name: set() for name in variables}
        self.__dict__[&#39;_dependencies&#39;] = _dependencies
        if _cache is None:
            _cache = {}
        self.__dict__[&#39;_cache&#39;] = _cache
        self.__dict__[&#39;_call_counts&#39;] = (
            Counter(_call_counts) if not isinstance(_call_counts, Counter)
            else _call_counts)
        self.__dict__[&#39;_read_only&#39;] = _read_only

    def __getattr__(self, name):
        if name in self._variables:
            return self._variables[name]
        else:
            raise AttributeError(
                f&#34;&#39;{type(self).__name__}&#39; object has no attribute &#39;{name}&#39;&#34;)

    def __setattr__(self, name, value):
        if self._read_only:
            raise ReadOnlyStateError(&#39;ChainState instance is read-only.&#39;)
        if name in self._variables:
            self._variables[name] = value
            # clear any dependent cached values
            for dep in self._dependencies[name]:
                self._cache[dep] = None
        else:
            return super().__setattr__(name, value)

    def __contains__(self, name):
        return name in self._variables

    def copy(self, read_only=False):
        &#34;&#34;&#34;Create a deep copy of the state object.

        Args:
            read_only (bool): Whether the state copy should be read-only.

        Returns:
            state_copy (ChainState): A copy of the state object with variable
                attributes that are independent copies of the original state
                object&#39;s variables.
        &#34;&#34;&#34;
        return type(self)(
            _dependencies=self._dependencies, _cache=self._cache.copy(),
            _call_counts=self._call_counts, _read_only=read_only,
            **{name: copy.copy(val) for name, val in self._variables.items()})

    def __str__(self):
        return (
            &#39;(\n &#39; +
            &#39;,\n &#39;.join([f&#39;{k}={v}&#39; for k, v in self._variables.items()]) +
            &#39;)&#39;
        )

    def __repr__(self):
        return type(self).__name__ + str(self)

    def __getstate__(self):
        return {
            &#39;variables&#39;: self._variables,
            &#39;dependencies&#39;: self._dependencies,
            # Don&#39;t pickle callable cached &#39;variables&#39; such as derivative
            # functions
            &#39;cache&#39;: {k: v for k, v in self._cache.items() if not callable(v)},
            &#39;call_counts&#39;: self._call_counts,
            &#39;read_only&#39;: self._read_only}

    def __setstate__(self, state):
        self.__dict__[&#39;_variables&#39;] = state[&#39;variables&#39;]
        self.__dict__[&#39;_dependencies&#39;] = state[&#39;dependencies&#39;]
        self.__dict__[&#39;_cache&#39;] = state[&#39;cache&#39;]
        self.__dict__[&#39;_call_counts&#39;] = state[&#39;call_counts&#39;]
        self.__dict__[&#39;_read_only&#39;] = state[&#39;read_only&#39;]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mici.states.ChainState.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, read_only=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a deep copy of the state object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>read_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the state copy should be read-only.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state_copy</code></strong> :&ensp;<a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>A copy of the state object with variable
attributes that are independent copies of the original state
object's variables.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/aaaad1aae5ce2d12baf95e59bc5ade40149c397b/mici/states.py#L231-L245" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def copy(self, read_only=False):
    &#34;&#34;&#34;Create a deep copy of the state object.

    Args:
        read_only (bool): Whether the state copy should be read-only.

    Returns:
        state_copy (ChainState): A copy of the state object with variable
            attributes that are independent copies of the original state
            object&#39;s variables.
    &#34;&#34;&#34;
    return type(self)(
        _dependencies=self._dependencies, _cache=self._cache.copy(),
        _call_counts=self._call_counts, _read_only=read_only,
        **{name: copy.copy(val) for name, val in self._variables.items()})</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
Copyright Â© 2019 Matt Graham
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2.dev0+g1b644f6.d20200630</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad(); hljs.configure({languages: ["python"]});</script>
</body>
</html>